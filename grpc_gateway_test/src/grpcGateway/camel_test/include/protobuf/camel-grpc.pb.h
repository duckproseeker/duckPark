// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camel-grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_camel_2dgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_camel_2dgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "camel-agvs.pb.h"
#include "camel-common.pb.h"
#include "camel-db.pb.h"
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_camel_2dgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_camel_2dgrpc_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_camel_2dgrpc_2eproto;
class AgvInfo;
struct AgvInfoDefaultTypeInternal;
extern AgvInfoDefaultTypeInternal _AgvInfo_default_instance_;
class AgvInfo_Alarm;
struct AgvInfo_AlarmDefaultTypeInternal;
extern AgvInfo_AlarmDefaultTypeInternal _AgvInfo_Alarm_default_instance_;
class AgvInfo_DebugInfo;
struct AgvInfo_DebugInfoDefaultTypeInternal;
extern AgvInfo_DebugInfoDefaultTypeInternal _AgvInfo_DebugInfo_default_instance_;
class AgvInfo_Motion;
struct AgvInfo_MotionDefaultTypeInternal;
extern AgvInfo_MotionDefaultTypeInternal _AgvInfo_Motion_default_instance_;
class AgvInfo_UIStation;
struct AgvInfo_UIStationDefaultTypeInternal;
extern AgvInfo_UIStationDefaultTypeInternal _AgvInfo_UIStation_default_instance_;
class AlarmMsg;
struct AlarmMsgDefaultTypeInternal;
extern AlarmMsgDefaultTypeInternal _AlarmMsg_default_instance_;
class CamelCfg;
struct CamelCfgDefaultTypeInternal;
extern CamelCfgDefaultTypeInternal _CamelCfg_default_instance_;
class CamelSysInfo;
struct CamelSysInfoDefaultTypeInternal;
extern CamelSysInfoDefaultTypeInternal _CamelSysInfo_default_instance_;
class InstallPack;
struct InstallPackDefaultTypeInternal;
extern InstallPackDefaultTypeInternal _InstallPack_default_instance_;
class LogRequest;
struct LogRequestDefaultTypeInternal;
extern LogRequestDefaultTypeInternal _LogRequest_default_instance_;
class LogResponse;
struct LogResponseDefaultTypeInternal;
extern LogResponseDefaultTypeInternal _LogResponse_default_instance_;
class NetworkConfig;
struct NetworkConfigDefaultTypeInternal;
extern NetworkConfigDefaultTypeInternal _NetworkConfig_default_instance_;
class NetworkConfigCollection;
struct NetworkConfigCollectionDefaultTypeInternal;
extern NetworkConfigCollectionDefaultTypeInternal _NetworkConfigCollection_default_instance_;
class Operation;
struct OperationDefaultTypeInternal;
extern OperationDefaultTypeInternal _Operation_default_instance_;
class RosNode;
struct RosNodeDefaultTypeInternal;
extern RosNodeDefaultTypeInternal _RosNode_default_instance_;
class RosNodesCfg;
struct RosNodesCfgDefaultTypeInternal;
extern RosNodesCfgDefaultTypeInternal _RosNodesCfg_default_instance_;
class RosoutMsg;
struct RosoutMsgDefaultTypeInternal;
extern RosoutMsgDefaultTypeInternal _RosoutMsg_default_instance_;
class RosoutMsg_RosoutInfo;
struct RosoutMsg_RosoutInfoDefaultTypeInternal;
extern RosoutMsg_RosoutInfoDefaultTypeInternal _RosoutMsg_RosoutInfo_default_instance_;
class SystemStatus;
struct SystemStatusDefaultTypeInternal;
extern SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
class UIConfig;
struct UIConfigDefaultTypeInternal;
extern UIConfigDefaultTypeInternal _UIConfig_default_instance_;
class UpdatePose;
struct UpdatePoseDefaultTypeInternal;
extern UpdatePoseDefaultTypeInternal _UpdatePose_default_instance_;
class UpdateStation;
struct UpdateStationDefaultTypeInternal;
extern UpdateStationDefaultTypeInternal _UpdateStation_default_instance_;
class Version;
struct VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class WLANList;
struct WLANListDefaultTypeInternal;
extern WLANListDefaultTypeInternal _WLANList_default_instance_;
class WirlessConfig;
struct WirlessConfigDefaultTypeInternal;
extern WirlessConfigDefaultTypeInternal _WirlessConfig_default_instance_;
class WirlessInfo;
struct WirlessInfoDefaultTypeInternal;
extern WirlessInfoDefaultTypeInternal _WirlessInfo_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AgvInfo* Arena::CreateMaybeMessage<::AgvInfo>(Arena*);
template<> ::AgvInfo_Alarm* Arena::CreateMaybeMessage<::AgvInfo_Alarm>(Arena*);
template<> ::AgvInfo_DebugInfo* Arena::CreateMaybeMessage<::AgvInfo_DebugInfo>(Arena*);
template<> ::AgvInfo_Motion* Arena::CreateMaybeMessage<::AgvInfo_Motion>(Arena*);
template<> ::AgvInfo_UIStation* Arena::CreateMaybeMessage<::AgvInfo_UIStation>(Arena*);
template<> ::AlarmMsg* Arena::CreateMaybeMessage<::AlarmMsg>(Arena*);
template<> ::CamelCfg* Arena::CreateMaybeMessage<::CamelCfg>(Arena*);
template<> ::CamelSysInfo* Arena::CreateMaybeMessage<::CamelSysInfo>(Arena*);
template<> ::InstallPack* Arena::CreateMaybeMessage<::InstallPack>(Arena*);
template<> ::LogRequest* Arena::CreateMaybeMessage<::LogRequest>(Arena*);
template<> ::LogResponse* Arena::CreateMaybeMessage<::LogResponse>(Arena*);
template<> ::NetworkConfig* Arena::CreateMaybeMessage<::NetworkConfig>(Arena*);
template<> ::NetworkConfigCollection* Arena::CreateMaybeMessage<::NetworkConfigCollection>(Arena*);
template<> ::Operation* Arena::CreateMaybeMessage<::Operation>(Arena*);
template<> ::RosNode* Arena::CreateMaybeMessage<::RosNode>(Arena*);
template<> ::RosNodesCfg* Arena::CreateMaybeMessage<::RosNodesCfg>(Arena*);
template<> ::RosoutMsg* Arena::CreateMaybeMessage<::RosoutMsg>(Arena*);
template<> ::RosoutMsg_RosoutInfo* Arena::CreateMaybeMessage<::RosoutMsg_RosoutInfo>(Arena*);
template<> ::SystemStatus* Arena::CreateMaybeMessage<::SystemStatus>(Arena*);
template<> ::UIConfig* Arena::CreateMaybeMessage<::UIConfig>(Arena*);
template<> ::UpdatePose* Arena::CreateMaybeMessage<::UpdatePose>(Arena*);
template<> ::UpdateStation* Arena::CreateMaybeMessage<::UpdateStation>(Arena*);
template<> ::Version* Arena::CreateMaybeMessage<::Version>(Arena*);
template<> ::WLANList* Arena::CreateMaybeMessage<::WLANList>(Arena*);
template<> ::WirlessConfig* Arena::CreateMaybeMessage<::WirlessConfig>(Arena*);
template<> ::WirlessInfo* Arena::CreateMaybeMessage<::WirlessInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum AgvInfo_Alarm_Source : int {
  AgvInfo_Alarm_Source_PLC_MCU = 0,
  AgvInfo_Alarm_Source_Camel = 1,
  AgvInfo_Alarm_Source_Controller = 2,
  AgvInfo_Alarm_Source_Nav = 3,
  AgvInfo_Alarm_Source_AGVS = 4,
  AgvInfo_Alarm_Source_Defender = 5,
  AgvInfo_Alarm_Source_Unknow = 6,
  AgvInfo_Alarm_Source_AgvInfo_Alarm_Source_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AgvInfo_Alarm_Source_AgvInfo_Alarm_Source_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AgvInfo_Alarm_Source_IsValid(int value);
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm_Source_Source_MIN = AgvInfo_Alarm_Source_PLC_MCU;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm_Source_Source_MAX = AgvInfo_Alarm_Source_Unknow;
constexpr int AgvInfo_Alarm_Source_Source_ARRAYSIZE = AgvInfo_Alarm_Source_Source_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgvInfo_Alarm_Source_descriptor();
template<typename T>
inline const std::string& AgvInfo_Alarm_Source_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AgvInfo_Alarm_Source>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AgvInfo_Alarm_Source_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AgvInfo_Alarm_Source_descriptor(), enum_t_value);
}
inline bool AgvInfo_Alarm_Source_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AgvInfo_Alarm_Source* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AgvInfo_Alarm_Source>(
    AgvInfo_Alarm_Source_descriptor(), name, value);
}
enum AgvInfo_Alarm_Level : int {
  AgvInfo_Alarm_Level_General = 0,
  AgvInfo_Alarm_Level_Serious = 1,
  AgvInfo_Alarm_Level_Fatal = 2,
  AgvInfo_Alarm_Level_AgvInfo_Alarm_Level_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AgvInfo_Alarm_Level_AgvInfo_Alarm_Level_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AgvInfo_Alarm_Level_IsValid(int value);
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm_Level_Level_MIN = AgvInfo_Alarm_Level_General;
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm_Level_Level_MAX = AgvInfo_Alarm_Level_Fatal;
constexpr int AgvInfo_Alarm_Level_Level_ARRAYSIZE = AgvInfo_Alarm_Level_Level_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgvInfo_Alarm_Level_descriptor();
template<typename T>
inline const std::string& AgvInfo_Alarm_Level_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AgvInfo_Alarm_Level>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AgvInfo_Alarm_Level_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AgvInfo_Alarm_Level_descriptor(), enum_t_value);
}
inline bool AgvInfo_Alarm_Level_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AgvInfo_Alarm_Level* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AgvInfo_Alarm_Level>(
    AgvInfo_Alarm_Level_descriptor(), name, value);
}
enum Language : int {
  en_us = 0,
  zh_cn = 1,
  Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Language_IsValid(int value);
constexpr Language Language_MIN = en_us;
constexpr Language Language_MAX = zh_cn;
constexpr int Language_ARRAYSIZE = Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor();
template<typename T>
inline const std::string& Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_descriptor(), enum_t_value);
}
inline bool Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language>(
    Language_descriptor(), name, value);
}
// ===================================================================

class AgvInfo_UIStation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgvInfo.UIStation) */ {
 public:
  inline AgvInfo_UIStation() : AgvInfo_UIStation(nullptr) {}
  ~AgvInfo_UIStation() override;
  explicit PROTOBUF_CONSTEXPR AgvInfo_UIStation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgvInfo_UIStation(const AgvInfo_UIStation& from);
  AgvInfo_UIStation(AgvInfo_UIStation&& from) noexcept
    : AgvInfo_UIStation() {
    *this = ::std::move(from);
  }

  inline AgvInfo_UIStation& operator=(const AgvInfo_UIStation& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgvInfo_UIStation& operator=(AgvInfo_UIStation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgvInfo_UIStation& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgvInfo_UIStation* internal_default_instance() {
    return reinterpret_cast<const AgvInfo_UIStation*>(
               &_AgvInfo_UIStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AgvInfo_UIStation& a, AgvInfo_UIStation& b) {
    a.Swap(&b);
  }
  inline void Swap(AgvInfo_UIStation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgvInfo_UIStation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgvInfo_UIStation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgvInfo_UIStation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgvInfo_UIStation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgvInfo_UIStation& from) {
    AgvInfo_UIStation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgvInfo_UIStation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgvInfo.UIStation";
  }
  protected:
  explicit AgvInfo_UIStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationOnMapFieldNumber = 1,
    kStationOnPathFieldNumber = 2,
    kTargetStationFieldNumber = 3,
  };
  // string stationOnMap = 1;
  void clear_stationonmap();
  const std::string& stationonmap() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationonmap(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationonmap();
  PROTOBUF_NODISCARD std::string* release_stationonmap();
  void set_allocated_stationonmap(std::string* stationonmap);
  private:
  const std::string& _internal_stationonmap() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationonmap(const std::string& value);
  std::string* _internal_mutable_stationonmap();
  public:

  // string stationOnPath = 2;
  void clear_stationonpath();
  const std::string& stationonpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stationonpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stationonpath();
  PROTOBUF_NODISCARD std::string* release_stationonpath();
  void set_allocated_stationonpath(std::string* stationonpath);
  private:
  const std::string& _internal_stationonpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stationonpath(const std::string& value);
  std::string* _internal_mutable_stationonpath();
  public:

  // string targetStation = 3;
  void clear_targetstation();
  const std::string& targetstation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetstation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetstation();
  PROTOBUF_NODISCARD std::string* release_targetstation();
  void set_allocated_targetstation(std::string* targetstation);
  private:
  const std::string& _internal_targetstation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetstation(const std::string& value);
  std::string* _internal_mutable_targetstation();
  public:

  // @@protoc_insertion_point(class_scope:AgvInfo.UIStation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationonmap_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stationonpath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetstation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class AgvInfo_Motion final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgvInfo.Motion) */ {
 public:
  inline AgvInfo_Motion() : AgvInfo_Motion(nullptr) {}
  ~AgvInfo_Motion() override;
  explicit PROTOBUF_CONSTEXPR AgvInfo_Motion(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgvInfo_Motion(const AgvInfo_Motion& from);
  AgvInfo_Motion(AgvInfo_Motion&& from) noexcept
    : AgvInfo_Motion() {
    *this = ::std::move(from);
  }

  inline AgvInfo_Motion& operator=(const AgvInfo_Motion& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgvInfo_Motion& operator=(AgvInfo_Motion&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgvInfo_Motion& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgvInfo_Motion* internal_default_instance() {
    return reinterpret_cast<const AgvInfo_Motion*>(
               &_AgvInfo_Motion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AgvInfo_Motion& a, AgvInfo_Motion& b) {
    a.Swap(&b);
  }
  inline void Swap(AgvInfo_Motion* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgvInfo_Motion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgvInfo_Motion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgvInfo_Motion>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgvInfo_Motion& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgvInfo_Motion& from) {
    AgvInfo_Motion::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgvInfo_Motion* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgvInfo.Motion";
  }
  protected:
  explicit AgvInfo_Motion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVxFieldNumber = 1,
    kVyFieldNumber = 2,
    kWFieldNumber = 3,
    kOd1FieldNumber = 4,
    kOd2FieldNumber = 5,
  };
  // float vx = 1;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 2;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float w = 3;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float od1 = 4;
  void clear_od1();
  float od1() const;
  void set_od1(float value);
  private:
  float _internal_od1() const;
  void _internal_set_od1(float value);
  public:

  // float od2 = 5;
  void clear_od2();
  float od2() const;
  void set_od2(float value);
  private:
  float _internal_od2() const;
  void _internal_set_od2(float value);
  public:

  // @@protoc_insertion_point(class_scope:AgvInfo.Motion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float vx_;
    float vy_;
    float w_;
    float od1_;
    float od2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class AgvInfo_Alarm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgvInfo.Alarm) */ {
 public:
  inline AgvInfo_Alarm() : AgvInfo_Alarm(nullptr) {}
  ~AgvInfo_Alarm() override;
  explicit PROTOBUF_CONSTEXPR AgvInfo_Alarm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgvInfo_Alarm(const AgvInfo_Alarm& from);
  AgvInfo_Alarm(AgvInfo_Alarm&& from) noexcept
    : AgvInfo_Alarm() {
    *this = ::std::move(from);
  }

  inline AgvInfo_Alarm& operator=(const AgvInfo_Alarm& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgvInfo_Alarm& operator=(AgvInfo_Alarm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgvInfo_Alarm& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgvInfo_Alarm* internal_default_instance() {
    return reinterpret_cast<const AgvInfo_Alarm*>(
               &_AgvInfo_Alarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AgvInfo_Alarm& a, AgvInfo_Alarm& b) {
    a.Swap(&b);
  }
  inline void Swap(AgvInfo_Alarm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgvInfo_Alarm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgvInfo_Alarm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgvInfo_Alarm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgvInfo_Alarm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgvInfo_Alarm& from) {
    AgvInfo_Alarm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgvInfo_Alarm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgvInfo.Alarm";
  }
  protected:
  explicit AgvInfo_Alarm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AgvInfo_Alarm_Source Source;
  static constexpr Source PLC_MCU =
    AgvInfo_Alarm_Source_PLC_MCU;
  static constexpr Source Camel =
    AgvInfo_Alarm_Source_Camel;
  static constexpr Source Controller =
    AgvInfo_Alarm_Source_Controller;
  static constexpr Source Nav =
    AgvInfo_Alarm_Source_Nav;
  static constexpr Source AGVS =
    AgvInfo_Alarm_Source_AGVS;
  static constexpr Source Defender =
    AgvInfo_Alarm_Source_Defender;
  static constexpr Source Unknow =
    AgvInfo_Alarm_Source_Unknow;
  static inline bool Source_IsValid(int value) {
    return AgvInfo_Alarm_Source_IsValid(value);
  }
  static constexpr Source Source_MIN =
    AgvInfo_Alarm_Source_Source_MIN;
  static constexpr Source Source_MAX =
    AgvInfo_Alarm_Source_Source_MAX;
  static constexpr int Source_ARRAYSIZE =
    AgvInfo_Alarm_Source_Source_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Source_descriptor() {
    return AgvInfo_Alarm_Source_descriptor();
  }
  template<typename T>
  static inline const std::string& Source_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Source>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Source_Name.");
    return AgvInfo_Alarm_Source_Name(enum_t_value);
  }
  static inline bool Source_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Source* value) {
    return AgvInfo_Alarm_Source_Parse(name, value);
  }

  typedef AgvInfo_Alarm_Level Level;
  static constexpr Level General =
    AgvInfo_Alarm_Level_General;
  static constexpr Level Serious =
    AgvInfo_Alarm_Level_Serious;
  static constexpr Level Fatal =
    AgvInfo_Alarm_Level_Fatal;
  static inline bool Level_IsValid(int value) {
    return AgvInfo_Alarm_Level_IsValid(value);
  }
  static constexpr Level Level_MIN =
    AgvInfo_Alarm_Level_Level_MIN;
  static constexpr Level Level_MAX =
    AgvInfo_Alarm_Level_Level_MAX;
  static constexpr int Level_ARRAYSIZE =
    AgvInfo_Alarm_Level_Level_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Level_descriptor() {
    return AgvInfo_Alarm_Level_descriptor();
  }
  template<typename T>
  static inline const std::string& Level_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Level>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Level_Name.");
    return AgvInfo_Alarm_Level_Name(enum_t_value);
  }
  static inline bool Level_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Level* value) {
    return AgvInfo_Alarm_Level_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kTimeFieldNumber = 4,
    kTypeFieldNumber = 1,
    kLevelFieldNumber = 2,
    kCodeFieldNumber = 5,
  };
  // bytes message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .AgvInfo.Alarm.Source type = 1;
  void clear_type();
  ::AgvInfo_Alarm_Source type() const;
  void set_type(::AgvInfo_Alarm_Source value);
  private:
  ::AgvInfo_Alarm_Source _internal_type() const;
  void _internal_set_type(::AgvInfo_Alarm_Source value);
  public:

  // .AgvInfo.Alarm.Level level = 2;
  void clear_level();
  ::AgvInfo_Alarm_Level level() const;
  void set_level(::AgvInfo_Alarm_Level value);
  private:
  ::AgvInfo_Alarm_Level _internal_level() const;
  void _internal_set_level(::AgvInfo_Alarm_Level value);
  public:

  // int32 code = 5;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AgvInfo.Alarm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    int type_;
    int level_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class AgvInfo_DebugInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgvInfo.DebugInfo) */ {
 public:
  inline AgvInfo_DebugInfo() : AgvInfo_DebugInfo(nullptr) {}
  ~AgvInfo_DebugInfo() override;
  explicit PROTOBUF_CONSTEXPR AgvInfo_DebugInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgvInfo_DebugInfo(const AgvInfo_DebugInfo& from);
  AgvInfo_DebugInfo(AgvInfo_DebugInfo&& from) noexcept
    : AgvInfo_DebugInfo() {
    *this = ::std::move(from);
  }

  inline AgvInfo_DebugInfo& operator=(const AgvInfo_DebugInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgvInfo_DebugInfo& operator=(AgvInfo_DebugInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgvInfo_DebugInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgvInfo_DebugInfo* internal_default_instance() {
    return reinterpret_cast<const AgvInfo_DebugInfo*>(
               &_AgvInfo_DebugInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AgvInfo_DebugInfo& a, AgvInfo_DebugInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AgvInfo_DebugInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgvInfo_DebugInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgvInfo_DebugInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgvInfo_DebugInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgvInfo_DebugInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgvInfo_DebugInfo& from) {
    AgvInfo_DebugInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgvInfo_DebugInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgvInfo.DebugInfo";
  }
  protected:
  explicit AgvInfo_DebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVxFieldNumber = 1,
    kVyFieldNumber = 2,
    kWFieldNumber = 3,
    kGoalXFieldNumber = 4,
    kTimestampFieldNumber = 6,
    kGoalYFieldNumber = 5,
    kTaskAverageVelocityFieldNumber = 7,
    kTotalTaskAverageVelocityFieldNumber = 8,
    kTotalOdometryFieldNumber = 9,
    kTotalRuntimeFieldNumber = 10,
  };
  // float Vx = 1;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float Vy = 2;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float W = 3;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float GoalX = 4;
  void clear_goalx();
  float goalx() const;
  void set_goalx(float value);
  private:
  float _internal_goalx() const;
  void _internal_set_goalx(float value);
  public:

  // uint64 timestamp = 6;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // float GoalY = 5;
  void clear_goaly();
  float goaly() const;
  void set_goaly(float value);
  private:
  float _internal_goaly() const;
  void _internal_set_goaly(float value);
  public:

  // float TaskAverageVelocity = 7;
  void clear_taskaveragevelocity();
  float taskaveragevelocity() const;
  void set_taskaveragevelocity(float value);
  private:
  float _internal_taskaveragevelocity() const;
  void _internal_set_taskaveragevelocity(float value);
  public:

  // float TotalTaskAverageVelocity = 8;
  void clear_totaltaskaveragevelocity();
  float totaltaskaveragevelocity() const;
  void set_totaltaskaveragevelocity(float value);
  private:
  float _internal_totaltaskaveragevelocity() const;
  void _internal_set_totaltaskaveragevelocity(float value);
  public:

  // float TotalOdometry = 9;
  void clear_totalodometry();
  float totalodometry() const;
  void set_totalodometry(float value);
  private:
  float _internal_totalodometry() const;
  void _internal_set_totalodometry(float value);
  public:

  // float TotalRuntime = 10;
  void clear_totalruntime();
  float totalruntime() const;
  void set_totalruntime(float value);
  private:
  float _internal_totalruntime() const;
  void _internal_set_totalruntime(float value);
  public:

  // @@protoc_insertion_point(class_scope:AgvInfo.DebugInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float vx_;
    float vy_;
    float w_;
    float goalx_;
    uint64_t timestamp_;
    float goaly_;
    float taskaveragevelocity_;
    float totaltaskaveragevelocity_;
    float totalodometry_;
    float totalruntime_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class AgvInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AgvInfo) */ {
 public:
  inline AgvInfo() : AgvInfo(nullptr) {}
  ~AgvInfo() override;
  explicit PROTOBUF_CONSTEXPR AgvInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgvInfo(const AgvInfo& from);
  AgvInfo(AgvInfo&& from) noexcept
    : AgvInfo() {
    *this = ::std::move(from);
  }

  inline AgvInfo& operator=(const AgvInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgvInfo& operator=(AgvInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgvInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgvInfo* internal_default_instance() {
    return reinterpret_cast<const AgvInfo*>(
               &_AgvInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AgvInfo& a, AgvInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AgvInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgvInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AgvInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AgvInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AgvInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AgvInfo& from) {
    AgvInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgvInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AgvInfo";
  }
  protected:
  explicit AgvInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AgvInfo_UIStation UIStation;
  typedef AgvInfo_Motion Motion;
  typedef AgvInfo_Alarm Alarm;
  typedef AgvInfo_DebugInfo DebugInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kAlarmFieldNumber = 4,
    kMontionFieldNumber = 1,
    kPostionFieldNumber = 2,
    kStationFieldNumber = 3,
    kBatteryFieldNumber = 5,
    kRouteFieldNumber = 9,
    kVersionFieldNumber = 11,
    kDebugFieldNumber = 12,
    kAgvsInfoFieldNumber = 13,
    kGrpcTaskFieldNumber = 14,
    kRunModeFieldNumber = 6,
    kHeightFieldNumber = 7,
    kRunStatusFieldNumber = 10,
  };
  // repeated .AgvInfo.Alarm alarm = 4;
  int alarm_size() const;
  private:
  int _internal_alarm_size() const;
  public:
  void clear_alarm();
  ::AgvInfo_Alarm* mutable_alarm(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AgvInfo_Alarm >*
      mutable_alarm();
  private:
  const ::AgvInfo_Alarm& _internal_alarm(int index) const;
  ::AgvInfo_Alarm* _internal_add_alarm();
  public:
  const ::AgvInfo_Alarm& alarm(int index) const;
  ::AgvInfo_Alarm* add_alarm();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AgvInfo_Alarm >&
      alarm() const;

  // .AgvInfo.Motion montion = 1;
  bool has_montion() const;
  private:
  bool _internal_has_montion() const;
  public:
  void clear_montion();
  const ::AgvInfo_Motion& montion() const;
  PROTOBUF_NODISCARD ::AgvInfo_Motion* release_montion();
  ::AgvInfo_Motion* mutable_montion();
  void set_allocated_montion(::AgvInfo_Motion* montion);
  private:
  const ::AgvInfo_Motion& _internal_montion() const;
  ::AgvInfo_Motion* _internal_mutable_montion();
  public:
  void unsafe_arena_set_allocated_montion(
      ::AgvInfo_Motion* montion);
  ::AgvInfo_Motion* unsafe_arena_release_montion();

  // .Position postion = 2;
  bool has_postion() const;
  private:
  bool _internal_has_postion() const;
  public:
  void clear_postion();
  const ::Position& postion() const;
  PROTOBUF_NODISCARD ::Position* release_postion();
  ::Position* mutable_postion();
  void set_allocated_postion(::Position* postion);
  private:
  const ::Position& _internal_postion() const;
  ::Position* _internal_mutable_postion();
  public:
  void unsafe_arena_set_allocated_postion(
      ::Position* postion);
  ::Position* unsafe_arena_release_postion();

  // .AgvInfo.UIStation station = 3;
  bool has_station() const;
  private:
  bool _internal_has_station() const;
  public:
  void clear_station();
  const ::AgvInfo_UIStation& station() const;
  PROTOBUF_NODISCARD ::AgvInfo_UIStation* release_station();
  ::AgvInfo_UIStation* mutable_station();
  void set_allocated_station(::AgvInfo_UIStation* station);
  private:
  const ::AgvInfo_UIStation& _internal_station() const;
  ::AgvInfo_UIStation* _internal_mutable_station();
  public:
  void unsafe_arena_set_allocated_station(
      ::AgvInfo_UIStation* station);
  ::AgvInfo_UIStation* unsafe_arena_release_station();

  // .Battery battery = 5;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  const ::Battery& battery() const;
  PROTOBUF_NODISCARD ::Battery* release_battery();
  ::Battery* mutable_battery();
  void set_allocated_battery(::Battery* battery);
  private:
  const ::Battery& _internal_battery() const;
  ::Battery* _internal_mutable_battery();
  public:
  void unsafe_arena_set_allocated_battery(
      ::Battery* battery);
  ::Battery* unsafe_arena_release_battery();

  // .PathCollection route = 9;
  bool has_route() const;
  private:
  bool _internal_has_route() const;
  public:
  void clear_route();
  const ::PathCollection& route() const;
  PROTOBUF_NODISCARD ::PathCollection* release_route();
  ::PathCollection* mutable_route();
  void set_allocated_route(::PathCollection* route);
  private:
  const ::PathCollection& _internal_route() const;
  ::PathCollection* _internal_mutable_route();
  public:
  void unsafe_arena_set_allocated_route(
      ::PathCollection* route);
  ::PathCollection* unsafe_arena_release_route();

  // .Version version = 11;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::Version& version() const;
  PROTOBUF_NODISCARD ::Version* release_version();
  ::Version* mutable_version();
  void set_allocated_version(::Version* version);
  private:
  const ::Version& _internal_version() const;
  ::Version* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::Version* version);
  ::Version* unsafe_arena_release_version();

  // .AgvInfo.DebugInfo debug = 12;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  const ::AgvInfo_DebugInfo& debug() const;
  PROTOBUF_NODISCARD ::AgvInfo_DebugInfo* release_debug();
  ::AgvInfo_DebugInfo* mutable_debug();
  void set_allocated_debug(::AgvInfo_DebugInfo* debug);
  private:
  const ::AgvInfo_DebugInfo& _internal_debug() const;
  ::AgvInfo_DebugInfo* _internal_mutable_debug();
  public:
  void unsafe_arena_set_allocated_debug(
      ::AgvInfo_DebugInfo* debug);
  ::AgvInfo_DebugInfo* unsafe_arena_release_debug();

  // .CamelSysInfo agvsInfo = 13;
  bool has_agvsinfo() const;
  private:
  bool _internal_has_agvsinfo() const;
  public:
  void clear_agvsinfo();
  const ::CamelSysInfo& agvsinfo() const;
  PROTOBUF_NODISCARD ::CamelSysInfo* release_agvsinfo();
  ::CamelSysInfo* mutable_agvsinfo();
  void set_allocated_agvsinfo(::CamelSysInfo* agvsinfo);
  private:
  const ::CamelSysInfo& _internal_agvsinfo() const;
  ::CamelSysInfo* _internal_mutable_agvsinfo();
  public:
  void unsafe_arena_set_allocated_agvsinfo(
      ::CamelSysInfo* agvsinfo);
  ::CamelSysInfo* unsafe_arena_release_agvsinfo();

  // .GrpcTaskInfomation grpcTask = 14;
  bool has_grpctask() const;
  private:
  bool _internal_has_grpctask() const;
  public:
  void clear_grpctask();
  const ::GrpcTaskInfomation& grpctask() const;
  PROTOBUF_NODISCARD ::GrpcTaskInfomation* release_grpctask();
  ::GrpcTaskInfomation* mutable_grpctask();
  void set_allocated_grpctask(::GrpcTaskInfomation* grpctask);
  private:
  const ::GrpcTaskInfomation& _internal_grpctask() const;
  ::GrpcTaskInfomation* _internal_mutable_grpctask();
  public:
  void unsafe_arena_set_allocated_grpctask(
      ::GrpcTaskInfomation* grpctask);
  ::GrpcTaskInfomation* unsafe_arena_release_grpctask();

  // int32 runMode = 6;
  void clear_runmode();
  int32_t runmode() const;
  void set_runmode(int32_t value);
  private:
  int32_t _internal_runmode() const;
  void _internal_set_runmode(int32_t value);
  public:

  // float height = 7;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // int32 runStatus = 10;
  void clear_runstatus();
  int32_t runstatus() const;
  void set_runstatus(int32_t value);
  private:
  int32_t _internal_runstatus() const;
  void _internal_set_runstatus(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AgvInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AgvInfo_Alarm > alarm_;
    ::AgvInfo_Motion* montion_;
    ::Position* postion_;
    ::AgvInfo_UIStation* station_;
    ::Battery* battery_;
    ::PathCollection* route_;
    ::Version* version_;
    ::AgvInfo_DebugInfo* debug_;
    ::CamelSysInfo* agvsinfo_;
    ::GrpcTaskInfomation* grpctask_;
    int32_t runmode_;
    float height_;
    int32_t runstatus_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class UIConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UIConfig) */ {
 public:
  inline UIConfig() : UIConfig(nullptr) {}
  ~UIConfig() override;
  explicit PROTOBUF_CONSTEXPR UIConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UIConfig(const UIConfig& from);
  UIConfig(UIConfig&& from) noexcept
    : UIConfig() {
    *this = ::std::move(from);
  }

  inline UIConfig& operator=(const UIConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline UIConfig& operator=(UIConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UIConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const UIConfig* internal_default_instance() {
    return reinterpret_cast<const UIConfig*>(
               &_UIConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UIConfig& a, UIConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(UIConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UIConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UIConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UIConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UIConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UIConfig& from) {
    UIConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UIConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UIConfig";
  }
  protected:
  explicit UIConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNavEndpointFieldNumber = 1,
    kLanguageFieldNumber = 2,
  };
  // string navEndpoint = 1;
  void clear_navendpoint();
  const std::string& navendpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_navendpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_navendpoint();
  PROTOBUF_NODISCARD std::string* release_navendpoint();
  void set_allocated_navendpoint(std::string* navendpoint);
  private:
  const std::string& _internal_navendpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_navendpoint(const std::string& value);
  std::string* _internal_mutable_navendpoint();
  public:

  // .Language language = 2;
  void clear_language();
  ::Language language() const;
  void set_language(::Language value);
  private:
  ::Language _internal_language() const;
  void _internal_set_language(::Language value);
  public:

  // @@protoc_insertion_point(class_scope:UIConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr navendpoint_;
    int language_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class Version final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Version) */ {
 public:
  inline Version() : Version(nullptr) {}
  ~Version() override;
  explicit PROTOBUF_CONSTEXPR Version(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Version(const Version& from);
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  inline Version& operator=(Version&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Version& default_instance() {
    return *internal_default_instance();
  }
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }
  inline void Swap(Version* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Version* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Version* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Version& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Version& from) {
    Version::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Version";
  }
  protected:
  explicit Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCamelVersionFieldNumber = 1,
    kDBVersionFieldNumber = 2,
    kDefenderVersionFieldNumber = 3,
    kPackageVersionFieldNumber = 4,
  };
  // string CamelVersion = 1;
  void clear_camelversion();
  const std::string& camelversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_camelversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_camelversion();
  PROTOBUF_NODISCARD std::string* release_camelversion();
  void set_allocated_camelversion(std::string* camelversion);
  private:
  const std::string& _internal_camelversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_camelversion(const std::string& value);
  std::string* _internal_mutable_camelversion();
  public:

  // bytes DBVersion = 2;
  void clear_dbversion();
  const std::string& dbversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dbversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dbversion();
  PROTOBUF_NODISCARD std::string* release_dbversion();
  void set_allocated_dbversion(std::string* dbversion);
  private:
  const std::string& _internal_dbversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dbversion(const std::string& value);
  std::string* _internal_mutable_dbversion();
  public:

  // string DefenderVersion = 3;
  void clear_defenderversion();
  const std::string& defenderversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_defenderversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_defenderversion();
  PROTOBUF_NODISCARD std::string* release_defenderversion();
  void set_allocated_defenderversion(std::string* defenderversion);
  private:
  const std::string& _internal_defenderversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_defenderversion(const std::string& value);
  std::string* _internal_mutable_defenderversion();
  public:

  // string PackageVersion = 4;
  void clear_packageversion();
  const std::string& packageversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_packageversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_packageversion();
  PROTOBUF_NODISCARD std::string* release_packageversion();
  void set_allocated_packageversion(std::string* packageversion);
  private:
  const std::string& _internal_packageversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_packageversion(const std::string& value);
  std::string* _internal_mutable_packageversion();
  public:

  // @@protoc_insertion_point(class_scope:Version)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr camelversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dbversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr defenderversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr packageversion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Operation) */ {
 public:
  inline Operation() : Operation(nullptr) {}
  ~Operation() override;
  explicit PROTOBUF_CONSTEXPR Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Operation(const Operation& from);
  Operation(Operation&& from) noexcept
    : Operation() {
    *this = ::std::move(from);
  }

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Operation& operator=(Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Operation& default_instance() {
    return *internal_default_instance();
  }
  static inline const Operation* internal_default_instance() {
    return reinterpret_cast<const Operation*>(
               &_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Operation& a, Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Operation& from) {
    Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Operation";
  }
  protected:
  explicit Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsContinueFieldNumber = 1,
    kClearPathFieldNumber = 2,
    kClearActionFieldNumber = 3,
    kDisableCargoFieldNumber = 4,
  };
  // bool isContinue = 1;
  void clear_iscontinue();
  bool iscontinue() const;
  void set_iscontinue(bool value);
  private:
  bool _internal_iscontinue() const;
  void _internal_set_iscontinue(bool value);
  public:

  // bool clearPath = 2;
  void clear_clearpath();
  bool clearpath() const;
  void set_clearpath(bool value);
  private:
  bool _internal_clearpath() const;
  void _internal_set_clearpath(bool value);
  public:

  // bool clearAction = 3;
  void clear_clearaction();
  bool clearaction() const;
  void set_clearaction(bool value);
  private:
  bool _internal_clearaction() const;
  void _internal_set_clearaction(bool value);
  public:

  // bool disableCargo = 4;
  void clear_disablecargo();
  bool disablecargo() const;
  void set_disablecargo(bool value);
  private:
  bool _internal_disablecargo() const;
  void _internal_set_disablecargo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Operation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool iscontinue_;
    bool clearpath_;
    bool clearaction_;
    bool disablecargo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class CamelCfg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CamelCfg) */ {
 public:
  inline CamelCfg() : CamelCfg(nullptr) {}
  ~CamelCfg() override;
  explicit PROTOBUF_CONSTEXPR CamelCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CamelCfg(const CamelCfg& from);
  CamelCfg(CamelCfg&& from) noexcept
    : CamelCfg() {
    *this = ::std::move(from);
  }

  inline CamelCfg& operator=(const CamelCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CamelCfg& operator=(CamelCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CamelCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CamelCfg* internal_default_instance() {
    return reinterpret_cast<const CamelCfg*>(
               &_CamelCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CamelCfg& a, CamelCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(CamelCfg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CamelCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CamelCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CamelCfg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CamelCfg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CamelCfg& from) {
    CamelCfg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CamelCfg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CamelCfg";
  }
  protected:
  explicit CamelCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonStringFieldNumber = 1,
  };
  // string JsonString = 1;
  void clear_jsonstring();
  const std::string& jsonstring() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jsonstring(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jsonstring();
  PROTOBUF_NODISCARD std::string* release_jsonstring();
  void set_allocated_jsonstring(std::string* jsonstring);
  private:
  const std::string& _internal_jsonstring() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jsonstring(const std::string& value);
  std::string* _internal_mutable_jsonstring();
  public:

  // @@protoc_insertion_point(class_scope:CamelCfg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jsonstring_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class CamelSysInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CamelSysInfo) */ {
 public:
  inline CamelSysInfo() : CamelSysInfo(nullptr) {}
  ~CamelSysInfo() override;
  explicit PROTOBUF_CONSTEXPR CamelSysInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CamelSysInfo(const CamelSysInfo& from);
  CamelSysInfo(CamelSysInfo&& from) noexcept
    : CamelSysInfo() {
    *this = ::std::move(from);
  }

  inline CamelSysInfo& operator=(const CamelSysInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CamelSysInfo& operator=(CamelSysInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CamelSysInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CamelSysInfo* internal_default_instance() {
    return reinterpret_cast<const CamelSysInfo*>(
               &_CamelSysInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CamelSysInfo& a, CamelSysInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CamelSysInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CamelSysInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CamelSysInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CamelSysInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CamelSysInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CamelSysInfo& from) {
    CamelSysInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CamelSysInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CamelSysInfo";
  }
  protected:
  explicit CamelSysInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgvsInfoFieldNumber = 1,
    kTaskInfoFieldNumber = 2,
  };
  // .CamelMessage.AllowFromAgvs agvsInfo = 1;
  bool has_agvsinfo() const;
  private:
  bool _internal_has_agvsinfo() const;
  public:
  void clear_agvsinfo();
  const ::CamelMessage_AllowFromAgvs& agvsinfo() const;
  PROTOBUF_NODISCARD ::CamelMessage_AllowFromAgvs* release_agvsinfo();
  ::CamelMessage_AllowFromAgvs* mutable_agvsinfo();
  void set_allocated_agvsinfo(::CamelMessage_AllowFromAgvs* agvsinfo);
  private:
  const ::CamelMessage_AllowFromAgvs& _internal_agvsinfo() const;
  ::CamelMessage_AllowFromAgvs* _internal_mutable_agvsinfo();
  public:
  void unsafe_arena_set_allocated_agvsinfo(
      ::CamelMessage_AllowFromAgvs* agvsinfo);
  ::CamelMessage_AllowFromAgvs* unsafe_arena_release_agvsinfo();

  // .CamelMessage.MissonFromAgvs taskInfo = 2;
  bool has_taskinfo() const;
  private:
  bool _internal_has_taskinfo() const;
  public:
  void clear_taskinfo();
  const ::CamelMessage_MissonFromAgvs& taskinfo() const;
  PROTOBUF_NODISCARD ::CamelMessage_MissonFromAgvs* release_taskinfo();
  ::CamelMessage_MissonFromAgvs* mutable_taskinfo();
  void set_allocated_taskinfo(::CamelMessage_MissonFromAgvs* taskinfo);
  private:
  const ::CamelMessage_MissonFromAgvs& _internal_taskinfo() const;
  ::CamelMessage_MissonFromAgvs* _internal_mutable_taskinfo();
  public:
  void unsafe_arena_set_allocated_taskinfo(
      ::CamelMessage_MissonFromAgvs* taskinfo);
  ::CamelMessage_MissonFromAgvs* unsafe_arena_release_taskinfo();

  // @@protoc_insertion_point(class_scope:CamelSysInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::CamelMessage_AllowFromAgvs* agvsinfo_;
    ::CamelMessage_MissonFromAgvs* taskinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class LogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogRequest) */ {
 public:
  inline LogRequest() : LogRequest(nullptr) {}
  ~LogRequest() override;
  explicit PROTOBUF_CONSTEXPR LogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogRequest(const LogRequest& from);
  LogRequest(LogRequest&& from) noexcept
    : LogRequest() {
    *this = ::std::move(from);
  }

  inline LogRequest& operator=(const LogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogRequest& operator=(LogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogRequest* internal_default_instance() {
    return reinterpret_cast<const LogRequest*>(
               &_LogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LogRequest& a, LogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogRequest& from) {
    LogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogRequest";
  }
  protected:
  explicit LogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModulesFieldNumber = 2,
    kTimeFieldNumber = 3,
    kCarFieldNumber = 1,
  };
  // repeated string modules = 2;
  int modules_size() const;
  private:
  int _internal_modules_size() const;
  public:
  void clear_modules();
  const std::string& modules(int index) const;
  std::string* mutable_modules(int index);
  void set_modules(int index, const std::string& value);
  void set_modules(int index, std::string&& value);
  void set_modules(int index, const char* value);
  void set_modules(int index, const char* value, size_t size);
  std::string* add_modules();
  void add_modules(const std::string& value);
  void add_modules(std::string&& value);
  void add_modules(const char* value);
  void add_modules(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& modules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_modules();
  private:
  const std::string& _internal_modules(int index) const;
  std::string* _internal_add_modules();
  public:

  // repeated string time = 3;
  int time_size() const;
  private:
  int _internal_time_size() const;
  public:
  void clear_time();
  const std::string& time(int index) const;
  std::string* mutable_time(int index);
  void set_time(int index, const std::string& value);
  void set_time(int index, std::string&& value);
  void set_time(int index, const char* value);
  void set_time(int index, const char* value, size_t size);
  std::string* add_time();
  void add_time(const std::string& value);
  void add_time(std::string&& value);
  void add_time(const char* value);
  void add_time(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& time() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_time();
  private:
  const std::string& _internal_time(int index) const;
  std::string* _internal_add_time();
  public:

  // string car = 1;
  void clear_car();
  const std::string& car() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_car(ArgT0&& arg0, ArgT... args);
  std::string* mutable_car();
  PROTOBUF_NODISCARD std::string* release_car();
  void set_allocated_car(std::string* car);
  private:
  const std::string& _internal_car() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car(const std::string& value);
  std::string* _internal_mutable_car();
  public:

  // @@protoc_insertion_point(class_scope:LogRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> modules_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class LogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LogResponse) */ {
 public:
  inline LogResponse() : LogResponse(nullptr) {}
  ~LogResponse() override;
  explicit PROTOBUF_CONSTEXPR LogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogResponse(const LogResponse& from);
  LogResponse(LogResponse&& from) noexcept
    : LogResponse() {
    *this = ::std::move(from);
  }

  inline LogResponse& operator=(const LogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogResponse& operator=(LogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogResponse* internal_default_instance() {
    return reinterpret_cast<const LogResponse*>(
               &_LogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LogResponse& a, LogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogResponse& from) {
    LogResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LogResponse";
  }
  protected:
  explicit LogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:LogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class RosNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RosNode) */ {
 public:
  inline RosNode() : RosNode(nullptr) {}
  ~RosNode() override;
  explicit PROTOBUF_CONSTEXPR RosNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RosNode(const RosNode& from);
  RosNode(RosNode&& from) noexcept
    : RosNode() {
    *this = ::std::move(from);
  }

  inline RosNode& operator=(const RosNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosNode& operator=(RosNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RosNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RosNode* internal_default_instance() {
    return reinterpret_cast<const RosNode*>(
               &_RosNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RosNode& a, RosNode& b) {
    a.Swap(&b);
  }
  inline void Swap(RosNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RosNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RosNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RosNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RosNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RosNode& from) {
    RosNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RosNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RosNode";
  }
  protected:
  explicit RosNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 1,
    kModuleFieldNumber = 4,
    kFilenameFieldNumber = 5,
    kModifyEnableFieldNumber = 2,
    kSetMasterFieldNumber = 3,
    kIsRunningFieldNumber = 6,
  };
  // string configuration = 1;
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_NODISCARD std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // string module = 4;
  void clear_module();
  const std::string& module() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_module(ArgT0&& arg0, ArgT... args);
  std::string* mutable_module();
  PROTOBUF_NODISCARD std::string* release_module();
  void set_allocated_module(std::string* module);
  private:
  const std::string& _internal_module() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_module(const std::string& value);
  std::string* _internal_mutable_module();
  public:

  // string filename = 5;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // bool modify_enable = 2;
  void clear_modify_enable();
  bool modify_enable() const;
  void set_modify_enable(bool value);
  private:
  bool _internal_modify_enable() const;
  void _internal_set_modify_enable(bool value);
  public:

  // bool set_master = 3;
  void clear_set_master();
  bool set_master() const;
  void set_set_master(bool value);
  private:
  bool _internal_set_master() const;
  void _internal_set_set_master(bool value);
  public:

  // bool is_running = 6;
  void clear_is_running();
  bool is_running() const;
  void set_is_running(bool value);
  private:
  bool _internal_is_running() const;
  void _internal_set_is_running(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RosNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    bool modify_enable_;
    bool set_master_;
    bool is_running_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class RosNodesCfg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RosNodesCfg) */ {
 public:
  inline RosNodesCfg() : RosNodesCfg(nullptr) {}
  ~RosNodesCfg() override;
  explicit PROTOBUF_CONSTEXPR RosNodesCfg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RosNodesCfg(const RosNodesCfg& from);
  RosNodesCfg(RosNodesCfg&& from) noexcept
    : RosNodesCfg() {
    *this = ::std::move(from);
  }

  inline RosNodesCfg& operator=(const RosNodesCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosNodesCfg& operator=(RosNodesCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RosNodesCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RosNodesCfg* internal_default_instance() {
    return reinterpret_cast<const RosNodesCfg*>(
               &_RosNodesCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RosNodesCfg& a, RosNodesCfg& b) {
    a.Swap(&b);
  }
  inline void Swap(RosNodesCfg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RosNodesCfg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RosNodesCfg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RosNodesCfg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RosNodesCfg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RosNodesCfg& from) {
    RosNodesCfg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RosNodesCfg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RosNodesCfg";
  }
  protected:
  explicit RosNodesCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
  };
  // repeated .RosNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::RosNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosNode >*
      mutable_nodes();
  private:
  const ::RosNode& _internal_nodes(int index) const;
  ::RosNode* _internal_add_nodes();
  public:
  const ::RosNode& nodes(int index) const;
  ::RosNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosNode >&
      nodes() const;

  // @@protoc_insertion_point(class_scope:RosNodesCfg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosNode > nodes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class RosoutMsg_RosoutInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RosoutMsg.RosoutInfo) */ {
 public:
  inline RosoutMsg_RosoutInfo() : RosoutMsg_RosoutInfo(nullptr) {}
  ~RosoutMsg_RosoutInfo() override;
  explicit PROTOBUF_CONSTEXPR RosoutMsg_RosoutInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RosoutMsg_RosoutInfo(const RosoutMsg_RosoutInfo& from);
  RosoutMsg_RosoutInfo(RosoutMsg_RosoutInfo&& from) noexcept
    : RosoutMsg_RosoutInfo() {
    *this = ::std::move(from);
  }

  inline RosoutMsg_RosoutInfo& operator=(const RosoutMsg_RosoutInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosoutMsg_RosoutInfo& operator=(RosoutMsg_RosoutInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RosoutMsg_RosoutInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RosoutMsg_RosoutInfo* internal_default_instance() {
    return reinterpret_cast<const RosoutMsg_RosoutInfo*>(
               &_RosoutMsg_RosoutInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RosoutMsg_RosoutInfo& a, RosoutMsg_RosoutInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RosoutMsg_RosoutInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RosoutMsg_RosoutInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RosoutMsg_RosoutInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RosoutMsg_RosoutInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RosoutMsg_RosoutInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RosoutMsg_RosoutInfo& from) {
    RosoutMsg_RosoutInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RosoutMsg_RosoutInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RosoutMsg.RosoutInfo";
  }
  protected:
  explicit RosoutMsg_RosoutInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kMsgFieldNumber = 3,
    kTopicFieldNumber = 4,
    kLevelFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string msg = 3;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // string topic = 4;
  void clear_topic();
  const std::string& topic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic();
  PROTOBUF_NODISCARD std::string* release_topic();
  void set_allocated_topic(std::string* topic);
  private:
  const std::string& _internal_topic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const std::string& value);
  std::string* _internal_mutable_topic();
  public:

  // int32 level = 1;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RosoutMsg.RosoutInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_;
    int32_t level_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class RosoutMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RosoutMsg) */ {
 public:
  inline RosoutMsg() : RosoutMsg(nullptr) {}
  ~RosoutMsg() override;
  explicit PROTOBUF_CONSTEXPR RosoutMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RosoutMsg(const RosoutMsg& from);
  RosoutMsg(RosoutMsg&& from) noexcept
    : RosoutMsg() {
    *this = ::std::move(from);
  }

  inline RosoutMsg& operator=(const RosoutMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RosoutMsg& operator=(RosoutMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RosoutMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RosoutMsg* internal_default_instance() {
    return reinterpret_cast<const RosoutMsg*>(
               &_RosoutMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RosoutMsg& a, RosoutMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RosoutMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RosoutMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RosoutMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RosoutMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RosoutMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RosoutMsg& from) {
    RosoutMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RosoutMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RosoutMsg";
  }
  protected:
  explicit RosoutMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RosoutMsg_RosoutInfo RosoutInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .RosoutMsg.RosoutInfo messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::RosoutMsg_RosoutInfo* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosoutMsg_RosoutInfo >*
      mutable_messages();
  private:
  const ::RosoutMsg_RosoutInfo& _internal_messages(int index) const;
  ::RosoutMsg_RosoutInfo* _internal_add_messages();
  public:
  const ::RosoutMsg_RosoutInfo& messages(int index) const;
  ::RosoutMsg_RosoutInfo* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosoutMsg_RosoutInfo >&
      messages() const;

  // @@protoc_insertion_point(class_scope:RosoutMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosoutMsg_RosoutInfo > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class AlarmMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AlarmMsg) */ {
 public:
  inline AlarmMsg() : AlarmMsg(nullptr) {}
  ~AlarmMsg() override;
  explicit PROTOBUF_CONSTEXPR AlarmMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AlarmMsg(const AlarmMsg& from);
  AlarmMsg(AlarmMsg&& from) noexcept
    : AlarmMsg() {
    *this = ::std::move(from);
  }

  inline AlarmMsg& operator=(const AlarmMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlarmMsg& operator=(AlarmMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlarmMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlarmMsg* internal_default_instance() {
    return reinterpret_cast<const AlarmMsg*>(
               &_AlarmMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AlarmMsg& a, AlarmMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(AlarmMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlarmMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlarmMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AlarmMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AlarmMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AlarmMsg& from) {
    AlarmMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlarmMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AlarmMsg";
  }
  protected:
  explicit AlarmMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 1,
    kClearedFieldNumber = 2,
  };
  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // bool cleared = 2;
  void clear_cleared();
  bool cleared() const;
  void set_cleared(bool value);
  private:
  bool _internal_cleared() const;
  void _internal_set_cleared(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AlarmMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t code_;
    bool cleared_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class NetworkConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NetworkConfig) */ {
 public:
  inline NetworkConfig() : NetworkConfig(nullptr) {}
  ~NetworkConfig() override;
  explicit PROTOBUF_CONSTEXPR NetworkConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConfig(const NetworkConfig& from);
  NetworkConfig(NetworkConfig&& from) noexcept
    : NetworkConfig() {
    *this = ::std::move(from);
  }

  inline NetworkConfig& operator=(const NetworkConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConfig& operator=(NetworkConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConfig* internal_default_instance() {
    return reinterpret_cast<const NetworkConfig*>(
               &_NetworkConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(NetworkConfig& a, NetworkConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkConfig& from) {
    NetworkConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NetworkConfig";
  }
  protected:
  explicit NetworkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddressFieldNumber = 2,
    kMacFieldNumber = 3,
    kNetmaskFieldNumber = 4,
    kGatewayFieldNumber = 5,
    kDnsFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string address = 2;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // string mac = 3;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string netmask = 4;
  void clear_netmask();
  const std::string& netmask() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_netmask(ArgT0&& arg0, ArgT... args);
  std::string* mutable_netmask();
  PROTOBUF_NODISCARD std::string* release_netmask();
  void set_allocated_netmask(std::string* netmask);
  private:
  const std::string& _internal_netmask() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_netmask(const std::string& value);
  std::string* _internal_mutable_netmask();
  public:

  // string gateway = 5;
  void clear_gateway();
  const std::string& gateway() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gateway(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gateway();
  PROTOBUF_NODISCARD std::string* release_gateway();
  void set_allocated_gateway(std::string* gateway);
  private:
  const std::string& _internal_gateway() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gateway(const std::string& value);
  std::string* _internal_mutable_gateway();
  public:

  // string dns = 6;
  void clear_dns();
  const std::string& dns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dns();
  PROTOBUF_NODISCARD std::string* release_dns();
  void set_allocated_dns(std::string* dns);
  private:
  const std::string& _internal_dns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dns(const std::string& value);
  std::string* _internal_mutable_dns();
  public:

  // @@protoc_insertion_point(class_scope:NetworkConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr netmask_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gateway_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dns_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class WirlessConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WirlessConfig) */ {
 public:
  inline WirlessConfig() : WirlessConfig(nullptr) {}
  ~WirlessConfig() override;
  explicit PROTOBUF_CONSTEXPR WirlessConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirlessConfig(const WirlessConfig& from);
  WirlessConfig(WirlessConfig&& from) noexcept
    : WirlessConfig() {
    *this = ::std::move(from);
  }

  inline WirlessConfig& operator=(const WirlessConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirlessConfig& operator=(WirlessConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirlessConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirlessConfig* internal_default_instance() {
    return reinterpret_cast<const WirlessConfig*>(
               &_WirlessConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(WirlessConfig& a, WirlessConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(WirlessConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirlessConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirlessConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirlessConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirlessConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirlessConfig& from) {
    WirlessConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirlessConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WirlessConfig";
  }
  protected:
  explicit WirlessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kPasswdFieldNumber = 2,
    kConfigFieldNumber = 3,
  };
  // string ssid = 1;
  void clear_ssid();
  const std::string& ssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ssid);
  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(const std::string& value);
  std::string* _internal_mutable_ssid();
  public:

  // string passwd = 2;
  void clear_passwd();
  const std::string& passwd() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_passwd(ArgT0&& arg0, ArgT... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* passwd);
  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(const std::string& value);
  std::string* _internal_mutable_passwd();
  public:

  // .NetworkConfig config = 3;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::NetworkConfig& config() const;
  PROTOBUF_NODISCARD ::NetworkConfig* release_config();
  ::NetworkConfig* mutable_config();
  void set_allocated_config(::NetworkConfig* config);
  private:
  const ::NetworkConfig& _internal_config() const;
  ::NetworkConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::NetworkConfig* config);
  ::NetworkConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:WirlessConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr passwd_;
    ::NetworkConfig* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class WirlessInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WirlessInfo) */ {
 public:
  inline WirlessInfo() : WirlessInfo(nullptr) {}
  ~WirlessInfo() override;
  explicit PROTOBUF_CONSTEXPR WirlessInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WirlessInfo(const WirlessInfo& from);
  WirlessInfo(WirlessInfo&& from) noexcept
    : WirlessInfo() {
    *this = ::std::move(from);
  }

  inline WirlessInfo& operator=(const WirlessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WirlessInfo& operator=(WirlessInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WirlessInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WirlessInfo* internal_default_instance() {
    return reinterpret_cast<const WirlessInfo*>(
               &_WirlessInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(WirlessInfo& a, WirlessInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(WirlessInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WirlessInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WirlessInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WirlessInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WirlessInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WirlessInfo& from) {
    WirlessInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WirlessInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WirlessInfo";
  }
  protected:
  explicit WirlessInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSsidFieldNumber = 1,
    kSignalLevelFieldNumber = 2,
  };
  // string ssid = 1;
  void clear_ssid();
  const std::string& ssid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ssid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ssid();
  PROTOBUF_NODISCARD std::string* release_ssid();
  void set_allocated_ssid(std::string* ssid);
  private:
  const std::string& _internal_ssid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ssid(const std::string& value);
  std::string* _internal_mutable_ssid();
  public:

  // int32 signalLevel = 2;
  void clear_signallevel();
  int32_t signallevel() const;
  void set_signallevel(int32_t value);
  private:
  int32_t _internal_signallevel() const;
  void _internal_set_signallevel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:WirlessInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ssid_;
    int32_t signallevel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class WLANList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WLANList) */ {
 public:
  inline WLANList() : WLANList(nullptr) {}
  ~WLANList() override;
  explicit PROTOBUF_CONSTEXPR WLANList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WLANList(const WLANList& from);
  WLANList(WLANList&& from) noexcept
    : WLANList() {
    *this = ::std::move(from);
  }

  inline WLANList& operator=(const WLANList& from) {
    CopyFrom(from);
    return *this;
  }
  inline WLANList& operator=(WLANList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WLANList& default_instance() {
    return *internal_default_instance();
  }
  static inline const WLANList* internal_default_instance() {
    return reinterpret_cast<const WLANList*>(
               &_WLANList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(WLANList& a, WLANList& b) {
    a.Swap(&b);
  }
  inline void Swap(WLANList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WLANList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WLANList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WLANList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WLANList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WLANList& from) {
    WLANList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WLANList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WLANList";
  }
  protected:
  explicit WLANList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWirlessListFieldNumber = 1,
  };
  // repeated .WirlessInfo wirlessList = 1;
  int wirlesslist_size() const;
  private:
  int _internal_wirlesslist_size() const;
  public:
  void clear_wirlesslist();
  ::WirlessInfo* mutable_wirlesslist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WirlessInfo >*
      mutable_wirlesslist();
  private:
  const ::WirlessInfo& _internal_wirlesslist(int index) const;
  ::WirlessInfo* _internal_add_wirlesslist();
  public:
  const ::WirlessInfo& wirlesslist(int index) const;
  ::WirlessInfo* add_wirlesslist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WirlessInfo >&
      wirlesslist() const;

  // @@protoc_insertion_point(class_scope:WLANList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WirlessInfo > wirlesslist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class NetworkConfigCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NetworkConfigCollection) */ {
 public:
  inline NetworkConfigCollection() : NetworkConfigCollection(nullptr) {}
  ~NetworkConfigCollection() override;
  explicit PROTOBUF_CONSTEXPR NetworkConfigCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConfigCollection(const NetworkConfigCollection& from);
  NetworkConfigCollection(NetworkConfigCollection&& from) noexcept
    : NetworkConfigCollection() {
    *this = ::std::move(from);
  }

  inline NetworkConfigCollection& operator=(const NetworkConfigCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConfigCollection& operator=(NetworkConfigCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConfigCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConfigCollection* internal_default_instance() {
    return reinterpret_cast<const NetworkConfigCollection*>(
               &_NetworkConfigCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(NetworkConfigCollection& a, NetworkConfigCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConfigCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConfigCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConfigCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConfigCollection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConfigCollection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NetworkConfigCollection& from) {
    NetworkConfigCollection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConfigCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NetworkConfigCollection";
  }
  protected:
  explicit NetworkConfigCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigCollectionFieldNumber = 1,
  };
  // repeated .NetworkConfig config_collection = 1;
  int config_collection_size() const;
  private:
  int _internal_config_collection_size() const;
  public:
  void clear_config_collection();
  ::NetworkConfig* mutable_config_collection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NetworkConfig >*
      mutable_config_collection();
  private:
  const ::NetworkConfig& _internal_config_collection(int index) const;
  ::NetworkConfig* _internal_add_config_collection();
  public:
  const ::NetworkConfig& config_collection(int index) const;
  ::NetworkConfig* add_config_collection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NetworkConfig >&
      config_collection() const;

  // @@protoc_insertion_point(class_scope:NetworkConfigCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NetworkConfig > config_collection_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class InstallPack final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InstallPack) */ {
 public:
  inline InstallPack() : InstallPack(nullptr) {}
  ~InstallPack() override;
  explicit PROTOBUF_CONSTEXPR InstallPack(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InstallPack(const InstallPack& from);
  InstallPack(InstallPack&& from) noexcept
    : InstallPack() {
    *this = ::std::move(from);
  }

  inline InstallPack& operator=(const InstallPack& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstallPack& operator=(InstallPack&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InstallPack& default_instance() {
    return *internal_default_instance();
  }
  static inline const InstallPack* internal_default_instance() {
    return reinterpret_cast<const InstallPack*>(
               &_InstallPack_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(InstallPack& a, InstallPack& b) {
    a.Swap(&b);
  }
  inline void Swap(InstallPack* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstallPack* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InstallPack* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InstallPack>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InstallPack& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InstallPack& from) {
    InstallPack::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstallPack* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InstallPack";
  }
  protected:
  explicit InstallPack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
  };
  // string filename = 1;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // @@protoc_insertion_point(class_scope:InstallPack)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class SystemStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SystemStatus) */ {
 public:
  inline SystemStatus() : SystemStatus(nullptr) {}
  ~SystemStatus() override;
  explicit PROTOBUF_CONSTEXPR SystemStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SystemStatus(const SystemStatus& from);
  SystemStatus(SystemStatus&& from) noexcept
    : SystemStatus() {
    *this = ::std::move(from);
  }

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SystemStatus& operator=(SystemStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SystemStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SystemStatus* internal_default_instance() {
    return reinterpret_cast<const SystemStatus*>(
               &_SystemStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SystemStatus& a, SystemStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SystemStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SystemStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SystemStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SystemStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SystemStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SystemStatus& from) {
    SystemStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SystemStatus";
  }
  protected:
  explicit SystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kCpuUsageFieldNumber = 2,
    kMemTotalFieldNumber = 3,
    kMemUsedFieldNumber = 4,
    kDiskTotalFieldNumber = 5,
    kDiskUsedFieldNumber = 6,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // float cpu_usage = 2;
  void clear_cpu_usage();
  float cpu_usage() const;
  void set_cpu_usage(float value);
  private:
  float _internal_cpu_usage() const;
  void _internal_set_cpu_usage(float value);
  public:

  // int32 mem_total = 3;
  void clear_mem_total();
  int32_t mem_total() const;
  void set_mem_total(int32_t value);
  private:
  int32_t _internal_mem_total() const;
  void _internal_set_mem_total(int32_t value);
  public:

  // int32 mem_used = 4;
  void clear_mem_used();
  int32_t mem_used() const;
  void set_mem_used(int32_t value);
  private:
  int32_t _internal_mem_used() const;
  void _internal_set_mem_used(int32_t value);
  public:

  // int32 disk_total = 5;
  void clear_disk_total();
  int32_t disk_total() const;
  void set_disk_total(int32_t value);
  private:
  int32_t _internal_disk_total() const;
  void _internal_set_disk_total(int32_t value);
  public:

  // int32 disk_used = 6;
  void clear_disk_used();
  int32_t disk_used() const;
  void set_disk_used(int32_t value);
  private:
  int32_t _internal_disk_used() const;
  void _internal_set_disk_used(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SystemStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    float cpu_usage_;
    int32_t mem_total_;
    int32_t mem_used_;
    int32_t disk_total_;
    int32_t disk_used_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class UpdateStation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateStation) */ {
 public:
  inline UpdateStation() : UpdateStation(nullptr) {}
  ~UpdateStation() override;
  explicit PROTOBUF_CONSTEXPR UpdateStation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateStation(const UpdateStation& from);
  UpdateStation(UpdateStation&& from) noexcept
    : UpdateStation() {
    *this = ::std::move(from);
  }

  inline UpdateStation& operator=(const UpdateStation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateStation& operator=(UpdateStation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateStation& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateStation* internal_default_instance() {
    return reinterpret_cast<const UpdateStation*>(
               &_UpdateStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateStation& a, UpdateStation& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateStation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateStation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateStation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateStation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateStation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateStation& from) {
    UpdateStation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateStation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdateStation";
  }
  protected:
  explicit UpdateStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkerTypeFieldNumber = 1,
  };
  // int32 marker_type = 1;
  void clear_marker_type();
  int32_t marker_type() const;
  void set_marker_type(int32_t value);
  private:
  int32_t _internal_marker_type() const;
  void _internal_set_marker_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UpdateStation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t marker_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// -------------------------------------------------------------------

class UpdatePose final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdatePose) */ {
 public:
  inline UpdatePose() : UpdatePose(nullptr) {}
  ~UpdatePose() override;
  explicit PROTOBUF_CONSTEXPR UpdatePose(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdatePose(const UpdatePose& from);
  UpdatePose(UpdatePose&& from) noexcept
    : UpdatePose() {
    *this = ::std::move(from);
  }

  inline UpdatePose& operator=(const UpdatePose& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdatePose& operator=(UpdatePose&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdatePose& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdatePose* internal_default_instance() {
    return reinterpret_cast<const UpdatePose*>(
               &_UpdatePose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UpdatePose& a, UpdatePose& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdatePose* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdatePose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdatePose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdatePose>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdatePose& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdatePose& from) {
    UpdatePose::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatePose* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UpdatePose";
  }
  protected:
  explicit UpdatePose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorInfoFieldNumber = 1,
    kPoseFieldNumber = 2,
  };
  // .Result error_info = 1;
  bool has_error_info() const;
  private:
  bool _internal_has_error_info() const;
  public:
  void clear_error_info();
  const ::Result& error_info() const;
  PROTOBUF_NODISCARD ::Result* release_error_info();
  ::Result* mutable_error_info();
  void set_allocated_error_info(::Result* error_info);
  private:
  const ::Result& _internal_error_info() const;
  ::Result* _internal_mutable_error_info();
  public:
  void unsafe_arena_set_allocated_error_info(
      ::Result* error_info);
  ::Result* unsafe_arena_release_error_info();

  // .Position pose = 2;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::Position& pose() const;
  PROTOBUF_NODISCARD ::Position* release_pose();
  ::Position* mutable_pose();
  void set_allocated_pose(::Position* pose);
  private:
  const ::Position& _internal_pose() const;
  ::Position* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::Position* pose);
  ::Position* unsafe_arena_release_pose();

  // @@protoc_insertion_point(class_scope:UpdatePose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Result* error_info_;
    ::Position* pose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AgvInfo_UIStation

// string stationOnMap = 1;
inline void AgvInfo_UIStation::clear_stationonmap() {
  _impl_.stationonmap_.ClearToEmpty();
}
inline const std::string& AgvInfo_UIStation::stationonmap() const {
  // @@protoc_insertion_point(field_get:AgvInfo.UIStation.stationOnMap)
  return _internal_stationonmap();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgvInfo_UIStation::set_stationonmap(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationonmap_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgvInfo.UIStation.stationOnMap)
}
inline std::string* AgvInfo_UIStation::mutable_stationonmap() {
  std::string* _s = _internal_mutable_stationonmap();
  // @@protoc_insertion_point(field_mutable:AgvInfo.UIStation.stationOnMap)
  return _s;
}
inline const std::string& AgvInfo_UIStation::_internal_stationonmap() const {
  return _impl_.stationonmap_.Get();
}
inline void AgvInfo_UIStation::_internal_set_stationonmap(const std::string& value) {
  
  _impl_.stationonmap_.Set(value, GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::_internal_mutable_stationonmap() {
  
  return _impl_.stationonmap_.Mutable(GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::release_stationonmap() {
  // @@protoc_insertion_point(field_release:AgvInfo.UIStation.stationOnMap)
  return _impl_.stationonmap_.Release();
}
inline void AgvInfo_UIStation::set_allocated_stationonmap(std::string* stationonmap) {
  if (stationonmap != nullptr) {
    
  } else {
    
  }
  _impl_.stationonmap_.SetAllocated(stationonmap, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationonmap_.IsDefault()) {
    _impl_.stationonmap_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.UIStation.stationOnMap)
}

// string stationOnPath = 2;
inline void AgvInfo_UIStation::clear_stationonpath() {
  _impl_.stationonpath_.ClearToEmpty();
}
inline const std::string& AgvInfo_UIStation::stationonpath() const {
  // @@protoc_insertion_point(field_get:AgvInfo.UIStation.stationOnPath)
  return _internal_stationonpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgvInfo_UIStation::set_stationonpath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.stationonpath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgvInfo.UIStation.stationOnPath)
}
inline std::string* AgvInfo_UIStation::mutable_stationonpath() {
  std::string* _s = _internal_mutable_stationonpath();
  // @@protoc_insertion_point(field_mutable:AgvInfo.UIStation.stationOnPath)
  return _s;
}
inline const std::string& AgvInfo_UIStation::_internal_stationonpath() const {
  return _impl_.stationonpath_.Get();
}
inline void AgvInfo_UIStation::_internal_set_stationonpath(const std::string& value) {
  
  _impl_.stationonpath_.Set(value, GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::_internal_mutable_stationonpath() {
  
  return _impl_.stationonpath_.Mutable(GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::release_stationonpath() {
  // @@protoc_insertion_point(field_release:AgvInfo.UIStation.stationOnPath)
  return _impl_.stationonpath_.Release();
}
inline void AgvInfo_UIStation::set_allocated_stationonpath(std::string* stationonpath) {
  if (stationonpath != nullptr) {
    
  } else {
    
  }
  _impl_.stationonpath_.SetAllocated(stationonpath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.stationonpath_.IsDefault()) {
    _impl_.stationonpath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.UIStation.stationOnPath)
}

// string targetStation = 3;
inline void AgvInfo_UIStation::clear_targetstation() {
  _impl_.targetstation_.ClearToEmpty();
}
inline const std::string& AgvInfo_UIStation::targetstation() const {
  // @@protoc_insertion_point(field_get:AgvInfo.UIStation.targetStation)
  return _internal_targetstation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgvInfo_UIStation::set_targetstation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.targetstation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgvInfo.UIStation.targetStation)
}
inline std::string* AgvInfo_UIStation::mutable_targetstation() {
  std::string* _s = _internal_mutable_targetstation();
  // @@protoc_insertion_point(field_mutable:AgvInfo.UIStation.targetStation)
  return _s;
}
inline const std::string& AgvInfo_UIStation::_internal_targetstation() const {
  return _impl_.targetstation_.Get();
}
inline void AgvInfo_UIStation::_internal_set_targetstation(const std::string& value) {
  
  _impl_.targetstation_.Set(value, GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::_internal_mutable_targetstation() {
  
  return _impl_.targetstation_.Mutable(GetArenaForAllocation());
}
inline std::string* AgvInfo_UIStation::release_targetstation() {
  // @@protoc_insertion_point(field_release:AgvInfo.UIStation.targetStation)
  return _impl_.targetstation_.Release();
}
inline void AgvInfo_UIStation::set_allocated_targetstation(std::string* targetstation) {
  if (targetstation != nullptr) {
    
  } else {
    
  }
  _impl_.targetstation_.SetAllocated(targetstation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.targetstation_.IsDefault()) {
    _impl_.targetstation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.UIStation.targetStation)
}

// -------------------------------------------------------------------

// AgvInfo_Motion

// float vx = 1;
inline void AgvInfo_Motion::clear_vx() {
  _impl_.vx_ = 0;
}
inline float AgvInfo_Motion::_internal_vx() const {
  return _impl_.vx_;
}
inline float AgvInfo_Motion::vx() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Motion.vx)
  return _internal_vx();
}
inline void AgvInfo_Motion::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void AgvInfo_Motion::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Motion.vx)
}

// float vy = 2;
inline void AgvInfo_Motion::clear_vy() {
  _impl_.vy_ = 0;
}
inline float AgvInfo_Motion::_internal_vy() const {
  return _impl_.vy_;
}
inline float AgvInfo_Motion::vy() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Motion.vy)
  return _internal_vy();
}
inline void AgvInfo_Motion::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void AgvInfo_Motion::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Motion.vy)
}

// float w = 3;
inline void AgvInfo_Motion::clear_w() {
  _impl_.w_ = 0;
}
inline float AgvInfo_Motion::_internal_w() const {
  return _impl_.w_;
}
inline float AgvInfo_Motion::w() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Motion.w)
  return _internal_w();
}
inline void AgvInfo_Motion::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void AgvInfo_Motion::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Motion.w)
}

// float od1 = 4;
inline void AgvInfo_Motion::clear_od1() {
  _impl_.od1_ = 0;
}
inline float AgvInfo_Motion::_internal_od1() const {
  return _impl_.od1_;
}
inline float AgvInfo_Motion::od1() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Motion.od1)
  return _internal_od1();
}
inline void AgvInfo_Motion::_internal_set_od1(float value) {
  
  _impl_.od1_ = value;
}
inline void AgvInfo_Motion::set_od1(float value) {
  _internal_set_od1(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Motion.od1)
}

// float od2 = 5;
inline void AgvInfo_Motion::clear_od2() {
  _impl_.od2_ = 0;
}
inline float AgvInfo_Motion::_internal_od2() const {
  return _impl_.od2_;
}
inline float AgvInfo_Motion::od2() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Motion.od2)
  return _internal_od2();
}
inline void AgvInfo_Motion::_internal_set_od2(float value) {
  
  _impl_.od2_ = value;
}
inline void AgvInfo_Motion::set_od2(float value) {
  _internal_set_od2(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Motion.od2)
}

// -------------------------------------------------------------------

// AgvInfo_Alarm

// .AgvInfo.Alarm.Source type = 1;
inline void AgvInfo_Alarm::clear_type() {
  _impl_.type_ = 0;
}
inline ::AgvInfo_Alarm_Source AgvInfo_Alarm::_internal_type() const {
  return static_cast< ::AgvInfo_Alarm_Source >(_impl_.type_);
}
inline ::AgvInfo_Alarm_Source AgvInfo_Alarm::type() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Alarm.type)
  return _internal_type();
}
inline void AgvInfo_Alarm::_internal_set_type(::AgvInfo_Alarm_Source value) {
  
  _impl_.type_ = value;
}
inline void AgvInfo_Alarm::set_type(::AgvInfo_Alarm_Source value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Alarm.type)
}

// .AgvInfo.Alarm.Level level = 2;
inline void AgvInfo_Alarm::clear_level() {
  _impl_.level_ = 0;
}
inline ::AgvInfo_Alarm_Level AgvInfo_Alarm::_internal_level() const {
  return static_cast< ::AgvInfo_Alarm_Level >(_impl_.level_);
}
inline ::AgvInfo_Alarm_Level AgvInfo_Alarm::level() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Alarm.level)
  return _internal_level();
}
inline void AgvInfo_Alarm::_internal_set_level(::AgvInfo_Alarm_Level value) {
  
  _impl_.level_ = value;
}
inline void AgvInfo_Alarm::set_level(::AgvInfo_Alarm_Level value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Alarm.level)
}

// bytes message = 3;
inline void AgvInfo_Alarm::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& AgvInfo_Alarm::message() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Alarm.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgvInfo_Alarm::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgvInfo.Alarm.message)
}
inline std::string* AgvInfo_Alarm::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:AgvInfo.Alarm.message)
  return _s;
}
inline const std::string& AgvInfo_Alarm::_internal_message() const {
  return _impl_.message_.Get();
}
inline void AgvInfo_Alarm::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* AgvInfo_Alarm::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* AgvInfo_Alarm::release_message() {
  // @@protoc_insertion_point(field_release:AgvInfo.Alarm.message)
  return _impl_.message_.Release();
}
inline void AgvInfo_Alarm::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.Alarm.message)
}

// bytes time = 4;
inline void AgvInfo_Alarm::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& AgvInfo_Alarm::time() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Alarm.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgvInfo_Alarm::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AgvInfo.Alarm.time)
}
inline std::string* AgvInfo_Alarm::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:AgvInfo.Alarm.time)
  return _s;
}
inline const std::string& AgvInfo_Alarm::_internal_time() const {
  return _impl_.time_.Get();
}
inline void AgvInfo_Alarm::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* AgvInfo_Alarm::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* AgvInfo_Alarm::release_time() {
  // @@protoc_insertion_point(field_release:AgvInfo.Alarm.time)
  return _impl_.time_.Release();
}
inline void AgvInfo_Alarm::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.Alarm.time)
}

// int32 code = 5;
inline void AgvInfo_Alarm::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t AgvInfo_Alarm::_internal_code() const {
  return _impl_.code_;
}
inline int32_t AgvInfo_Alarm::code() const {
  // @@protoc_insertion_point(field_get:AgvInfo.Alarm.code)
  return _internal_code();
}
inline void AgvInfo_Alarm::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void AgvInfo_Alarm::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:AgvInfo.Alarm.code)
}

// -------------------------------------------------------------------

// AgvInfo_DebugInfo

// float Vx = 1;
inline void AgvInfo_DebugInfo::clear_vx() {
  _impl_.vx_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_vx() const {
  return _impl_.vx_;
}
inline float AgvInfo_DebugInfo::vx() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.Vx)
  return _internal_vx();
}
inline void AgvInfo_DebugInfo::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void AgvInfo_DebugInfo::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.Vx)
}

// float Vy = 2;
inline void AgvInfo_DebugInfo::clear_vy() {
  _impl_.vy_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_vy() const {
  return _impl_.vy_;
}
inline float AgvInfo_DebugInfo::vy() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.Vy)
  return _internal_vy();
}
inline void AgvInfo_DebugInfo::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void AgvInfo_DebugInfo::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.Vy)
}

// float W = 3;
inline void AgvInfo_DebugInfo::clear_w() {
  _impl_.w_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_w() const {
  return _impl_.w_;
}
inline float AgvInfo_DebugInfo::w() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.W)
  return _internal_w();
}
inline void AgvInfo_DebugInfo::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void AgvInfo_DebugInfo::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.W)
}

// float GoalX = 4;
inline void AgvInfo_DebugInfo::clear_goalx() {
  _impl_.goalx_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_goalx() const {
  return _impl_.goalx_;
}
inline float AgvInfo_DebugInfo::goalx() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.GoalX)
  return _internal_goalx();
}
inline void AgvInfo_DebugInfo::_internal_set_goalx(float value) {
  
  _impl_.goalx_ = value;
}
inline void AgvInfo_DebugInfo::set_goalx(float value) {
  _internal_set_goalx(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.GoalX)
}

// float GoalY = 5;
inline void AgvInfo_DebugInfo::clear_goaly() {
  _impl_.goaly_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_goaly() const {
  return _impl_.goaly_;
}
inline float AgvInfo_DebugInfo::goaly() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.GoalY)
  return _internal_goaly();
}
inline void AgvInfo_DebugInfo::_internal_set_goaly(float value) {
  
  _impl_.goaly_ = value;
}
inline void AgvInfo_DebugInfo::set_goaly(float value) {
  _internal_set_goaly(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.GoalY)
}

// uint64 timestamp = 6;
inline void AgvInfo_DebugInfo::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t AgvInfo_DebugInfo::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t AgvInfo_DebugInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.timestamp)
  return _internal_timestamp();
}
inline void AgvInfo_DebugInfo::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void AgvInfo_DebugInfo::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.timestamp)
}

// float TaskAverageVelocity = 7;
inline void AgvInfo_DebugInfo::clear_taskaveragevelocity() {
  _impl_.taskaveragevelocity_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_taskaveragevelocity() const {
  return _impl_.taskaveragevelocity_;
}
inline float AgvInfo_DebugInfo::taskaveragevelocity() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.TaskAverageVelocity)
  return _internal_taskaveragevelocity();
}
inline void AgvInfo_DebugInfo::_internal_set_taskaveragevelocity(float value) {
  
  _impl_.taskaveragevelocity_ = value;
}
inline void AgvInfo_DebugInfo::set_taskaveragevelocity(float value) {
  _internal_set_taskaveragevelocity(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.TaskAverageVelocity)
}

// float TotalTaskAverageVelocity = 8;
inline void AgvInfo_DebugInfo::clear_totaltaskaveragevelocity() {
  _impl_.totaltaskaveragevelocity_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_totaltaskaveragevelocity() const {
  return _impl_.totaltaskaveragevelocity_;
}
inline float AgvInfo_DebugInfo::totaltaskaveragevelocity() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.TotalTaskAverageVelocity)
  return _internal_totaltaskaveragevelocity();
}
inline void AgvInfo_DebugInfo::_internal_set_totaltaskaveragevelocity(float value) {
  
  _impl_.totaltaskaveragevelocity_ = value;
}
inline void AgvInfo_DebugInfo::set_totaltaskaveragevelocity(float value) {
  _internal_set_totaltaskaveragevelocity(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.TotalTaskAverageVelocity)
}

// float TotalOdometry = 9;
inline void AgvInfo_DebugInfo::clear_totalodometry() {
  _impl_.totalodometry_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_totalodometry() const {
  return _impl_.totalodometry_;
}
inline float AgvInfo_DebugInfo::totalodometry() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.TotalOdometry)
  return _internal_totalodometry();
}
inline void AgvInfo_DebugInfo::_internal_set_totalodometry(float value) {
  
  _impl_.totalodometry_ = value;
}
inline void AgvInfo_DebugInfo::set_totalodometry(float value) {
  _internal_set_totalodometry(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.TotalOdometry)
}

// float TotalRuntime = 10;
inline void AgvInfo_DebugInfo::clear_totalruntime() {
  _impl_.totalruntime_ = 0;
}
inline float AgvInfo_DebugInfo::_internal_totalruntime() const {
  return _impl_.totalruntime_;
}
inline float AgvInfo_DebugInfo::totalruntime() const {
  // @@protoc_insertion_point(field_get:AgvInfo.DebugInfo.TotalRuntime)
  return _internal_totalruntime();
}
inline void AgvInfo_DebugInfo::_internal_set_totalruntime(float value) {
  
  _impl_.totalruntime_ = value;
}
inline void AgvInfo_DebugInfo::set_totalruntime(float value) {
  _internal_set_totalruntime(value);
  // @@protoc_insertion_point(field_set:AgvInfo.DebugInfo.TotalRuntime)
}

// -------------------------------------------------------------------

// AgvInfo

// .AgvInfo.Motion montion = 1;
inline bool AgvInfo::_internal_has_montion() const {
  return this != internal_default_instance() && _impl_.montion_ != nullptr;
}
inline bool AgvInfo::has_montion() const {
  return _internal_has_montion();
}
inline void AgvInfo::clear_montion() {
  if (GetArenaForAllocation() == nullptr && _impl_.montion_ != nullptr) {
    delete _impl_.montion_;
  }
  _impl_.montion_ = nullptr;
}
inline const ::AgvInfo_Motion& AgvInfo::_internal_montion() const {
  const ::AgvInfo_Motion* p = _impl_.montion_;
  return p != nullptr ? *p : reinterpret_cast<const ::AgvInfo_Motion&>(
      ::_AgvInfo_Motion_default_instance_);
}
inline const ::AgvInfo_Motion& AgvInfo::montion() const {
  // @@protoc_insertion_point(field_get:AgvInfo.montion)
  return _internal_montion();
}
inline void AgvInfo::unsafe_arena_set_allocated_montion(
    ::AgvInfo_Motion* montion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.montion_);
  }
  _impl_.montion_ = montion;
  if (montion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.montion)
}
inline ::AgvInfo_Motion* AgvInfo::release_montion() {
  
  ::AgvInfo_Motion* temp = _impl_.montion_;
  _impl_.montion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AgvInfo_Motion* AgvInfo::unsafe_arena_release_montion() {
  // @@protoc_insertion_point(field_release:AgvInfo.montion)
  
  ::AgvInfo_Motion* temp = _impl_.montion_;
  _impl_.montion_ = nullptr;
  return temp;
}
inline ::AgvInfo_Motion* AgvInfo::_internal_mutable_montion() {
  
  if (_impl_.montion_ == nullptr) {
    auto* p = CreateMaybeMessage<::AgvInfo_Motion>(GetArenaForAllocation());
    _impl_.montion_ = p;
  }
  return _impl_.montion_;
}
inline ::AgvInfo_Motion* AgvInfo::mutable_montion() {
  ::AgvInfo_Motion* _msg = _internal_mutable_montion();
  // @@protoc_insertion_point(field_mutable:AgvInfo.montion)
  return _msg;
}
inline void AgvInfo::set_allocated_montion(::AgvInfo_Motion* montion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.montion_;
  }
  if (montion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(montion);
    if (message_arena != submessage_arena) {
      montion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, montion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.montion_ = montion;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.montion)
}

// .Position postion = 2;
inline bool AgvInfo::_internal_has_postion() const {
  return this != internal_default_instance() && _impl_.postion_ != nullptr;
}
inline bool AgvInfo::has_postion() const {
  return _internal_has_postion();
}
inline const ::Position& AgvInfo::_internal_postion() const {
  const ::Position* p = _impl_.postion_;
  return p != nullptr ? *p : reinterpret_cast<const ::Position&>(
      ::_Position_default_instance_);
}
inline const ::Position& AgvInfo::postion() const {
  // @@protoc_insertion_point(field_get:AgvInfo.postion)
  return _internal_postion();
}
inline void AgvInfo::unsafe_arena_set_allocated_postion(
    ::Position* postion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.postion_);
  }
  _impl_.postion_ = postion;
  if (postion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.postion)
}
inline ::Position* AgvInfo::release_postion() {
  
  ::Position* temp = _impl_.postion_;
  _impl_.postion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Position* AgvInfo::unsafe_arena_release_postion() {
  // @@protoc_insertion_point(field_release:AgvInfo.postion)
  
  ::Position* temp = _impl_.postion_;
  _impl_.postion_ = nullptr;
  return temp;
}
inline ::Position* AgvInfo::_internal_mutable_postion() {
  
  if (_impl_.postion_ == nullptr) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaForAllocation());
    _impl_.postion_ = p;
  }
  return _impl_.postion_;
}
inline ::Position* AgvInfo::mutable_postion() {
  ::Position* _msg = _internal_mutable_postion();
  // @@protoc_insertion_point(field_mutable:AgvInfo.postion)
  return _msg;
}
inline void AgvInfo::set_allocated_postion(::Position* postion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.postion_);
  }
  if (postion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(postion));
    if (message_arena != submessage_arena) {
      postion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.postion_ = postion;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.postion)
}

// .AgvInfo.UIStation station = 3;
inline bool AgvInfo::_internal_has_station() const {
  return this != internal_default_instance() && _impl_.station_ != nullptr;
}
inline bool AgvInfo::has_station() const {
  return _internal_has_station();
}
inline void AgvInfo::clear_station() {
  if (GetArenaForAllocation() == nullptr && _impl_.station_ != nullptr) {
    delete _impl_.station_;
  }
  _impl_.station_ = nullptr;
}
inline const ::AgvInfo_UIStation& AgvInfo::_internal_station() const {
  const ::AgvInfo_UIStation* p = _impl_.station_;
  return p != nullptr ? *p : reinterpret_cast<const ::AgvInfo_UIStation&>(
      ::_AgvInfo_UIStation_default_instance_);
}
inline const ::AgvInfo_UIStation& AgvInfo::station() const {
  // @@protoc_insertion_point(field_get:AgvInfo.station)
  return _internal_station();
}
inline void AgvInfo::unsafe_arena_set_allocated_station(
    ::AgvInfo_UIStation* station) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.station_);
  }
  _impl_.station_ = station;
  if (station) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.station)
}
inline ::AgvInfo_UIStation* AgvInfo::release_station() {
  
  ::AgvInfo_UIStation* temp = _impl_.station_;
  _impl_.station_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AgvInfo_UIStation* AgvInfo::unsafe_arena_release_station() {
  // @@protoc_insertion_point(field_release:AgvInfo.station)
  
  ::AgvInfo_UIStation* temp = _impl_.station_;
  _impl_.station_ = nullptr;
  return temp;
}
inline ::AgvInfo_UIStation* AgvInfo::_internal_mutable_station() {
  
  if (_impl_.station_ == nullptr) {
    auto* p = CreateMaybeMessage<::AgvInfo_UIStation>(GetArenaForAllocation());
    _impl_.station_ = p;
  }
  return _impl_.station_;
}
inline ::AgvInfo_UIStation* AgvInfo::mutable_station() {
  ::AgvInfo_UIStation* _msg = _internal_mutable_station();
  // @@protoc_insertion_point(field_mutable:AgvInfo.station)
  return _msg;
}
inline void AgvInfo::set_allocated_station(::AgvInfo_UIStation* station) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.station_;
  }
  if (station) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(station);
    if (message_arena != submessage_arena) {
      station = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, station, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.station_ = station;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.station)
}

// repeated .AgvInfo.Alarm alarm = 4;
inline int AgvInfo::_internal_alarm_size() const {
  return _impl_.alarm_.size();
}
inline int AgvInfo::alarm_size() const {
  return _internal_alarm_size();
}
inline void AgvInfo::clear_alarm() {
  _impl_.alarm_.Clear();
}
inline ::AgvInfo_Alarm* AgvInfo::mutable_alarm(int index) {
  // @@protoc_insertion_point(field_mutable:AgvInfo.alarm)
  return _impl_.alarm_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AgvInfo_Alarm >*
AgvInfo::mutable_alarm() {
  // @@protoc_insertion_point(field_mutable_list:AgvInfo.alarm)
  return &_impl_.alarm_;
}
inline const ::AgvInfo_Alarm& AgvInfo::_internal_alarm(int index) const {
  return _impl_.alarm_.Get(index);
}
inline const ::AgvInfo_Alarm& AgvInfo::alarm(int index) const {
  // @@protoc_insertion_point(field_get:AgvInfo.alarm)
  return _internal_alarm(index);
}
inline ::AgvInfo_Alarm* AgvInfo::_internal_add_alarm() {
  return _impl_.alarm_.Add();
}
inline ::AgvInfo_Alarm* AgvInfo::add_alarm() {
  ::AgvInfo_Alarm* _add = _internal_add_alarm();
  // @@protoc_insertion_point(field_add:AgvInfo.alarm)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::AgvInfo_Alarm >&
AgvInfo::alarm() const {
  // @@protoc_insertion_point(field_list:AgvInfo.alarm)
  return _impl_.alarm_;
}

// .Battery battery = 5;
inline bool AgvInfo::_internal_has_battery() const {
  return this != internal_default_instance() && _impl_.battery_ != nullptr;
}
inline bool AgvInfo::has_battery() const {
  return _internal_has_battery();
}
inline const ::Battery& AgvInfo::_internal_battery() const {
  const ::Battery* p = _impl_.battery_;
  return p != nullptr ? *p : reinterpret_cast<const ::Battery&>(
      ::_Battery_default_instance_);
}
inline const ::Battery& AgvInfo::battery() const {
  // @@protoc_insertion_point(field_get:AgvInfo.battery)
  return _internal_battery();
}
inline void AgvInfo::unsafe_arena_set_allocated_battery(
    ::Battery* battery) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.battery_);
  }
  _impl_.battery_ = battery;
  if (battery) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.battery)
}
inline ::Battery* AgvInfo::release_battery() {
  
  ::Battery* temp = _impl_.battery_;
  _impl_.battery_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Battery* AgvInfo::unsafe_arena_release_battery() {
  // @@protoc_insertion_point(field_release:AgvInfo.battery)
  
  ::Battery* temp = _impl_.battery_;
  _impl_.battery_ = nullptr;
  return temp;
}
inline ::Battery* AgvInfo::_internal_mutable_battery() {
  
  if (_impl_.battery_ == nullptr) {
    auto* p = CreateMaybeMessage<::Battery>(GetArenaForAllocation());
    _impl_.battery_ = p;
  }
  return _impl_.battery_;
}
inline ::Battery* AgvInfo::mutable_battery() {
  ::Battery* _msg = _internal_mutable_battery();
  // @@protoc_insertion_point(field_mutable:AgvInfo.battery)
  return _msg;
}
inline void AgvInfo::set_allocated_battery(::Battery* battery) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.battery_);
  }
  if (battery) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(battery));
    if (message_arena != submessage_arena) {
      battery = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, battery, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.battery_ = battery;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.battery)
}

// int32 runMode = 6;
inline void AgvInfo::clear_runmode() {
  _impl_.runmode_ = 0;
}
inline int32_t AgvInfo::_internal_runmode() const {
  return _impl_.runmode_;
}
inline int32_t AgvInfo::runmode() const {
  // @@protoc_insertion_point(field_get:AgvInfo.runMode)
  return _internal_runmode();
}
inline void AgvInfo::_internal_set_runmode(int32_t value) {
  
  _impl_.runmode_ = value;
}
inline void AgvInfo::set_runmode(int32_t value) {
  _internal_set_runmode(value);
  // @@protoc_insertion_point(field_set:AgvInfo.runMode)
}

// float height = 7;
inline void AgvInfo::clear_height() {
  _impl_.height_ = 0;
}
inline float AgvInfo::_internal_height() const {
  return _impl_.height_;
}
inline float AgvInfo::height() const {
  // @@protoc_insertion_point(field_get:AgvInfo.height)
  return _internal_height();
}
inline void AgvInfo::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void AgvInfo::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:AgvInfo.height)
}

// .PathCollection route = 9;
inline bool AgvInfo::_internal_has_route() const {
  return this != internal_default_instance() && _impl_.route_ != nullptr;
}
inline bool AgvInfo::has_route() const {
  return _internal_has_route();
}
inline const ::PathCollection& AgvInfo::_internal_route() const {
  const ::PathCollection* p = _impl_.route_;
  return p != nullptr ? *p : reinterpret_cast<const ::PathCollection&>(
      ::_PathCollection_default_instance_);
}
inline const ::PathCollection& AgvInfo::route() const {
  // @@protoc_insertion_point(field_get:AgvInfo.route)
  return _internal_route();
}
inline void AgvInfo::unsafe_arena_set_allocated_route(
    ::PathCollection* route) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  _impl_.route_ = route;
  if (route) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.route)
}
inline ::PathCollection* AgvInfo::release_route() {
  
  ::PathCollection* temp = _impl_.route_;
  _impl_.route_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PathCollection* AgvInfo::unsafe_arena_release_route() {
  // @@protoc_insertion_point(field_release:AgvInfo.route)
  
  ::PathCollection* temp = _impl_.route_;
  _impl_.route_ = nullptr;
  return temp;
}
inline ::PathCollection* AgvInfo::_internal_mutable_route() {
  
  if (_impl_.route_ == nullptr) {
    auto* p = CreateMaybeMessage<::PathCollection>(GetArenaForAllocation());
    _impl_.route_ = p;
  }
  return _impl_.route_;
}
inline ::PathCollection* AgvInfo::mutable_route() {
  ::PathCollection* _msg = _internal_mutable_route();
  // @@protoc_insertion_point(field_mutable:AgvInfo.route)
  return _msg;
}
inline void AgvInfo::set_allocated_route(::PathCollection* route) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.route_);
  }
  if (route) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(route));
    if (message_arena != submessage_arena) {
      route = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, route, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.route_ = route;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.route)
}

// int32 runStatus = 10;
inline void AgvInfo::clear_runstatus() {
  _impl_.runstatus_ = 0;
}
inline int32_t AgvInfo::_internal_runstatus() const {
  return _impl_.runstatus_;
}
inline int32_t AgvInfo::runstatus() const {
  // @@protoc_insertion_point(field_get:AgvInfo.runStatus)
  return _internal_runstatus();
}
inline void AgvInfo::_internal_set_runstatus(int32_t value) {
  
  _impl_.runstatus_ = value;
}
inline void AgvInfo::set_runstatus(int32_t value) {
  _internal_set_runstatus(value);
  // @@protoc_insertion_point(field_set:AgvInfo.runStatus)
}

// .Version version = 11;
inline bool AgvInfo::_internal_has_version() const {
  return this != internal_default_instance() && _impl_.version_ != nullptr;
}
inline bool AgvInfo::has_version() const {
  return _internal_has_version();
}
inline void AgvInfo::clear_version() {
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
}
inline const ::Version& AgvInfo::_internal_version() const {
  const ::Version* p = _impl_.version_;
  return p != nullptr ? *p : reinterpret_cast<const ::Version&>(
      ::_Version_default_instance_);
}
inline const ::Version& AgvInfo::version() const {
  // @@protoc_insertion_point(field_get:AgvInfo.version)
  return _internal_version();
}
inline void AgvInfo::unsafe_arena_set_allocated_version(
    ::Version* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.version_);
  }
  _impl_.version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.version)
}
inline ::Version* AgvInfo::release_version() {
  
  ::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Version* AgvInfo::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:AgvInfo.version)
  
  ::Version* temp = _impl_.version_;
  _impl_.version_ = nullptr;
  return temp;
}
inline ::Version* AgvInfo::_internal_mutable_version() {
  
  if (_impl_.version_ == nullptr) {
    auto* p = CreateMaybeMessage<::Version>(GetArenaForAllocation());
    _impl_.version_ = p;
  }
  return _impl_.version_;
}
inline ::Version* AgvInfo::mutable_version() {
  ::Version* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:AgvInfo.version)
  return _msg;
}
inline void AgvInfo::set_allocated_version(::Version* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.version_;
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(version);
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.version_ = version;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.version)
}

// .AgvInfo.DebugInfo debug = 12;
inline bool AgvInfo::_internal_has_debug() const {
  return this != internal_default_instance() && _impl_.debug_ != nullptr;
}
inline bool AgvInfo::has_debug() const {
  return _internal_has_debug();
}
inline void AgvInfo::clear_debug() {
  if (GetArenaForAllocation() == nullptr && _impl_.debug_ != nullptr) {
    delete _impl_.debug_;
  }
  _impl_.debug_ = nullptr;
}
inline const ::AgvInfo_DebugInfo& AgvInfo::_internal_debug() const {
  const ::AgvInfo_DebugInfo* p = _impl_.debug_;
  return p != nullptr ? *p : reinterpret_cast<const ::AgvInfo_DebugInfo&>(
      ::_AgvInfo_DebugInfo_default_instance_);
}
inline const ::AgvInfo_DebugInfo& AgvInfo::debug() const {
  // @@protoc_insertion_point(field_get:AgvInfo.debug)
  return _internal_debug();
}
inline void AgvInfo::unsafe_arena_set_allocated_debug(
    ::AgvInfo_DebugInfo* debug) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.debug_);
  }
  _impl_.debug_ = debug;
  if (debug) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.debug)
}
inline ::AgvInfo_DebugInfo* AgvInfo::release_debug() {
  
  ::AgvInfo_DebugInfo* temp = _impl_.debug_;
  _impl_.debug_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::AgvInfo_DebugInfo* AgvInfo::unsafe_arena_release_debug() {
  // @@protoc_insertion_point(field_release:AgvInfo.debug)
  
  ::AgvInfo_DebugInfo* temp = _impl_.debug_;
  _impl_.debug_ = nullptr;
  return temp;
}
inline ::AgvInfo_DebugInfo* AgvInfo::_internal_mutable_debug() {
  
  if (_impl_.debug_ == nullptr) {
    auto* p = CreateMaybeMessage<::AgvInfo_DebugInfo>(GetArenaForAllocation());
    _impl_.debug_ = p;
  }
  return _impl_.debug_;
}
inline ::AgvInfo_DebugInfo* AgvInfo::mutable_debug() {
  ::AgvInfo_DebugInfo* _msg = _internal_mutable_debug();
  // @@protoc_insertion_point(field_mutable:AgvInfo.debug)
  return _msg;
}
inline void AgvInfo::set_allocated_debug(::AgvInfo_DebugInfo* debug) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.debug_;
  }
  if (debug) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(debug);
    if (message_arena != submessage_arena) {
      debug = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.debug_ = debug;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.debug)
}

// .CamelSysInfo agvsInfo = 13;
inline bool AgvInfo::_internal_has_agvsinfo() const {
  return this != internal_default_instance() && _impl_.agvsinfo_ != nullptr;
}
inline bool AgvInfo::has_agvsinfo() const {
  return _internal_has_agvsinfo();
}
inline void AgvInfo::clear_agvsinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.agvsinfo_ != nullptr) {
    delete _impl_.agvsinfo_;
  }
  _impl_.agvsinfo_ = nullptr;
}
inline const ::CamelSysInfo& AgvInfo::_internal_agvsinfo() const {
  const ::CamelSysInfo* p = _impl_.agvsinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::CamelSysInfo&>(
      ::_CamelSysInfo_default_instance_);
}
inline const ::CamelSysInfo& AgvInfo::agvsinfo() const {
  // @@protoc_insertion_point(field_get:AgvInfo.agvsInfo)
  return _internal_agvsinfo();
}
inline void AgvInfo::unsafe_arena_set_allocated_agvsinfo(
    ::CamelSysInfo* agvsinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.agvsinfo_);
  }
  _impl_.agvsinfo_ = agvsinfo;
  if (agvsinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.agvsInfo)
}
inline ::CamelSysInfo* AgvInfo::release_agvsinfo() {
  
  ::CamelSysInfo* temp = _impl_.agvsinfo_;
  _impl_.agvsinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CamelSysInfo* AgvInfo::unsafe_arena_release_agvsinfo() {
  // @@protoc_insertion_point(field_release:AgvInfo.agvsInfo)
  
  ::CamelSysInfo* temp = _impl_.agvsinfo_;
  _impl_.agvsinfo_ = nullptr;
  return temp;
}
inline ::CamelSysInfo* AgvInfo::_internal_mutable_agvsinfo() {
  
  if (_impl_.agvsinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamelSysInfo>(GetArenaForAllocation());
    _impl_.agvsinfo_ = p;
  }
  return _impl_.agvsinfo_;
}
inline ::CamelSysInfo* AgvInfo::mutable_agvsinfo() {
  ::CamelSysInfo* _msg = _internal_mutable_agvsinfo();
  // @@protoc_insertion_point(field_mutable:AgvInfo.agvsInfo)
  return _msg;
}
inline void AgvInfo::set_allocated_agvsinfo(::CamelSysInfo* agvsinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.agvsinfo_;
  }
  if (agvsinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(agvsinfo);
    if (message_arena != submessage_arena) {
      agvsinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agvsinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.agvsinfo_ = agvsinfo;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.agvsInfo)
}

// .GrpcTaskInfomation grpcTask = 14;
inline bool AgvInfo::_internal_has_grpctask() const {
  return this != internal_default_instance() && _impl_.grpctask_ != nullptr;
}
inline bool AgvInfo::has_grpctask() const {
  return _internal_has_grpctask();
}
inline const ::GrpcTaskInfomation& AgvInfo::_internal_grpctask() const {
  const ::GrpcTaskInfomation* p = _impl_.grpctask_;
  return p != nullptr ? *p : reinterpret_cast<const ::GrpcTaskInfomation&>(
      ::_GrpcTaskInfomation_default_instance_);
}
inline const ::GrpcTaskInfomation& AgvInfo::grpctask() const {
  // @@protoc_insertion_point(field_get:AgvInfo.grpcTask)
  return _internal_grpctask();
}
inline void AgvInfo::unsafe_arena_set_allocated_grpctask(
    ::GrpcTaskInfomation* grpctask) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grpctask_);
  }
  _impl_.grpctask_ = grpctask;
  if (grpctask) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AgvInfo.grpcTask)
}
inline ::GrpcTaskInfomation* AgvInfo::release_grpctask() {
  
  ::GrpcTaskInfomation* temp = _impl_.grpctask_;
  _impl_.grpctask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GrpcTaskInfomation* AgvInfo::unsafe_arena_release_grpctask() {
  // @@protoc_insertion_point(field_release:AgvInfo.grpcTask)
  
  ::GrpcTaskInfomation* temp = _impl_.grpctask_;
  _impl_.grpctask_ = nullptr;
  return temp;
}
inline ::GrpcTaskInfomation* AgvInfo::_internal_mutable_grpctask() {
  
  if (_impl_.grpctask_ == nullptr) {
    auto* p = CreateMaybeMessage<::GrpcTaskInfomation>(GetArenaForAllocation());
    _impl_.grpctask_ = p;
  }
  return _impl_.grpctask_;
}
inline ::GrpcTaskInfomation* AgvInfo::mutable_grpctask() {
  ::GrpcTaskInfomation* _msg = _internal_mutable_grpctask();
  // @@protoc_insertion_point(field_mutable:AgvInfo.grpcTask)
  return _msg;
}
inline void AgvInfo::set_allocated_grpctask(::GrpcTaskInfomation* grpctask) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.grpctask_);
  }
  if (grpctask) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(grpctask));
    if (message_arena != submessage_arena) {
      grpctask = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, grpctask, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.grpctask_ = grpctask;
  // @@protoc_insertion_point(field_set_allocated:AgvInfo.grpcTask)
}

// -------------------------------------------------------------------

// UIConfig

// string navEndpoint = 1;
inline void UIConfig::clear_navendpoint() {
  _impl_.navendpoint_.ClearToEmpty();
}
inline const std::string& UIConfig::navendpoint() const {
  // @@protoc_insertion_point(field_get:UIConfig.navEndpoint)
  return _internal_navendpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UIConfig::set_navendpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.navendpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UIConfig.navEndpoint)
}
inline std::string* UIConfig::mutable_navendpoint() {
  std::string* _s = _internal_mutable_navendpoint();
  // @@protoc_insertion_point(field_mutable:UIConfig.navEndpoint)
  return _s;
}
inline const std::string& UIConfig::_internal_navendpoint() const {
  return _impl_.navendpoint_.Get();
}
inline void UIConfig::_internal_set_navendpoint(const std::string& value) {
  
  _impl_.navendpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* UIConfig::_internal_mutable_navendpoint() {
  
  return _impl_.navendpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* UIConfig::release_navendpoint() {
  // @@protoc_insertion_point(field_release:UIConfig.navEndpoint)
  return _impl_.navendpoint_.Release();
}
inline void UIConfig::set_allocated_navendpoint(std::string* navendpoint) {
  if (navendpoint != nullptr) {
    
  } else {
    
  }
  _impl_.navendpoint_.SetAllocated(navendpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.navendpoint_.IsDefault()) {
    _impl_.navendpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UIConfig.navEndpoint)
}

// .Language language = 2;
inline void UIConfig::clear_language() {
  _impl_.language_ = 0;
}
inline ::Language UIConfig::_internal_language() const {
  return static_cast< ::Language >(_impl_.language_);
}
inline ::Language UIConfig::language() const {
  // @@protoc_insertion_point(field_get:UIConfig.language)
  return _internal_language();
}
inline void UIConfig::_internal_set_language(::Language value) {
  
  _impl_.language_ = value;
}
inline void UIConfig::set_language(::Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:UIConfig.language)
}

// -------------------------------------------------------------------

// Version

// string CamelVersion = 1;
inline void Version::clear_camelversion() {
  _impl_.camelversion_.ClearToEmpty();
}
inline const std::string& Version::camelversion() const {
  // @@protoc_insertion_point(field_get:Version.CamelVersion)
  return _internal_camelversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_camelversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.camelversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Version.CamelVersion)
}
inline std::string* Version::mutable_camelversion() {
  std::string* _s = _internal_mutable_camelversion();
  // @@protoc_insertion_point(field_mutable:Version.CamelVersion)
  return _s;
}
inline const std::string& Version::_internal_camelversion() const {
  return _impl_.camelversion_.Get();
}
inline void Version::_internal_set_camelversion(const std::string& value) {
  
  _impl_.camelversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_camelversion() {
  
  return _impl_.camelversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_camelversion() {
  // @@protoc_insertion_point(field_release:Version.CamelVersion)
  return _impl_.camelversion_.Release();
}
inline void Version::set_allocated_camelversion(std::string* camelversion) {
  if (camelversion != nullptr) {
    
  } else {
    
  }
  _impl_.camelversion_.SetAllocated(camelversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.camelversion_.IsDefault()) {
    _impl_.camelversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Version.CamelVersion)
}

// bytes DBVersion = 2;
inline void Version::clear_dbversion() {
  _impl_.dbversion_.ClearToEmpty();
}
inline const std::string& Version::dbversion() const {
  // @@protoc_insertion_point(field_get:Version.DBVersion)
  return _internal_dbversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_dbversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dbversion_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Version.DBVersion)
}
inline std::string* Version::mutable_dbversion() {
  std::string* _s = _internal_mutable_dbversion();
  // @@protoc_insertion_point(field_mutable:Version.DBVersion)
  return _s;
}
inline const std::string& Version::_internal_dbversion() const {
  return _impl_.dbversion_.Get();
}
inline void Version::_internal_set_dbversion(const std::string& value) {
  
  _impl_.dbversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_dbversion() {
  
  return _impl_.dbversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_dbversion() {
  // @@protoc_insertion_point(field_release:Version.DBVersion)
  return _impl_.dbversion_.Release();
}
inline void Version::set_allocated_dbversion(std::string* dbversion) {
  if (dbversion != nullptr) {
    
  } else {
    
  }
  _impl_.dbversion_.SetAllocated(dbversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dbversion_.IsDefault()) {
    _impl_.dbversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Version.DBVersion)
}

// string DefenderVersion = 3;
inline void Version::clear_defenderversion() {
  _impl_.defenderversion_.ClearToEmpty();
}
inline const std::string& Version::defenderversion() const {
  // @@protoc_insertion_point(field_get:Version.DefenderVersion)
  return _internal_defenderversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_defenderversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.defenderversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Version.DefenderVersion)
}
inline std::string* Version::mutable_defenderversion() {
  std::string* _s = _internal_mutable_defenderversion();
  // @@protoc_insertion_point(field_mutable:Version.DefenderVersion)
  return _s;
}
inline const std::string& Version::_internal_defenderversion() const {
  return _impl_.defenderversion_.Get();
}
inline void Version::_internal_set_defenderversion(const std::string& value) {
  
  _impl_.defenderversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_defenderversion() {
  
  return _impl_.defenderversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_defenderversion() {
  // @@protoc_insertion_point(field_release:Version.DefenderVersion)
  return _impl_.defenderversion_.Release();
}
inline void Version::set_allocated_defenderversion(std::string* defenderversion) {
  if (defenderversion != nullptr) {
    
  } else {
    
  }
  _impl_.defenderversion_.SetAllocated(defenderversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.defenderversion_.IsDefault()) {
    _impl_.defenderversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Version.DefenderVersion)
}

// string PackageVersion = 4;
inline void Version::clear_packageversion() {
  _impl_.packageversion_.ClearToEmpty();
}
inline const std::string& Version::packageversion() const {
  // @@protoc_insertion_point(field_get:Version.PackageVersion)
  return _internal_packageversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Version::set_packageversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.packageversion_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Version.PackageVersion)
}
inline std::string* Version::mutable_packageversion() {
  std::string* _s = _internal_mutable_packageversion();
  // @@protoc_insertion_point(field_mutable:Version.PackageVersion)
  return _s;
}
inline const std::string& Version::_internal_packageversion() const {
  return _impl_.packageversion_.Get();
}
inline void Version::_internal_set_packageversion(const std::string& value) {
  
  _impl_.packageversion_.Set(value, GetArenaForAllocation());
}
inline std::string* Version::_internal_mutable_packageversion() {
  
  return _impl_.packageversion_.Mutable(GetArenaForAllocation());
}
inline std::string* Version::release_packageversion() {
  // @@protoc_insertion_point(field_release:Version.PackageVersion)
  return _impl_.packageversion_.Release();
}
inline void Version::set_allocated_packageversion(std::string* packageversion) {
  if (packageversion != nullptr) {
    
  } else {
    
  }
  _impl_.packageversion_.SetAllocated(packageversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.packageversion_.IsDefault()) {
    _impl_.packageversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Version.PackageVersion)
}

// -------------------------------------------------------------------

// Operation

// bool isContinue = 1;
inline void Operation::clear_iscontinue() {
  _impl_.iscontinue_ = false;
}
inline bool Operation::_internal_iscontinue() const {
  return _impl_.iscontinue_;
}
inline bool Operation::iscontinue() const {
  // @@protoc_insertion_point(field_get:Operation.isContinue)
  return _internal_iscontinue();
}
inline void Operation::_internal_set_iscontinue(bool value) {
  
  _impl_.iscontinue_ = value;
}
inline void Operation::set_iscontinue(bool value) {
  _internal_set_iscontinue(value);
  // @@protoc_insertion_point(field_set:Operation.isContinue)
}

// bool clearPath = 2;
inline void Operation::clear_clearpath() {
  _impl_.clearpath_ = false;
}
inline bool Operation::_internal_clearpath() const {
  return _impl_.clearpath_;
}
inline bool Operation::clearpath() const {
  // @@protoc_insertion_point(field_get:Operation.clearPath)
  return _internal_clearpath();
}
inline void Operation::_internal_set_clearpath(bool value) {
  
  _impl_.clearpath_ = value;
}
inline void Operation::set_clearpath(bool value) {
  _internal_set_clearpath(value);
  // @@protoc_insertion_point(field_set:Operation.clearPath)
}

// bool clearAction = 3;
inline void Operation::clear_clearaction() {
  _impl_.clearaction_ = false;
}
inline bool Operation::_internal_clearaction() const {
  return _impl_.clearaction_;
}
inline bool Operation::clearaction() const {
  // @@protoc_insertion_point(field_get:Operation.clearAction)
  return _internal_clearaction();
}
inline void Operation::_internal_set_clearaction(bool value) {
  
  _impl_.clearaction_ = value;
}
inline void Operation::set_clearaction(bool value) {
  _internal_set_clearaction(value);
  // @@protoc_insertion_point(field_set:Operation.clearAction)
}

// bool disableCargo = 4;
inline void Operation::clear_disablecargo() {
  _impl_.disablecargo_ = false;
}
inline bool Operation::_internal_disablecargo() const {
  return _impl_.disablecargo_;
}
inline bool Operation::disablecargo() const {
  // @@protoc_insertion_point(field_get:Operation.disableCargo)
  return _internal_disablecargo();
}
inline void Operation::_internal_set_disablecargo(bool value) {
  
  _impl_.disablecargo_ = value;
}
inline void Operation::set_disablecargo(bool value) {
  _internal_set_disablecargo(value);
  // @@protoc_insertion_point(field_set:Operation.disableCargo)
}

// -------------------------------------------------------------------

// CamelCfg

// string JsonString = 1;
inline void CamelCfg::clear_jsonstring() {
  _impl_.jsonstring_.ClearToEmpty();
}
inline const std::string& CamelCfg::jsonstring() const {
  // @@protoc_insertion_point(field_get:CamelCfg.JsonString)
  return _internal_jsonstring();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CamelCfg::set_jsonstring(ArgT0&& arg0, ArgT... args) {
 
 _impl_.jsonstring_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CamelCfg.JsonString)
}
inline std::string* CamelCfg::mutable_jsonstring() {
  std::string* _s = _internal_mutable_jsonstring();
  // @@protoc_insertion_point(field_mutable:CamelCfg.JsonString)
  return _s;
}
inline const std::string& CamelCfg::_internal_jsonstring() const {
  return _impl_.jsonstring_.Get();
}
inline void CamelCfg::_internal_set_jsonstring(const std::string& value) {
  
  _impl_.jsonstring_.Set(value, GetArenaForAllocation());
}
inline std::string* CamelCfg::_internal_mutable_jsonstring() {
  
  return _impl_.jsonstring_.Mutable(GetArenaForAllocation());
}
inline std::string* CamelCfg::release_jsonstring() {
  // @@protoc_insertion_point(field_release:CamelCfg.JsonString)
  return _impl_.jsonstring_.Release();
}
inline void CamelCfg::set_allocated_jsonstring(std::string* jsonstring) {
  if (jsonstring != nullptr) {
    
  } else {
    
  }
  _impl_.jsonstring_.SetAllocated(jsonstring, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.jsonstring_.IsDefault()) {
    _impl_.jsonstring_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CamelCfg.JsonString)
}

// -------------------------------------------------------------------

// CamelSysInfo

// .CamelMessage.AllowFromAgvs agvsInfo = 1;
inline bool CamelSysInfo::_internal_has_agvsinfo() const {
  return this != internal_default_instance() && _impl_.agvsinfo_ != nullptr;
}
inline bool CamelSysInfo::has_agvsinfo() const {
  return _internal_has_agvsinfo();
}
inline const ::CamelMessage_AllowFromAgvs& CamelSysInfo::_internal_agvsinfo() const {
  const ::CamelMessage_AllowFromAgvs* p = _impl_.agvsinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::CamelMessage_AllowFromAgvs&>(
      ::_CamelMessage_AllowFromAgvs_default_instance_);
}
inline const ::CamelMessage_AllowFromAgvs& CamelSysInfo::agvsinfo() const {
  // @@protoc_insertion_point(field_get:CamelSysInfo.agvsInfo)
  return _internal_agvsinfo();
}
inline void CamelSysInfo::unsafe_arena_set_allocated_agvsinfo(
    ::CamelMessage_AllowFromAgvs* agvsinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.agvsinfo_);
  }
  _impl_.agvsinfo_ = agvsinfo;
  if (agvsinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CamelSysInfo.agvsInfo)
}
inline ::CamelMessage_AllowFromAgvs* CamelSysInfo::release_agvsinfo() {
  
  ::CamelMessage_AllowFromAgvs* temp = _impl_.agvsinfo_;
  _impl_.agvsinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CamelMessage_AllowFromAgvs* CamelSysInfo::unsafe_arena_release_agvsinfo() {
  // @@protoc_insertion_point(field_release:CamelSysInfo.agvsInfo)
  
  ::CamelMessage_AllowFromAgvs* temp = _impl_.agvsinfo_;
  _impl_.agvsinfo_ = nullptr;
  return temp;
}
inline ::CamelMessage_AllowFromAgvs* CamelSysInfo::_internal_mutable_agvsinfo() {
  
  if (_impl_.agvsinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamelMessage_AllowFromAgvs>(GetArenaForAllocation());
    _impl_.agvsinfo_ = p;
  }
  return _impl_.agvsinfo_;
}
inline ::CamelMessage_AllowFromAgvs* CamelSysInfo::mutable_agvsinfo() {
  ::CamelMessage_AllowFromAgvs* _msg = _internal_mutable_agvsinfo();
  // @@protoc_insertion_point(field_mutable:CamelSysInfo.agvsInfo)
  return _msg;
}
inline void CamelSysInfo::set_allocated_agvsinfo(::CamelMessage_AllowFromAgvs* agvsinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.agvsinfo_);
  }
  if (agvsinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(agvsinfo));
    if (message_arena != submessage_arena) {
      agvsinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agvsinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.agvsinfo_ = agvsinfo;
  // @@protoc_insertion_point(field_set_allocated:CamelSysInfo.agvsInfo)
}

// .CamelMessage.MissonFromAgvs taskInfo = 2;
inline bool CamelSysInfo::_internal_has_taskinfo() const {
  return this != internal_default_instance() && _impl_.taskinfo_ != nullptr;
}
inline bool CamelSysInfo::has_taskinfo() const {
  return _internal_has_taskinfo();
}
inline const ::CamelMessage_MissonFromAgvs& CamelSysInfo::_internal_taskinfo() const {
  const ::CamelMessage_MissonFromAgvs* p = _impl_.taskinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::CamelMessage_MissonFromAgvs&>(
      ::_CamelMessage_MissonFromAgvs_default_instance_);
}
inline const ::CamelMessage_MissonFromAgvs& CamelSysInfo::taskinfo() const {
  // @@protoc_insertion_point(field_get:CamelSysInfo.taskInfo)
  return _internal_taskinfo();
}
inline void CamelSysInfo::unsafe_arena_set_allocated_taskinfo(
    ::CamelMessage_MissonFromAgvs* taskinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.taskinfo_);
  }
  _impl_.taskinfo_ = taskinfo;
  if (taskinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CamelSysInfo.taskInfo)
}
inline ::CamelMessage_MissonFromAgvs* CamelSysInfo::release_taskinfo() {
  
  ::CamelMessage_MissonFromAgvs* temp = _impl_.taskinfo_;
  _impl_.taskinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CamelMessage_MissonFromAgvs* CamelSysInfo::unsafe_arena_release_taskinfo() {
  // @@protoc_insertion_point(field_release:CamelSysInfo.taskInfo)
  
  ::CamelMessage_MissonFromAgvs* temp = _impl_.taskinfo_;
  _impl_.taskinfo_ = nullptr;
  return temp;
}
inline ::CamelMessage_MissonFromAgvs* CamelSysInfo::_internal_mutable_taskinfo() {
  
  if (_impl_.taskinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::CamelMessage_MissonFromAgvs>(GetArenaForAllocation());
    _impl_.taskinfo_ = p;
  }
  return _impl_.taskinfo_;
}
inline ::CamelMessage_MissonFromAgvs* CamelSysInfo::mutable_taskinfo() {
  ::CamelMessage_MissonFromAgvs* _msg = _internal_mutable_taskinfo();
  // @@protoc_insertion_point(field_mutable:CamelSysInfo.taskInfo)
  return _msg;
}
inline void CamelSysInfo::set_allocated_taskinfo(::CamelMessage_MissonFromAgvs* taskinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.taskinfo_);
  }
  if (taskinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(taskinfo));
    if (message_arena != submessage_arena) {
      taskinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, taskinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.taskinfo_ = taskinfo;
  // @@protoc_insertion_point(field_set_allocated:CamelSysInfo.taskInfo)
}

// -------------------------------------------------------------------

// LogRequest

// string car = 1;
inline void LogRequest::clear_car() {
  _impl_.car_.ClearToEmpty();
}
inline const std::string& LogRequest::car() const {
  // @@protoc_insertion_point(field_get:LogRequest.car)
  return _internal_car();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogRequest::set_car(ArgT0&& arg0, ArgT... args) {
 
 _impl_.car_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogRequest.car)
}
inline std::string* LogRequest::mutable_car() {
  std::string* _s = _internal_mutable_car();
  // @@protoc_insertion_point(field_mutable:LogRequest.car)
  return _s;
}
inline const std::string& LogRequest::_internal_car() const {
  return _impl_.car_.Get();
}
inline void LogRequest::_internal_set_car(const std::string& value) {
  
  _impl_.car_.Set(value, GetArenaForAllocation());
}
inline std::string* LogRequest::_internal_mutable_car() {
  
  return _impl_.car_.Mutable(GetArenaForAllocation());
}
inline std::string* LogRequest::release_car() {
  // @@protoc_insertion_point(field_release:LogRequest.car)
  return _impl_.car_.Release();
}
inline void LogRequest::set_allocated_car(std::string* car) {
  if (car != nullptr) {
    
  } else {
    
  }
  _impl_.car_.SetAllocated(car, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.car_.IsDefault()) {
    _impl_.car_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogRequest.car)
}

// repeated string modules = 2;
inline int LogRequest::_internal_modules_size() const {
  return _impl_.modules_.size();
}
inline int LogRequest::modules_size() const {
  return _internal_modules_size();
}
inline void LogRequest::clear_modules() {
  _impl_.modules_.Clear();
}
inline std::string* LogRequest::add_modules() {
  std::string* _s = _internal_add_modules();
  // @@protoc_insertion_point(field_add_mutable:LogRequest.modules)
  return _s;
}
inline const std::string& LogRequest::_internal_modules(int index) const {
  return _impl_.modules_.Get(index);
}
inline const std::string& LogRequest::modules(int index) const {
  // @@protoc_insertion_point(field_get:LogRequest.modules)
  return _internal_modules(index);
}
inline std::string* LogRequest::mutable_modules(int index) {
  // @@protoc_insertion_point(field_mutable:LogRequest.modules)
  return _impl_.modules_.Mutable(index);
}
inline void LogRequest::set_modules(int index, const std::string& value) {
  _impl_.modules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:LogRequest.modules)
}
inline void LogRequest::set_modules(int index, std::string&& value) {
  _impl_.modules_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:LogRequest.modules)
}
inline void LogRequest::set_modules(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.modules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LogRequest.modules)
}
inline void LogRequest::set_modules(int index, const char* value, size_t size) {
  _impl_.modules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LogRequest.modules)
}
inline std::string* LogRequest::_internal_add_modules() {
  return _impl_.modules_.Add();
}
inline void LogRequest::add_modules(const std::string& value) {
  _impl_.modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LogRequest.modules)
}
inline void LogRequest::add_modules(std::string&& value) {
  _impl_.modules_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:LogRequest.modules)
}
inline void LogRequest::add_modules(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LogRequest.modules)
}
inline void LogRequest::add_modules(const char* value, size_t size) {
  _impl_.modules_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LogRequest.modules)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogRequest::modules() const {
  // @@protoc_insertion_point(field_list:LogRequest.modules)
  return _impl_.modules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogRequest::mutable_modules() {
  // @@protoc_insertion_point(field_mutable_list:LogRequest.modules)
  return &_impl_.modules_;
}

// repeated string time = 3;
inline int LogRequest::_internal_time_size() const {
  return _impl_.time_.size();
}
inline int LogRequest::time_size() const {
  return _internal_time_size();
}
inline void LogRequest::clear_time() {
  _impl_.time_.Clear();
}
inline std::string* LogRequest::add_time() {
  std::string* _s = _internal_add_time();
  // @@protoc_insertion_point(field_add_mutable:LogRequest.time)
  return _s;
}
inline const std::string& LogRequest::_internal_time(int index) const {
  return _impl_.time_.Get(index);
}
inline const std::string& LogRequest::time(int index) const {
  // @@protoc_insertion_point(field_get:LogRequest.time)
  return _internal_time(index);
}
inline std::string* LogRequest::mutable_time(int index) {
  // @@protoc_insertion_point(field_mutable:LogRequest.time)
  return _impl_.time_.Mutable(index);
}
inline void LogRequest::set_time(int index, const std::string& value) {
  _impl_.time_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:LogRequest.time)
}
inline void LogRequest::set_time(int index, std::string&& value) {
  _impl_.time_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:LogRequest.time)
}
inline void LogRequest::set_time(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.time_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:LogRequest.time)
}
inline void LogRequest::set_time(int index, const char* value, size_t size) {
  _impl_.time_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LogRequest.time)
}
inline std::string* LogRequest::_internal_add_time() {
  return _impl_.time_.Add();
}
inline void LogRequest::add_time(const std::string& value) {
  _impl_.time_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:LogRequest.time)
}
inline void LogRequest::add_time(std::string&& value) {
  _impl_.time_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:LogRequest.time)
}
inline void LogRequest::add_time(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.time_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:LogRequest.time)
}
inline void LogRequest::add_time(const char* value, size_t size) {
  _impl_.time_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:LogRequest.time)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogRequest::time() const {
  // @@protoc_insertion_point(field_list:LogRequest.time)
  return _impl_.time_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogRequest::mutable_time() {
  // @@protoc_insertion_point(field_mutable_list:LogRequest.time)
  return &_impl_.time_;
}

// -------------------------------------------------------------------

// LogResponse

// string path = 1;
inline void LogResponse::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& LogResponse::path() const {
  // @@protoc_insertion_point(field_get:LogResponse.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogResponse::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LogResponse.path)
}
inline std::string* LogResponse::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:LogResponse.path)
  return _s;
}
inline const std::string& LogResponse::_internal_path() const {
  return _impl_.path_.Get();
}
inline void LogResponse::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* LogResponse::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* LogResponse::release_path() {
  // @@protoc_insertion_point(field_release:LogResponse.path)
  return _impl_.path_.Release();
}
inline void LogResponse::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LogResponse.path)
}

// -------------------------------------------------------------------

// RosNode

// string configuration = 1;
inline void RosNode::clear_configuration() {
  _impl_.configuration_.ClearToEmpty();
}
inline const std::string& RosNode::configuration() const {
  // @@protoc_insertion_point(field_get:RosNode.configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosNode::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 _impl_.configuration_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosNode.configuration)
}
inline std::string* RosNode::mutable_configuration() {
  std::string* _s = _internal_mutable_configuration();
  // @@protoc_insertion_point(field_mutable:RosNode.configuration)
  return _s;
}
inline const std::string& RosNode::_internal_configuration() const {
  return _impl_.configuration_.Get();
}
inline void RosNode::_internal_set_configuration(const std::string& value) {
  
  _impl_.configuration_.Set(value, GetArenaForAllocation());
}
inline std::string* RosNode::_internal_mutable_configuration() {
  
  return _impl_.configuration_.Mutable(GetArenaForAllocation());
}
inline std::string* RosNode::release_configuration() {
  // @@protoc_insertion_point(field_release:RosNode.configuration)
  return _impl_.configuration_.Release();
}
inline void RosNode::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  _impl_.configuration_.SetAllocated(configuration, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.configuration_.IsDefault()) {
    _impl_.configuration_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosNode.configuration)
}

// bool modify_enable = 2;
inline void RosNode::clear_modify_enable() {
  _impl_.modify_enable_ = false;
}
inline bool RosNode::_internal_modify_enable() const {
  return _impl_.modify_enable_;
}
inline bool RosNode::modify_enable() const {
  // @@protoc_insertion_point(field_get:RosNode.modify_enable)
  return _internal_modify_enable();
}
inline void RosNode::_internal_set_modify_enable(bool value) {
  
  _impl_.modify_enable_ = value;
}
inline void RosNode::set_modify_enable(bool value) {
  _internal_set_modify_enable(value);
  // @@protoc_insertion_point(field_set:RosNode.modify_enable)
}

// bool set_master = 3;
inline void RosNode::clear_set_master() {
  _impl_.set_master_ = false;
}
inline bool RosNode::_internal_set_master() const {
  return _impl_.set_master_;
}
inline bool RosNode::set_master() const {
  // @@protoc_insertion_point(field_get:RosNode.set_master)
  return _internal_set_master();
}
inline void RosNode::_internal_set_set_master(bool value) {
  
  _impl_.set_master_ = value;
}
inline void RosNode::set_set_master(bool value) {
  _internal_set_set_master(value);
  // @@protoc_insertion_point(field_set:RosNode.set_master)
}

// string module = 4;
inline void RosNode::clear_module() {
  _impl_.module_.ClearToEmpty();
}
inline const std::string& RosNode::module() const {
  // @@protoc_insertion_point(field_get:RosNode.module)
  return _internal_module();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosNode::set_module(ArgT0&& arg0, ArgT... args) {
 
 _impl_.module_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosNode.module)
}
inline std::string* RosNode::mutable_module() {
  std::string* _s = _internal_mutable_module();
  // @@protoc_insertion_point(field_mutable:RosNode.module)
  return _s;
}
inline const std::string& RosNode::_internal_module() const {
  return _impl_.module_.Get();
}
inline void RosNode::_internal_set_module(const std::string& value) {
  
  _impl_.module_.Set(value, GetArenaForAllocation());
}
inline std::string* RosNode::_internal_mutable_module() {
  
  return _impl_.module_.Mutable(GetArenaForAllocation());
}
inline std::string* RosNode::release_module() {
  // @@protoc_insertion_point(field_release:RosNode.module)
  return _impl_.module_.Release();
}
inline void RosNode::set_allocated_module(std::string* module) {
  if (module != nullptr) {
    
  } else {
    
  }
  _impl_.module_.SetAllocated(module, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.module_.IsDefault()) {
    _impl_.module_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosNode.module)
}

// string filename = 5;
inline void RosNode::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& RosNode::filename() const {
  // @@protoc_insertion_point(field_get:RosNode.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosNode::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosNode.filename)
}
inline std::string* RosNode::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:RosNode.filename)
  return _s;
}
inline const std::string& RosNode::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void RosNode::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* RosNode::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* RosNode::release_filename() {
  // @@protoc_insertion_point(field_release:RosNode.filename)
  return _impl_.filename_.Release();
}
inline void RosNode::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosNode.filename)
}

// bool is_running = 6;
inline void RosNode::clear_is_running() {
  _impl_.is_running_ = false;
}
inline bool RosNode::_internal_is_running() const {
  return _impl_.is_running_;
}
inline bool RosNode::is_running() const {
  // @@protoc_insertion_point(field_get:RosNode.is_running)
  return _internal_is_running();
}
inline void RosNode::_internal_set_is_running(bool value) {
  
  _impl_.is_running_ = value;
}
inline void RosNode::set_is_running(bool value) {
  _internal_set_is_running(value);
  // @@protoc_insertion_point(field_set:RosNode.is_running)
}

// -------------------------------------------------------------------

// RosNodesCfg

// repeated .RosNode nodes = 1;
inline int RosNodesCfg::_internal_nodes_size() const {
  return _impl_.nodes_.size();
}
inline int RosNodesCfg::nodes_size() const {
  return _internal_nodes_size();
}
inline void RosNodesCfg::clear_nodes() {
  _impl_.nodes_.Clear();
}
inline ::RosNode* RosNodesCfg::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:RosNodesCfg.nodes)
  return _impl_.nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosNode >*
RosNodesCfg::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:RosNodesCfg.nodes)
  return &_impl_.nodes_;
}
inline const ::RosNode& RosNodesCfg::_internal_nodes(int index) const {
  return _impl_.nodes_.Get(index);
}
inline const ::RosNode& RosNodesCfg::nodes(int index) const {
  // @@protoc_insertion_point(field_get:RosNodesCfg.nodes)
  return _internal_nodes(index);
}
inline ::RosNode* RosNodesCfg::_internal_add_nodes() {
  return _impl_.nodes_.Add();
}
inline ::RosNode* RosNodesCfg::add_nodes() {
  ::RosNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:RosNodesCfg.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosNode >&
RosNodesCfg::nodes() const {
  // @@protoc_insertion_point(field_list:RosNodesCfg.nodes)
  return _impl_.nodes_;
}

// -------------------------------------------------------------------

// RosoutMsg_RosoutInfo

// int32 level = 1;
inline void RosoutMsg_RosoutInfo::clear_level() {
  _impl_.level_ = 0;
}
inline int32_t RosoutMsg_RosoutInfo::_internal_level() const {
  return _impl_.level_;
}
inline int32_t RosoutMsg_RosoutInfo::level() const {
  // @@protoc_insertion_point(field_get:RosoutMsg.RosoutInfo.level)
  return _internal_level();
}
inline void RosoutMsg_RosoutInfo::_internal_set_level(int32_t value) {
  
  _impl_.level_ = value;
}
inline void RosoutMsg_RosoutInfo::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:RosoutMsg.RosoutInfo.level)
}

// string name = 2;
inline void RosoutMsg_RosoutInfo::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& RosoutMsg_RosoutInfo::name() const {
  // @@protoc_insertion_point(field_get:RosoutMsg.RosoutInfo.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosoutMsg_RosoutInfo::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosoutMsg.RosoutInfo.name)
}
inline std::string* RosoutMsg_RosoutInfo::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:RosoutMsg.RosoutInfo.name)
  return _s;
}
inline const std::string& RosoutMsg_RosoutInfo::_internal_name() const {
  return _impl_.name_.Get();
}
inline void RosoutMsg_RosoutInfo::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::release_name() {
  // @@protoc_insertion_point(field_release:RosoutMsg.RosoutInfo.name)
  return _impl_.name_.Release();
}
inline void RosoutMsg_RosoutInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosoutMsg.RosoutInfo.name)
}

// string msg = 3;
inline void RosoutMsg_RosoutInfo::clear_msg() {
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& RosoutMsg_RosoutInfo::msg() const {
  // @@protoc_insertion_point(field_get:RosoutMsg.RosoutInfo.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosoutMsg_RosoutInfo::set_msg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.msg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosoutMsg.RosoutInfo.msg)
}
inline std::string* RosoutMsg_RosoutInfo::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:RosoutMsg.RosoutInfo.msg)
  return _s;
}
inline const std::string& RosoutMsg_RosoutInfo::_internal_msg() const {
  return _impl_.msg_.Get();
}
inline void RosoutMsg_RosoutInfo::_internal_set_msg(const std::string& value) {
  
  _impl_.msg_.Set(value, GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::_internal_mutable_msg() {
  
  return _impl_.msg_.Mutable(GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::release_msg() {
  // @@protoc_insertion_point(field_release:RosoutMsg.RosoutInfo.msg)
  return _impl_.msg_.Release();
}
inline void RosoutMsg_RosoutInfo::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  _impl_.msg_.SetAllocated(msg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.msg_.IsDefault()) {
    _impl_.msg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosoutMsg.RosoutInfo.msg)
}

// string topic = 4;
inline void RosoutMsg_RosoutInfo::clear_topic() {
  _impl_.topic_.ClearToEmpty();
}
inline const std::string& RosoutMsg_RosoutInfo::topic() const {
  // @@protoc_insertion_point(field_get:RosoutMsg.RosoutInfo.topic)
  return _internal_topic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RosoutMsg_RosoutInfo::set_topic(ArgT0&& arg0, ArgT... args) {
 
 _impl_.topic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RosoutMsg.RosoutInfo.topic)
}
inline std::string* RosoutMsg_RosoutInfo::mutable_topic() {
  std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:RosoutMsg.RosoutInfo.topic)
  return _s;
}
inline const std::string& RosoutMsg_RosoutInfo::_internal_topic() const {
  return _impl_.topic_.Get();
}
inline void RosoutMsg_RosoutInfo::_internal_set_topic(const std::string& value) {
  
  _impl_.topic_.Set(value, GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::_internal_mutable_topic() {
  
  return _impl_.topic_.Mutable(GetArenaForAllocation());
}
inline std::string* RosoutMsg_RosoutInfo::release_topic() {
  // @@protoc_insertion_point(field_release:RosoutMsg.RosoutInfo.topic)
  return _impl_.topic_.Release();
}
inline void RosoutMsg_RosoutInfo::set_allocated_topic(std::string* topic) {
  if (topic != nullptr) {
    
  } else {
    
  }
  _impl_.topic_.SetAllocated(topic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RosoutMsg.RosoutInfo.topic)
}

// -------------------------------------------------------------------

// RosoutMsg

// repeated .RosoutMsg.RosoutInfo messages = 1;
inline int RosoutMsg::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int RosoutMsg::messages_size() const {
  return _internal_messages_size();
}
inline void RosoutMsg::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::RosoutMsg_RosoutInfo* RosoutMsg::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:RosoutMsg.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosoutMsg_RosoutInfo >*
RosoutMsg::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:RosoutMsg.messages)
  return &_impl_.messages_;
}
inline const ::RosoutMsg_RosoutInfo& RosoutMsg::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::RosoutMsg_RosoutInfo& RosoutMsg::messages(int index) const {
  // @@protoc_insertion_point(field_get:RosoutMsg.messages)
  return _internal_messages(index);
}
inline ::RosoutMsg_RosoutInfo* RosoutMsg::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::RosoutMsg_RosoutInfo* RosoutMsg::add_messages() {
  ::RosoutMsg_RosoutInfo* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:RosoutMsg.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RosoutMsg_RosoutInfo >&
RosoutMsg::messages() const {
  // @@protoc_insertion_point(field_list:RosoutMsg.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// AlarmMsg

// int32 code = 1;
inline void AlarmMsg::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t AlarmMsg::_internal_code() const {
  return _impl_.code_;
}
inline int32_t AlarmMsg::code() const {
  // @@protoc_insertion_point(field_get:AlarmMsg.code)
  return _internal_code();
}
inline void AlarmMsg::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void AlarmMsg::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:AlarmMsg.code)
}

// bool cleared = 2;
inline void AlarmMsg::clear_cleared() {
  _impl_.cleared_ = false;
}
inline bool AlarmMsg::_internal_cleared() const {
  return _impl_.cleared_;
}
inline bool AlarmMsg::cleared() const {
  // @@protoc_insertion_point(field_get:AlarmMsg.cleared)
  return _internal_cleared();
}
inline void AlarmMsg::_internal_set_cleared(bool value) {
  
  _impl_.cleared_ = value;
}
inline void AlarmMsg::set_cleared(bool value) {
  _internal_set_cleared(value);
  // @@protoc_insertion_point(field_set:AlarmMsg.cleared)
}

// -------------------------------------------------------------------

// NetworkConfig

// string name = 1;
inline void NetworkConfig::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NetworkConfig::name() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.name)
}
inline std::string* NetworkConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.name)
  return _s;
}
inline const std::string& NetworkConfig::_internal_name() const {
  return _impl_.name_.Get();
}
inline void NetworkConfig::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_name() {
  // @@protoc_insertion_point(field_release:NetworkConfig.name)
  return _impl_.name_.Release();
}
inline void NetworkConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.name)
}

// string address = 2;
inline void NetworkConfig::clear_address() {
  _impl_.address_.ClearToEmpty();
}
inline const std::string& NetworkConfig::address() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_address(ArgT0&& arg0, ArgT... args) {
 
 _impl_.address_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.address)
}
inline std::string* NetworkConfig::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.address)
  return _s;
}
inline const std::string& NetworkConfig::_internal_address() const {
  return _impl_.address_.Get();
}
inline void NetworkConfig::_internal_set_address(const std::string& value) {
  
  _impl_.address_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_address() {
  
  return _impl_.address_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_address() {
  // @@protoc_insertion_point(field_release:NetworkConfig.address)
  return _impl_.address_.Release();
}
inline void NetworkConfig::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  _impl_.address_.SetAllocated(address, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.address_.IsDefault()) {
    _impl_.address_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.address)
}

// string mac = 3;
inline void NetworkConfig::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& NetworkConfig::mac() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.mac)
}
inline std::string* NetworkConfig::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.mac)
  return _s;
}
inline const std::string& NetworkConfig::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void NetworkConfig::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_mac() {
  // @@protoc_insertion_point(field_release:NetworkConfig.mac)
  return _impl_.mac_.Release();
}
inline void NetworkConfig::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.mac)
}

// string netmask = 4;
inline void NetworkConfig::clear_netmask() {
  _impl_.netmask_.ClearToEmpty();
}
inline const std::string& NetworkConfig::netmask() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.netmask)
  return _internal_netmask();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_netmask(ArgT0&& arg0, ArgT... args) {
 
 _impl_.netmask_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.netmask)
}
inline std::string* NetworkConfig::mutable_netmask() {
  std::string* _s = _internal_mutable_netmask();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.netmask)
  return _s;
}
inline const std::string& NetworkConfig::_internal_netmask() const {
  return _impl_.netmask_.Get();
}
inline void NetworkConfig::_internal_set_netmask(const std::string& value) {
  
  _impl_.netmask_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_netmask() {
  
  return _impl_.netmask_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_netmask() {
  // @@protoc_insertion_point(field_release:NetworkConfig.netmask)
  return _impl_.netmask_.Release();
}
inline void NetworkConfig::set_allocated_netmask(std::string* netmask) {
  if (netmask != nullptr) {
    
  } else {
    
  }
  _impl_.netmask_.SetAllocated(netmask, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.netmask_.IsDefault()) {
    _impl_.netmask_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.netmask)
}

// string gateway = 5;
inline void NetworkConfig::clear_gateway() {
  _impl_.gateway_.ClearToEmpty();
}
inline const std::string& NetworkConfig::gateway() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.gateway)
  return _internal_gateway();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_gateway(ArgT0&& arg0, ArgT... args) {
 
 _impl_.gateway_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.gateway)
}
inline std::string* NetworkConfig::mutable_gateway() {
  std::string* _s = _internal_mutable_gateway();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.gateway)
  return _s;
}
inline const std::string& NetworkConfig::_internal_gateway() const {
  return _impl_.gateway_.Get();
}
inline void NetworkConfig::_internal_set_gateway(const std::string& value) {
  
  _impl_.gateway_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_gateway() {
  
  return _impl_.gateway_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_gateway() {
  // @@protoc_insertion_point(field_release:NetworkConfig.gateway)
  return _impl_.gateway_.Release();
}
inline void NetworkConfig::set_allocated_gateway(std::string* gateway) {
  if (gateway != nullptr) {
    
  } else {
    
  }
  _impl_.gateway_.SetAllocated(gateway, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.gateway_.IsDefault()) {
    _impl_.gateway_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.gateway)
}

// string dns = 6;
inline void NetworkConfig::clear_dns() {
  _impl_.dns_.ClearToEmpty();
}
inline const std::string& NetworkConfig::dns() const {
  // @@protoc_insertion_point(field_get:NetworkConfig.dns)
  return _internal_dns();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConfig::set_dns(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dns_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:NetworkConfig.dns)
}
inline std::string* NetworkConfig::mutable_dns() {
  std::string* _s = _internal_mutable_dns();
  // @@protoc_insertion_point(field_mutable:NetworkConfig.dns)
  return _s;
}
inline const std::string& NetworkConfig::_internal_dns() const {
  return _impl_.dns_.Get();
}
inline void NetworkConfig::_internal_set_dns(const std::string& value) {
  
  _impl_.dns_.Set(value, GetArenaForAllocation());
}
inline std::string* NetworkConfig::_internal_mutable_dns() {
  
  return _impl_.dns_.Mutable(GetArenaForAllocation());
}
inline std::string* NetworkConfig::release_dns() {
  // @@protoc_insertion_point(field_release:NetworkConfig.dns)
  return _impl_.dns_.Release();
}
inline void NetworkConfig::set_allocated_dns(std::string* dns) {
  if (dns != nullptr) {
    
  } else {
    
  }
  _impl_.dns_.SetAllocated(dns, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dns_.IsDefault()) {
    _impl_.dns_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:NetworkConfig.dns)
}

// -------------------------------------------------------------------

// WirlessConfig

// string ssid = 1;
inline void WirlessConfig::clear_ssid() {
  _impl_.ssid_.ClearToEmpty();
}
inline const std::string& WirlessConfig::ssid() const {
  // @@protoc_insertion_point(field_get:WirlessConfig.ssid)
  return _internal_ssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WirlessConfig::set_ssid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ssid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WirlessConfig.ssid)
}
inline std::string* WirlessConfig::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:WirlessConfig.ssid)
  return _s;
}
inline const std::string& WirlessConfig::_internal_ssid() const {
  return _impl_.ssid_.Get();
}
inline void WirlessConfig::_internal_set_ssid(const std::string& value) {
  
  _impl_.ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* WirlessConfig::_internal_mutable_ssid() {
  
  return _impl_.ssid_.Mutable(GetArenaForAllocation());
}
inline std::string* WirlessConfig::release_ssid() {
  // @@protoc_insertion_point(field_release:WirlessConfig.ssid)
  return _impl_.ssid_.Release();
}
inline void WirlessConfig::set_allocated_ssid(std::string* ssid) {
  if (ssid != nullptr) {
    
  } else {
    
  }
  _impl_.ssid_.SetAllocated(ssid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ssid_.IsDefault()) {
    _impl_.ssid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WirlessConfig.ssid)
}

// string passwd = 2;
inline void WirlessConfig::clear_passwd() {
  _impl_.passwd_.ClearToEmpty();
}
inline const std::string& WirlessConfig::passwd() const {
  // @@protoc_insertion_point(field_get:WirlessConfig.passwd)
  return _internal_passwd();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WirlessConfig::set_passwd(ArgT0&& arg0, ArgT... args) {
 
 _impl_.passwd_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WirlessConfig.passwd)
}
inline std::string* WirlessConfig::mutable_passwd() {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:WirlessConfig.passwd)
  return _s;
}
inline const std::string& WirlessConfig::_internal_passwd() const {
  return _impl_.passwd_.Get();
}
inline void WirlessConfig::_internal_set_passwd(const std::string& value) {
  
  _impl_.passwd_.Set(value, GetArenaForAllocation());
}
inline std::string* WirlessConfig::_internal_mutable_passwd() {
  
  return _impl_.passwd_.Mutable(GetArenaForAllocation());
}
inline std::string* WirlessConfig::release_passwd() {
  // @@protoc_insertion_point(field_release:WirlessConfig.passwd)
  return _impl_.passwd_.Release();
}
inline void WirlessConfig::set_allocated_passwd(std::string* passwd) {
  if (passwd != nullptr) {
    
  } else {
    
  }
  _impl_.passwd_.SetAllocated(passwd, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.passwd_.IsDefault()) {
    _impl_.passwd_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WirlessConfig.passwd)
}

// .NetworkConfig config = 3;
inline bool WirlessConfig::_internal_has_config() const {
  return this != internal_default_instance() && _impl_.config_ != nullptr;
}
inline bool WirlessConfig::has_config() const {
  return _internal_has_config();
}
inline void WirlessConfig::clear_config() {
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
}
inline const ::NetworkConfig& WirlessConfig::_internal_config() const {
  const ::NetworkConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::NetworkConfig&>(
      ::_NetworkConfig_default_instance_);
}
inline const ::NetworkConfig& WirlessConfig::config() const {
  // @@protoc_insertion_point(field_get:WirlessConfig.config)
  return _internal_config();
}
inline void WirlessConfig::unsafe_arena_set_allocated_config(
    ::NetworkConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:WirlessConfig.config)
}
inline ::NetworkConfig* WirlessConfig::release_config() {
  
  ::NetworkConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::NetworkConfig* WirlessConfig::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:WirlessConfig.config)
  
  ::NetworkConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::NetworkConfig* WirlessConfig::_internal_mutable_config() {
  
  if (_impl_.config_ == nullptr) {
    auto* p = CreateMaybeMessage<::NetworkConfig>(GetArenaForAllocation());
    _impl_.config_ = p;
  }
  return _impl_.config_;
}
inline ::NetworkConfig* WirlessConfig::mutable_config() {
  ::NetworkConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:WirlessConfig.config)
  return _msg;
}
inline void WirlessConfig::set_allocated_config(::NetworkConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.config_ = config;
  // @@protoc_insertion_point(field_set_allocated:WirlessConfig.config)
}

// -------------------------------------------------------------------

// WirlessInfo

// string ssid = 1;
inline void WirlessInfo::clear_ssid() {
  _impl_.ssid_.ClearToEmpty();
}
inline const std::string& WirlessInfo::ssid() const {
  // @@protoc_insertion_point(field_get:WirlessInfo.ssid)
  return _internal_ssid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WirlessInfo::set_ssid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ssid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WirlessInfo.ssid)
}
inline std::string* WirlessInfo::mutable_ssid() {
  std::string* _s = _internal_mutable_ssid();
  // @@protoc_insertion_point(field_mutable:WirlessInfo.ssid)
  return _s;
}
inline const std::string& WirlessInfo::_internal_ssid() const {
  return _impl_.ssid_.Get();
}
inline void WirlessInfo::_internal_set_ssid(const std::string& value) {
  
  _impl_.ssid_.Set(value, GetArenaForAllocation());
}
inline std::string* WirlessInfo::_internal_mutable_ssid() {
  
  return _impl_.ssid_.Mutable(GetArenaForAllocation());
}
inline std::string* WirlessInfo::release_ssid() {
  // @@protoc_insertion_point(field_release:WirlessInfo.ssid)
  return _impl_.ssid_.Release();
}
inline void WirlessInfo::set_allocated_ssid(std::string* ssid) {
  if (ssid != nullptr) {
    
  } else {
    
  }
  _impl_.ssid_.SetAllocated(ssid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ssid_.IsDefault()) {
    _impl_.ssid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WirlessInfo.ssid)
}

// int32 signalLevel = 2;
inline void WirlessInfo::clear_signallevel() {
  _impl_.signallevel_ = 0;
}
inline int32_t WirlessInfo::_internal_signallevel() const {
  return _impl_.signallevel_;
}
inline int32_t WirlessInfo::signallevel() const {
  // @@protoc_insertion_point(field_get:WirlessInfo.signalLevel)
  return _internal_signallevel();
}
inline void WirlessInfo::_internal_set_signallevel(int32_t value) {
  
  _impl_.signallevel_ = value;
}
inline void WirlessInfo::set_signallevel(int32_t value) {
  _internal_set_signallevel(value);
  // @@protoc_insertion_point(field_set:WirlessInfo.signalLevel)
}

// -------------------------------------------------------------------

// WLANList

// repeated .WirlessInfo wirlessList = 1;
inline int WLANList::_internal_wirlesslist_size() const {
  return _impl_.wirlesslist_.size();
}
inline int WLANList::wirlesslist_size() const {
  return _internal_wirlesslist_size();
}
inline void WLANList::clear_wirlesslist() {
  _impl_.wirlesslist_.Clear();
}
inline ::WirlessInfo* WLANList::mutable_wirlesslist(int index) {
  // @@protoc_insertion_point(field_mutable:WLANList.wirlessList)
  return _impl_.wirlesslist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WirlessInfo >*
WLANList::mutable_wirlesslist() {
  // @@protoc_insertion_point(field_mutable_list:WLANList.wirlessList)
  return &_impl_.wirlesslist_;
}
inline const ::WirlessInfo& WLANList::_internal_wirlesslist(int index) const {
  return _impl_.wirlesslist_.Get(index);
}
inline const ::WirlessInfo& WLANList::wirlesslist(int index) const {
  // @@protoc_insertion_point(field_get:WLANList.wirlessList)
  return _internal_wirlesslist(index);
}
inline ::WirlessInfo* WLANList::_internal_add_wirlesslist() {
  return _impl_.wirlesslist_.Add();
}
inline ::WirlessInfo* WLANList::add_wirlesslist() {
  ::WirlessInfo* _add = _internal_add_wirlesslist();
  // @@protoc_insertion_point(field_add:WLANList.wirlessList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::WirlessInfo >&
WLANList::wirlesslist() const {
  // @@protoc_insertion_point(field_list:WLANList.wirlessList)
  return _impl_.wirlesslist_;
}

// -------------------------------------------------------------------

// NetworkConfigCollection

// repeated .NetworkConfig config_collection = 1;
inline int NetworkConfigCollection::_internal_config_collection_size() const {
  return _impl_.config_collection_.size();
}
inline int NetworkConfigCollection::config_collection_size() const {
  return _internal_config_collection_size();
}
inline void NetworkConfigCollection::clear_config_collection() {
  _impl_.config_collection_.Clear();
}
inline ::NetworkConfig* NetworkConfigCollection::mutable_config_collection(int index) {
  // @@protoc_insertion_point(field_mutable:NetworkConfigCollection.config_collection)
  return _impl_.config_collection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NetworkConfig >*
NetworkConfigCollection::mutable_config_collection() {
  // @@protoc_insertion_point(field_mutable_list:NetworkConfigCollection.config_collection)
  return &_impl_.config_collection_;
}
inline const ::NetworkConfig& NetworkConfigCollection::_internal_config_collection(int index) const {
  return _impl_.config_collection_.Get(index);
}
inline const ::NetworkConfig& NetworkConfigCollection::config_collection(int index) const {
  // @@protoc_insertion_point(field_get:NetworkConfigCollection.config_collection)
  return _internal_config_collection(index);
}
inline ::NetworkConfig* NetworkConfigCollection::_internal_add_config_collection() {
  return _impl_.config_collection_.Add();
}
inline ::NetworkConfig* NetworkConfigCollection::add_config_collection() {
  ::NetworkConfig* _add = _internal_add_config_collection();
  // @@protoc_insertion_point(field_add:NetworkConfigCollection.config_collection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::NetworkConfig >&
NetworkConfigCollection::config_collection() const {
  // @@protoc_insertion_point(field_list:NetworkConfigCollection.config_collection)
  return _impl_.config_collection_;
}

// -------------------------------------------------------------------

// InstallPack

// string filename = 1;
inline void InstallPack::clear_filename() {
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& InstallPack::filename() const {
  // @@protoc_insertion_point(field_get:InstallPack.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InstallPack::set_filename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InstallPack.filename)
}
inline std::string* InstallPack::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:InstallPack.filename)
  return _s;
}
inline const std::string& InstallPack::_internal_filename() const {
  return _impl_.filename_.Get();
}
inline void InstallPack::_internal_set_filename(const std::string& value) {
  
  _impl_.filename_.Set(value, GetArenaForAllocation());
}
inline std::string* InstallPack::_internal_mutable_filename() {
  
  return _impl_.filename_.Mutable(GetArenaForAllocation());
}
inline std::string* InstallPack::release_filename() {
  // @@protoc_insertion_point(field_release:InstallPack.filename)
  return _impl_.filename_.Release();
}
inline void InstallPack::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  _impl_.filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filename_.IsDefault()) {
    _impl_.filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InstallPack.filename)
}

// -------------------------------------------------------------------

// SystemStatus

// string version = 1;
inline void SystemStatus::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& SystemStatus::version() const {
  // @@protoc_insertion_point(field_get:SystemStatus.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SystemStatus::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SystemStatus.version)
}
inline std::string* SystemStatus::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:SystemStatus.version)
  return _s;
}
inline const std::string& SystemStatus::_internal_version() const {
  return _impl_.version_.Get();
}
inline void SystemStatus::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* SystemStatus::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* SystemStatus::release_version() {
  // @@protoc_insertion_point(field_release:SystemStatus.version)
  return _impl_.version_.Release();
}
inline void SystemStatus::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SystemStatus.version)
}

// float cpu_usage = 2;
inline void SystemStatus::clear_cpu_usage() {
  _impl_.cpu_usage_ = 0;
}
inline float SystemStatus::_internal_cpu_usage() const {
  return _impl_.cpu_usage_;
}
inline float SystemStatus::cpu_usage() const {
  // @@protoc_insertion_point(field_get:SystemStatus.cpu_usage)
  return _internal_cpu_usage();
}
inline void SystemStatus::_internal_set_cpu_usage(float value) {
  
  _impl_.cpu_usage_ = value;
}
inline void SystemStatus::set_cpu_usage(float value) {
  _internal_set_cpu_usage(value);
  // @@protoc_insertion_point(field_set:SystemStatus.cpu_usage)
}

// int32 mem_total = 3;
inline void SystemStatus::clear_mem_total() {
  _impl_.mem_total_ = 0;
}
inline int32_t SystemStatus::_internal_mem_total() const {
  return _impl_.mem_total_;
}
inline int32_t SystemStatus::mem_total() const {
  // @@protoc_insertion_point(field_get:SystemStatus.mem_total)
  return _internal_mem_total();
}
inline void SystemStatus::_internal_set_mem_total(int32_t value) {
  
  _impl_.mem_total_ = value;
}
inline void SystemStatus::set_mem_total(int32_t value) {
  _internal_set_mem_total(value);
  // @@protoc_insertion_point(field_set:SystemStatus.mem_total)
}

// int32 mem_used = 4;
inline void SystemStatus::clear_mem_used() {
  _impl_.mem_used_ = 0;
}
inline int32_t SystemStatus::_internal_mem_used() const {
  return _impl_.mem_used_;
}
inline int32_t SystemStatus::mem_used() const {
  // @@protoc_insertion_point(field_get:SystemStatus.mem_used)
  return _internal_mem_used();
}
inline void SystemStatus::_internal_set_mem_used(int32_t value) {
  
  _impl_.mem_used_ = value;
}
inline void SystemStatus::set_mem_used(int32_t value) {
  _internal_set_mem_used(value);
  // @@protoc_insertion_point(field_set:SystemStatus.mem_used)
}

// int32 disk_total = 5;
inline void SystemStatus::clear_disk_total() {
  _impl_.disk_total_ = 0;
}
inline int32_t SystemStatus::_internal_disk_total() const {
  return _impl_.disk_total_;
}
inline int32_t SystemStatus::disk_total() const {
  // @@protoc_insertion_point(field_get:SystemStatus.disk_total)
  return _internal_disk_total();
}
inline void SystemStatus::_internal_set_disk_total(int32_t value) {
  
  _impl_.disk_total_ = value;
}
inline void SystemStatus::set_disk_total(int32_t value) {
  _internal_set_disk_total(value);
  // @@protoc_insertion_point(field_set:SystemStatus.disk_total)
}

// int32 disk_used = 6;
inline void SystemStatus::clear_disk_used() {
  _impl_.disk_used_ = 0;
}
inline int32_t SystemStatus::_internal_disk_used() const {
  return _impl_.disk_used_;
}
inline int32_t SystemStatus::disk_used() const {
  // @@protoc_insertion_point(field_get:SystemStatus.disk_used)
  return _internal_disk_used();
}
inline void SystemStatus::_internal_set_disk_used(int32_t value) {
  
  _impl_.disk_used_ = value;
}
inline void SystemStatus::set_disk_used(int32_t value) {
  _internal_set_disk_used(value);
  // @@protoc_insertion_point(field_set:SystemStatus.disk_used)
}

// -------------------------------------------------------------------

// UpdateStation

// int32 marker_type = 1;
inline void UpdateStation::clear_marker_type() {
  _impl_.marker_type_ = 0;
}
inline int32_t UpdateStation::_internal_marker_type() const {
  return _impl_.marker_type_;
}
inline int32_t UpdateStation::marker_type() const {
  // @@protoc_insertion_point(field_get:UpdateStation.marker_type)
  return _internal_marker_type();
}
inline void UpdateStation::_internal_set_marker_type(int32_t value) {
  
  _impl_.marker_type_ = value;
}
inline void UpdateStation::set_marker_type(int32_t value) {
  _internal_set_marker_type(value);
  // @@protoc_insertion_point(field_set:UpdateStation.marker_type)
}

// -------------------------------------------------------------------

// UpdatePose

// .Result error_info = 1;
inline bool UpdatePose::_internal_has_error_info() const {
  return this != internal_default_instance() && _impl_.error_info_ != nullptr;
}
inline bool UpdatePose::has_error_info() const {
  return _internal_has_error_info();
}
inline const ::Result& UpdatePose::_internal_error_info() const {
  const ::Result* p = _impl_.error_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::Result&>(
      ::_Result_default_instance_);
}
inline const ::Result& UpdatePose::error_info() const {
  // @@protoc_insertion_point(field_get:UpdatePose.error_info)
  return _internal_error_info();
}
inline void UpdatePose::unsafe_arena_set_allocated_error_info(
    ::Result* error_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_info_);
  }
  _impl_.error_info_ = error_info;
  if (error_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdatePose.error_info)
}
inline ::Result* UpdatePose::release_error_info() {
  
  ::Result* temp = _impl_.error_info_;
  _impl_.error_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Result* UpdatePose::unsafe_arena_release_error_info() {
  // @@protoc_insertion_point(field_release:UpdatePose.error_info)
  
  ::Result* temp = _impl_.error_info_;
  _impl_.error_info_ = nullptr;
  return temp;
}
inline ::Result* UpdatePose::_internal_mutable_error_info() {
  
  if (_impl_.error_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::Result>(GetArenaForAllocation());
    _impl_.error_info_ = p;
  }
  return _impl_.error_info_;
}
inline ::Result* UpdatePose::mutable_error_info() {
  ::Result* _msg = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:UpdatePose.error_info)
  return _msg;
}
inline void UpdatePose::set_allocated_error_info(::Result* error_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_info_);
  }
  if (error_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_info));
    if (message_arena != submessage_arena) {
      error_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error_info, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_info_ = error_info;
  // @@protoc_insertion_point(field_set_allocated:UpdatePose.error_info)
}

// .Position pose = 2;
inline bool UpdatePose::_internal_has_pose() const {
  return this != internal_default_instance() && _impl_.pose_ != nullptr;
}
inline bool UpdatePose::has_pose() const {
  return _internal_has_pose();
}
inline const ::Position& UpdatePose::_internal_pose() const {
  const ::Position* p = _impl_.pose_;
  return p != nullptr ? *p : reinterpret_cast<const ::Position&>(
      ::_Position_default_instance_);
}
inline const ::Position& UpdatePose::pose() const {
  // @@protoc_insertion_point(field_get:UpdatePose.pose)
  return _internal_pose();
}
inline void UpdatePose::unsafe_arena_set_allocated_pose(
    ::Position* pose) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  _impl_.pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdatePose.pose)
}
inline ::Position* UpdatePose::release_pose() {
  
  ::Position* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Position* UpdatePose::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:UpdatePose.pose)
  
  ::Position* temp = _impl_.pose_;
  _impl_.pose_ = nullptr;
  return temp;
}
inline ::Position* UpdatePose::_internal_mutable_pose() {
  
  if (_impl_.pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Position>(GetArenaForAllocation());
    _impl_.pose_ = p;
  }
  return _impl_.pose_;
}
inline ::Position* UpdatePose::mutable_pose() {
  ::Position* _msg = _internal_mutable_pose();
  // @@protoc_insertion_point(field_mutable:UpdatePose.pose)
  return _msg;
}
inline void UpdatePose::set_allocated_pose(::Position* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pose_);
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose));
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:UpdatePose.pose)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::AgvInfo_Alarm_Source> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AgvInfo_Alarm_Source>() {
  return ::AgvInfo_Alarm_Source_descriptor();
}
template <> struct is_proto_enum< ::AgvInfo_Alarm_Level> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AgvInfo_Alarm_Level>() {
  return ::AgvInfo_Alarm_Level_descriptor();
}
template <> struct is_proto_enum< ::Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Language>() {
  return ::Language_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_camel_2dgrpc_2eproto
