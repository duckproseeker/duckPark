// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camel-db.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_camel_2ddb_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_camel_2ddb_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_camel_2ddb_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_camel_2ddb_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_camel_2ddb_2eproto;
class ISeeMap;
struct ISeeMapDefaultTypeInternal;
extern ISeeMapDefaultTypeInternal _ISeeMap_default_instance_;
class ISeeMap_Area;
struct ISeeMap_AreaDefaultTypeInternal;
extern ISeeMap_AreaDefaultTypeInternal _ISeeMap_Area_default_instance_;
class ISeeMap_CarManagemet;
struct ISeeMap_CarManagemetDefaultTypeInternal;
extern ISeeMap_CarManagemetDefaultTypeInternal _ISeeMap_CarManagemet_default_instance_;
class ISeeMap_Configuration;
struct ISeeMap_ConfigurationDefaultTypeInternal;
extern ISeeMap_ConfigurationDefaultTypeInternal _ISeeMap_Configuration_default_instance_;
class ISeeMap_CoordOffset;
struct ISeeMap_CoordOffsetDefaultTypeInternal;
extern ISeeMap_CoordOffsetDefaultTypeInternal _ISeeMap_CoordOffset_default_instance_;
class ISeeMap_Path;
struct ISeeMap_PathDefaultTypeInternal;
extern ISeeMap_PathDefaultTypeInternal _ISeeMap_Path_default_instance_;
class ISeeMap_Region;
struct ISeeMap_RegionDefaultTypeInternal;
extern ISeeMap_RegionDefaultTypeInternal _ISeeMap_Region_default_instance_;
class ISeeMap_Station;
struct ISeeMap_StationDefaultTypeInternal;
extern ISeeMap_StationDefaultTypeInternal _ISeeMap_Station_default_instance_;
class ISeeMap_TaskAction;
struct ISeeMap_TaskActionDefaultTypeInternal;
extern ISeeMap_TaskActionDefaultTypeInternal _ISeeMap_TaskAction_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ISeeMap* Arena::CreateMaybeMessage<::ISeeMap>(Arena*);
template<> ::ISeeMap_Area* Arena::CreateMaybeMessage<::ISeeMap_Area>(Arena*);
template<> ::ISeeMap_CarManagemet* Arena::CreateMaybeMessage<::ISeeMap_CarManagemet>(Arena*);
template<> ::ISeeMap_Configuration* Arena::CreateMaybeMessage<::ISeeMap_Configuration>(Arena*);
template<> ::ISeeMap_CoordOffset* Arena::CreateMaybeMessage<::ISeeMap_CoordOffset>(Arena*);
template<> ::ISeeMap_Path* Arena::CreateMaybeMessage<::ISeeMap_Path>(Arena*);
template<> ::ISeeMap_Region* Arena::CreateMaybeMessage<::ISeeMap_Region>(Arena*);
template<> ::ISeeMap_Station* Arena::CreateMaybeMessage<::ISeeMap_Station>(Arena*);
template<> ::ISeeMap_TaskAction* Arena::CreateMaybeMessage<::ISeeMap_TaskAction>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ISeeMap_Region final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.Region) */ {
 public:
  inline ISeeMap_Region() : ISeeMap_Region(nullptr) {}
  ~ISeeMap_Region() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_Region(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_Region(const ISeeMap_Region& from);
  ISeeMap_Region(ISeeMap_Region&& from) noexcept
    : ISeeMap_Region() {
    *this = ::std::move(from);
  }

  inline ISeeMap_Region& operator=(const ISeeMap_Region& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_Region& operator=(ISeeMap_Region&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_Region& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_Region* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_Region*>(
               &_ISeeMap_Region_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ISeeMap_Region& a, ISeeMap_Region& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_Region* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_Region* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_Region* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_Region>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_Region& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_Region& from) {
    ISeeMap_Region::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_Region* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.Region";
  }
  protected:
  explicit ISeeMap_Region(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kNameFieldNumber = 3,
    kValidFieldNumber = 5,
    kLmuserFieldNumber = 6,
    kMapVersionFieldNumber = 7,
    kLmdateFieldNumber = 8,
    kFloorNumberFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bytes name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string valid = 5;
  void clear_valid();
  const std::string& valid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valid();
  PROTOBUF_NODISCARD std::string* release_valid();
  void set_allocated_valid(std::string* valid);
  private:
  const std::string& _internal_valid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valid(const std::string& value);
  std::string* _internal_mutable_valid();
  public:

  // bytes lmuser = 6;
  void clear_lmuser();
  const std::string& lmuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmuser();
  PROTOBUF_NODISCARD std::string* release_lmuser();
  void set_allocated_lmuser(std::string* lmuser);
  private:
  const std::string& _internal_lmuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmuser(const std::string& value);
  std::string* _internal_mutable_lmuser();
  public:

  // bytes mapVersion = 7;
  void clear_mapversion();
  const std::string& mapversion() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mapversion(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mapversion();
  PROTOBUF_NODISCARD std::string* release_mapversion();
  void set_allocated_mapversion(std::string* mapversion);
  private:
  const std::string& _internal_mapversion() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mapversion(const std::string& value);
  std::string* _internal_mutable_mapversion();
  public:

  // string lmdate = 8;
  void clear_lmdate();
  const std::string& lmdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmdate();
  PROTOBUF_NODISCARD std::string* release_lmdate();
  void set_allocated_lmdate(std::string* lmdate);
  private:
  const std::string& _internal_lmdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmdate(const std::string& value);
  std::string* _internal_mutable_lmdate();
  public:

  // int32 floor_number = 4;
  void clear_floor_number();
  int32_t floor_number() const;
  void set_floor_number(int32_t value);
  private:
  int32_t _internal_floor_number() const;
  void _internal_set_floor_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.Region)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmuser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapversion_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmdate_;
    int32_t floor_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_Area final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.Area) */ {
 public:
  inline ISeeMap_Area() : ISeeMap_Area(nullptr) {}
  ~ISeeMap_Area() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_Area(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_Area(const ISeeMap_Area& from);
  ISeeMap_Area(ISeeMap_Area&& from) noexcept
    : ISeeMap_Area() {
    *this = ::std::move(from);
  }

  inline ISeeMap_Area& operator=(const ISeeMap_Area& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_Area& operator=(ISeeMap_Area&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_Area& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_Area* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_Area*>(
               &_ISeeMap_Area_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ISeeMap_Area& a, ISeeMap_Area& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_Area* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_Area* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_Area* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_Area>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_Area& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_Area& from) {
    ISeeMap_Area::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_Area* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.Area";
  }
  protected:
  explicit ISeeMap_Area(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kRegionIdFieldNumber = 4,
    kForkLiftHeightFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string region_id = 4;
  void clear_region_id();
  const std::string& region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* region_id);
  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(const std::string& value);
  std::string* _internal_mutable_region_id();
  public:

  // int32 fork_lift_height = 3;
  void clear_fork_lift_height();
  int32_t fork_lift_height() const;
  void set_fork_lift_height(int32_t value);
  private:
  int32_t _internal_fork_lift_height() const;
  void _internal_set_fork_lift_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.Area)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
    int32_t fork_lift_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_Path final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.Path) */ {
 public:
  inline ISeeMap_Path() : ISeeMap_Path(nullptr) {}
  ~ISeeMap_Path() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_Path(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_Path(const ISeeMap_Path& from);
  ISeeMap_Path(ISeeMap_Path&& from) noexcept
    : ISeeMap_Path() {
    *this = ::std::move(from);
  }

  inline ISeeMap_Path& operator=(const ISeeMap_Path& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_Path& operator=(ISeeMap_Path&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_Path& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_Path* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_Path*>(
               &_ISeeMap_Path_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ISeeMap_Path& a, ISeeMap_Path& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_Path* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_Path* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_Path* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_Path>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_Path& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_Path& from) {
    ISeeMap_Path::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_Path* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.Path";
  }
  protected:
  explicit ISeeMap_Path(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kFromStationRfidFieldNumber = 2,
    kToStationRfidFieldNumber = 3,
    kFlagFieldNumber = 21,
    kLmdateFieldNumber = 22,
    kRegionIdFieldNumber = 23,
    kTransitActionFieldNumber = 24,
    kEnterActionFieldNumber = 25,
    kExitActionFieldNumber = 26,
    kCarTypeFieldNumber = 28,
    kGoalsAngleFieldNumber = 4,
    kGoalsHeightFieldNumber = 5,
    kAngleCompensateFieldNumber = 6,
    kLaserHeadHeightFieldNumber = 7,
    kUncertaintyFieldNumber = 8,
    kMusicFieldNumber = 9,
    kDedectZone1FieldNumber = 10,
    kDedectZone2FieldNumber = 11,
    kVelocityMaxFieldNumber = 12,
    kRadiusFieldNumber = 13,
    kDestinationRangeFieldNumber = 14,
    kDistanceZoneInterchangeFieldNumber = 15,
    kIsRunningFieldNumber = 16,
    kHeightStepFieldNumber = 17,
    kCargoFieldNumber = 18,
    kDrivingDirectionFieldNumber = 19,
    kDistanceFieldNumber = 20,
    kAllowAutoAvoidFieldNumber = 27,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string from_station_rfid = 2;
  void clear_from_station_rfid();
  const std::string& from_station_rfid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from_station_rfid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from_station_rfid();
  PROTOBUF_NODISCARD std::string* release_from_station_rfid();
  void set_allocated_from_station_rfid(std::string* from_station_rfid);
  private:
  const std::string& _internal_from_station_rfid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_station_rfid(const std::string& value);
  std::string* _internal_mutable_from_station_rfid();
  public:

  // string to_station_rfid = 3;
  void clear_to_station_rfid();
  const std::string& to_station_rfid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_to_station_rfid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_to_station_rfid();
  PROTOBUF_NODISCARD std::string* release_to_station_rfid();
  void set_allocated_to_station_rfid(std::string* to_station_rfid);
  private:
  const std::string& _internal_to_station_rfid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_to_station_rfid(const std::string& value);
  std::string* _internal_mutable_to_station_rfid();
  public:

  // string flag = 21;
  void clear_flag();
  const std::string& flag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flag();
  PROTOBUF_NODISCARD std::string* release_flag();
  void set_allocated_flag(std::string* flag);
  private:
  const std::string& _internal_flag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flag(const std::string& value);
  std::string* _internal_mutable_flag();
  public:

  // string lmdate = 22;
  void clear_lmdate();
  const std::string& lmdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmdate();
  PROTOBUF_NODISCARD std::string* release_lmdate();
  void set_allocated_lmdate(std::string* lmdate);
  private:
  const std::string& _internal_lmdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmdate(const std::string& value);
  std::string* _internal_mutable_lmdate();
  public:

  // string region_id = 23;
  void clear_region_id();
  const std::string& region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* region_id);
  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(const std::string& value);
  std::string* _internal_mutable_region_id();
  public:

  // string transit_action = 24;
  void clear_transit_action();
  const std::string& transit_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transit_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transit_action();
  PROTOBUF_NODISCARD std::string* release_transit_action();
  void set_allocated_transit_action(std::string* transit_action);
  private:
  const std::string& _internal_transit_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transit_action(const std::string& value);
  std::string* _internal_mutable_transit_action();
  public:

  // string enter_action = 25;
  void clear_enter_action();
  const std::string& enter_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enter_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enter_action();
  PROTOBUF_NODISCARD std::string* release_enter_action();
  void set_allocated_enter_action(std::string* enter_action);
  private:
  const std::string& _internal_enter_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enter_action(const std::string& value);
  std::string* _internal_mutable_enter_action();
  public:

  // string exit_action = 26;
  void clear_exit_action();
  const std::string& exit_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exit_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exit_action();
  PROTOBUF_NODISCARD std::string* release_exit_action();
  void set_allocated_exit_action(std::string* exit_action);
  private:
  const std::string& _internal_exit_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exit_action(const std::string& value);
  std::string* _internal_mutable_exit_action();
  public:

  // string car_type = 28;
  void clear_car_type();
  const std::string& car_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_car_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_car_type();
  PROTOBUF_NODISCARD std::string* release_car_type();
  void set_allocated_car_type(std::string* car_type);
  private:
  const std::string& _internal_car_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_type(const std::string& value);
  std::string* _internal_mutable_car_type();
  public:

  // float goals_angle = 4;
  void clear_goals_angle();
  float goals_angle() const;
  void set_goals_angle(float value);
  private:
  float _internal_goals_angle() const;
  void _internal_set_goals_angle(float value);
  public:

  // float goals_height = 5;
  void clear_goals_height();
  float goals_height() const;
  void set_goals_height(float value);
  private:
  float _internal_goals_height() const;
  void _internal_set_goals_height(float value);
  public:

  // float angle_compensate = 6;
  void clear_angle_compensate();
  float angle_compensate() const;
  void set_angle_compensate(float value);
  private:
  float _internal_angle_compensate() const;
  void _internal_set_angle_compensate(float value);
  public:

  // float laser_head_height = 7;
  void clear_laser_head_height();
  float laser_head_height() const;
  void set_laser_head_height(float value);
  private:
  float _internal_laser_head_height() const;
  void _internal_set_laser_head_height(float value);
  public:

  // float uncertainty = 8;
  void clear_uncertainty();
  float uncertainty() const;
  void set_uncertainty(float value);
  private:
  float _internal_uncertainty() const;
  void _internal_set_uncertainty(float value);
  public:

  // int32 music = 9;
  void clear_music();
  int32_t music() const;
  void set_music(int32_t value);
  private:
  int32_t _internal_music() const;
  void _internal_set_music(int32_t value);
  public:

  // int32 dedect_zone1 = 10;
  void clear_dedect_zone1();
  int32_t dedect_zone1() const;
  void set_dedect_zone1(int32_t value);
  private:
  int32_t _internal_dedect_zone1() const;
  void _internal_set_dedect_zone1(int32_t value);
  public:

  // int32 dedect_zone2 = 11;
  void clear_dedect_zone2();
  int32_t dedect_zone2() const;
  void set_dedect_zone2(int32_t value);
  private:
  int32_t _internal_dedect_zone2() const;
  void _internal_set_dedect_zone2(int32_t value);
  public:

  // float velocity_max = 12;
  void clear_velocity_max();
  float velocity_max() const;
  void set_velocity_max(float value);
  private:
  float _internal_velocity_max() const;
  void _internal_set_velocity_max(float value);
  public:

  // float radius = 13;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float destination_range = 14;
  void clear_destination_range();
  float destination_range() const;
  void set_destination_range(float value);
  private:
  float _internal_destination_range() const;
  void _internal_set_destination_range(float value);
  public:

  // float distance_zone_interchange = 15;
  void clear_distance_zone_interchange();
  float distance_zone_interchange() const;
  void set_distance_zone_interchange(float value);
  private:
  float _internal_distance_zone_interchange() const;
  void _internal_set_distance_zone_interchange(float value);
  public:

  // int32 is_running = 16;
  void clear_is_running();
  int32_t is_running() const;
  void set_is_running(int32_t value);
  private:
  int32_t _internal_is_running() const;
  void _internal_set_is_running(int32_t value);
  public:

  // int32 height_step = 17;
  void clear_height_step();
  int32_t height_step() const;
  void set_height_step(int32_t value);
  private:
  int32_t _internal_height_step() const;
  void _internal_set_height_step(int32_t value);
  public:

  // int32 cargo = 18;
  void clear_cargo();
  int32_t cargo() const;
  void set_cargo(int32_t value);
  private:
  int32_t _internal_cargo() const;
  void _internal_set_cargo(int32_t value);
  public:

  // int32 driving_direction = 19;
  void clear_driving_direction();
  int32_t driving_direction() const;
  void set_driving_direction(int32_t value);
  private:
  int32_t _internal_driving_direction() const;
  void _internal_set_driving_direction(int32_t value);
  public:

  // float distance = 20;
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // bool allow_auto_avoid = 27;
  void clear_allow_auto_avoid();
  bool allow_auto_avoid() const;
  void set_allow_auto_avoid(bool value);
  private:
  bool _internal_allow_auto_avoid() const;
  void _internal_set_allow_auto_avoid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.Path)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_station_rfid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_station_rfid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transit_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enter_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exit_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_type_;
    float goals_angle_;
    float goals_height_;
    float angle_compensate_;
    float laser_head_height_;
    float uncertainty_;
    int32_t music_;
    int32_t dedect_zone1_;
    int32_t dedect_zone2_;
    float velocity_max_;
    float radius_;
    float destination_range_;
    float distance_zone_interchange_;
    int32_t is_running_;
    int32_t height_step_;
    int32_t cargo_;
    int32_t driving_direction_;
    float distance_;
    bool allow_auto_avoid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_Station final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.Station) */ {
 public:
  inline ISeeMap_Station() : ISeeMap_Station(nullptr) {}
  ~ISeeMap_Station() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_Station(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_Station(const ISeeMap_Station& from);
  ISeeMap_Station(ISeeMap_Station&& from) noexcept
    : ISeeMap_Station() {
    *this = ::std::move(from);
  }

  inline ISeeMap_Station& operator=(const ISeeMap_Station& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_Station& operator=(ISeeMap_Station&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_Station& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_Station* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_Station*>(
               &_ISeeMap_Station_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ISeeMap_Station& a, ISeeMap_Station& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_Station* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_Station* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_Station* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_Station>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_Station& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_Station& from) {
    ISeeMap_Station::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_Station* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.Station";
  }
  protected:
  explicit ISeeMap_Station(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStationRfidFieldNumber = 2,
    kStationNameFieldNumber = 3,
    kStationTypeFieldNumber = 4,
    kRelatedIdFieldNumber = 8,
    kFlagFieldNumber = 9,
    kLmdateFieldNumber = 10,
    kRegionIdFieldNumber = 11,
    kSpaceXFieldNumber = 5,
    kSpaceYFieldNumber = 6,
    kZAxisFieldNumber = 7,
    kQRIdFieldNumber = 12,
    kQRAngleFieldNumber = 13,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string station_rfid = 2;
  void clear_station_rfid();
  const std::string& station_rfid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_rfid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_rfid();
  PROTOBUF_NODISCARD std::string* release_station_rfid();
  void set_allocated_station_rfid(std::string* station_rfid);
  private:
  const std::string& _internal_station_rfid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_rfid(const std::string& value);
  std::string* _internal_mutable_station_rfid();
  public:

  // string station_name = 3;
  void clear_station_name();
  const std::string& station_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_name();
  PROTOBUF_NODISCARD std::string* release_station_name();
  void set_allocated_station_name(std::string* station_name);
  private:
  const std::string& _internal_station_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_name(const std::string& value);
  std::string* _internal_mutable_station_name();
  public:

  // string station_type = 4;
  void clear_station_type();
  const std::string& station_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_type();
  PROTOBUF_NODISCARD std::string* release_station_type();
  void set_allocated_station_type(std::string* station_type);
  private:
  const std::string& _internal_station_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_type(const std::string& value);
  std::string* _internal_mutable_station_type();
  public:

  // string related_id = 8;
  void clear_related_id();
  const std::string& related_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_related_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_related_id();
  PROTOBUF_NODISCARD std::string* release_related_id();
  void set_allocated_related_id(std::string* related_id);
  private:
  const std::string& _internal_related_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_related_id(const std::string& value);
  std::string* _internal_mutable_related_id();
  public:

  // string flag = 9;
  void clear_flag();
  const std::string& flag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flag();
  PROTOBUF_NODISCARD std::string* release_flag();
  void set_allocated_flag(std::string* flag);
  private:
  const std::string& _internal_flag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flag(const std::string& value);
  std::string* _internal_mutable_flag();
  public:

  // string lmdate = 10;
  void clear_lmdate();
  const std::string& lmdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmdate();
  PROTOBUF_NODISCARD std::string* release_lmdate();
  void set_allocated_lmdate(std::string* lmdate);
  private:
  const std::string& _internal_lmdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmdate(const std::string& value);
  std::string* _internal_mutable_lmdate();
  public:

  // string region_id = 11;
  void clear_region_id();
  const std::string& region_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region_id();
  PROTOBUF_NODISCARD std::string* release_region_id();
  void set_allocated_region_id(std::string* region_id);
  private:
  const std::string& _internal_region_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region_id(const std::string& value);
  std::string* _internal_mutable_region_id();
  public:

  // float space_x = 5;
  void clear_space_x();
  float space_x() const;
  void set_space_x(float value);
  private:
  float _internal_space_x() const;
  void _internal_set_space_x(float value);
  public:

  // float space_y = 6;
  void clear_space_y();
  float space_y() const;
  void set_space_y(float value);
  private:
  float _internal_space_y() const;
  void _internal_set_space_y(float value);
  public:

  // float z_axis = 7;
  void clear_z_axis();
  float z_axis() const;
  void set_z_axis(float value);
  private:
  float _internal_z_axis() const;
  void _internal_set_z_axis(float value);
  public:

  // uint32 QR_id = 12;
  void clear_qr_id();
  uint32_t qr_id() const;
  void set_qr_id(uint32_t value);
  private:
  uint32_t _internal_qr_id() const;
  void _internal_set_qr_id(uint32_t value);
  public:

  // float QR_angle = 13;
  void clear_qr_angle();
  float qr_angle() const;
  void set_qr_angle(float value);
  private:
  float _internal_qr_angle() const;
  void _internal_set_qr_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.Station)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_rfid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr related_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flag_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmdate_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_id_;
    float space_x_;
    float space_y_;
    float z_axis_;
    uint32_t qr_id_;
    float qr_angle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_Configuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.Configuration) */ {
 public:
  inline ISeeMap_Configuration() : ISeeMap_Configuration(nullptr) {}
  ~ISeeMap_Configuration() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_Configuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_Configuration(const ISeeMap_Configuration& from);
  ISeeMap_Configuration(ISeeMap_Configuration&& from) noexcept
    : ISeeMap_Configuration() {
    *this = ::std::move(from);
  }

  inline ISeeMap_Configuration& operator=(const ISeeMap_Configuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_Configuration& operator=(ISeeMap_Configuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_Configuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_Configuration* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_Configuration*>(
               &_ISeeMap_Configuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ISeeMap_Configuration& a, ISeeMap_Configuration& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_Configuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_Configuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_Configuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_Configuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_Configuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_Configuration& from) {
    ISeeMap_Configuration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_Configuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.Configuration";
  }
  protected:
  explicit ISeeMap_Configuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAreaNameFieldNumber = 1,
    kTaskTypeFieldNumber = 2,
    kSectionFieldNumber = 3,
    kLaserHeadHeightFieldNumber = 4,
    kDedectZone1FieldNumber = 5,
    kDedectZone2FieldNumber = 6,
    kDistanceZoneInterchangeFieldNumber = 7,
    kDestinationRangeFieldNumber = 8,
    kHeightStepFieldNumber = 9,
    kCargoFieldNumber = 10,
  };
  // string area_name = 1;
  void clear_area_name();
  const std::string& area_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_area_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_area_name();
  PROTOBUF_NODISCARD std::string* release_area_name();
  void set_allocated_area_name(std::string* area_name);
  private:
  const std::string& _internal_area_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_area_name(const std::string& value);
  std::string* _internal_mutable_area_name();
  public:

  // string task_type = 2;
  void clear_task_type();
  const std::string& task_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_task_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_task_type();
  PROTOBUF_NODISCARD std::string* release_task_type();
  void set_allocated_task_type(std::string* task_type);
  private:
  const std::string& _internal_task_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_task_type(const std::string& value);
  std::string* _internal_mutable_task_type();
  public:

  // int32 section = 3;
  void clear_section();
  int32_t section() const;
  void set_section(int32_t value);
  private:
  int32_t _internal_section() const;
  void _internal_set_section(int32_t value);
  public:

  // int32 laser_head_height = 4;
  void clear_laser_head_height();
  int32_t laser_head_height() const;
  void set_laser_head_height(int32_t value);
  private:
  int32_t _internal_laser_head_height() const;
  void _internal_set_laser_head_height(int32_t value);
  public:

  // int32 dedect_zone1 = 5;
  void clear_dedect_zone1();
  int32_t dedect_zone1() const;
  void set_dedect_zone1(int32_t value);
  private:
  int32_t _internal_dedect_zone1() const;
  void _internal_set_dedect_zone1(int32_t value);
  public:

  // int32 dedect_zone2 = 6;
  void clear_dedect_zone2();
  int32_t dedect_zone2() const;
  void set_dedect_zone2(int32_t value);
  private:
  int32_t _internal_dedect_zone2() const;
  void _internal_set_dedect_zone2(int32_t value);
  public:

  // int32 distance_zone_interchange = 7;
  void clear_distance_zone_interchange();
  int32_t distance_zone_interchange() const;
  void set_distance_zone_interchange(int32_t value);
  private:
  int32_t _internal_distance_zone_interchange() const;
  void _internal_set_distance_zone_interchange(int32_t value);
  public:

  // int32 destination_range = 8;
  void clear_destination_range();
  int32_t destination_range() const;
  void set_destination_range(int32_t value);
  private:
  int32_t _internal_destination_range() const;
  void _internal_set_destination_range(int32_t value);
  public:

  // int32 height_step = 9;
  void clear_height_step();
  int32_t height_step() const;
  void set_height_step(int32_t value);
  private:
  int32_t _internal_height_step() const;
  void _internal_set_height_step(int32_t value);
  public:

  // int32 cargo = 10;
  void clear_cargo();
  int32_t cargo() const;
  void set_cargo(int32_t value);
  private:
  int32_t _internal_cargo() const;
  void _internal_set_cargo(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.Configuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr area_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr task_type_;
    int32_t section_;
    int32_t laser_head_height_;
    int32_t dedect_zone1_;
    int32_t dedect_zone2_;
    int32_t distance_zone_interchange_;
    int32_t destination_range_;
    int32_t height_step_;
    int32_t cargo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_TaskAction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.TaskAction) */ {
 public:
  inline ISeeMap_TaskAction() : ISeeMap_TaskAction(nullptr) {}
  ~ISeeMap_TaskAction() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_TaskAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_TaskAction(const ISeeMap_TaskAction& from);
  ISeeMap_TaskAction(ISeeMap_TaskAction&& from) noexcept
    : ISeeMap_TaskAction() {
    *this = ::std::move(from);
  }

  inline ISeeMap_TaskAction& operator=(const ISeeMap_TaskAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_TaskAction& operator=(ISeeMap_TaskAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_TaskAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_TaskAction* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_TaskAction*>(
               &_ISeeMap_TaskAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ISeeMap_TaskAction& a, ISeeMap_TaskAction& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_TaskAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_TaskAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_TaskAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_TaskAction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_TaskAction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_TaskAction& from) {
    ISeeMap_TaskAction::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_TaskAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.TaskAction";
  }
  protected:
  explicit ISeeMap_TaskAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionNameFieldNumber = 1,
    kEnterActionFieldNumber = 2,
    kExitActionFieldNumber = 3,
  };
  // bytes action_name = 1;
  void clear_action_name();
  const std::string& action_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_name();
  PROTOBUF_NODISCARD std::string* release_action_name();
  void set_allocated_action_name(std::string* action_name);
  private:
  const std::string& _internal_action_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_name(const std::string& value);
  std::string* _internal_mutable_action_name();
  public:

  // string enter_action = 2;
  void clear_enter_action();
  const std::string& enter_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_enter_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_enter_action();
  PROTOBUF_NODISCARD std::string* release_enter_action();
  void set_allocated_enter_action(std::string* enter_action);
  private:
  const std::string& _internal_enter_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enter_action(const std::string& value);
  std::string* _internal_mutable_enter_action();
  public:

  // string exit_action = 3;
  void clear_exit_action();
  const std::string& exit_action() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exit_action(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exit_action();
  PROTOBUF_NODISCARD std::string* release_exit_action();
  void set_allocated_exit_action(std::string* exit_action);
  private:
  const std::string& _internal_exit_action() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exit_action(const std::string& value);
  std::string* _internal_mutable_exit_action();
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.TaskAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enter_action_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exit_action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_CarManagemet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.CarManagemet) */ {
 public:
  inline ISeeMap_CarManagemet() : ISeeMap_CarManagemet(nullptr) {}
  ~ISeeMap_CarManagemet() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_CarManagemet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_CarManagemet(const ISeeMap_CarManagemet& from);
  ISeeMap_CarManagemet(ISeeMap_CarManagemet&& from) noexcept
    : ISeeMap_CarManagemet() {
    *this = ::std::move(from);
  }

  inline ISeeMap_CarManagemet& operator=(const ISeeMap_CarManagemet& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_CarManagemet& operator=(ISeeMap_CarManagemet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_CarManagemet& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_CarManagemet* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_CarManagemet*>(
               &_ISeeMap_CarManagemet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ISeeMap_CarManagemet& a, ISeeMap_CarManagemet& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_CarManagemet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_CarManagemet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_CarManagemet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_CarManagemet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_CarManagemet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_CarManagemet& from) {
    ISeeMap_CarManagemet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_CarManagemet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.CarManagemet";
  }
  protected:
  explicit ISeeMap_CarManagemet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kMacFieldNumber = 4,
    kIpFieldNumber = 5,
    kCarTypeFieldNumber = 6,
    kBatteryFieldNumber = 7,
    kValidFieldNumber = 14,
    kLmuserFieldNumber = 15,
    kLmdateFieldNumber = 16,
    kRatedLoadFieldNumber = 8,
    kNumberFieldNumber = 3,
    kRunTimeFieldNumber = 13,
    kLengthFieldNumber = 9,
    kWidthFieldNumber = 10,
    kMarginFieldNumber = 11,
    kReferencePointFieldNumber = 12,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string mac = 4;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // string ip = 5;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // bytes car_type = 6;
  void clear_car_type();
  const std::string& car_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_car_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_car_type();
  PROTOBUF_NODISCARD std::string* release_car_type();
  void set_allocated_car_type(std::string* car_type);
  private:
  const std::string& _internal_car_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_car_type(const std::string& value);
  std::string* _internal_mutable_car_type();
  public:

  // string battery = 7;
  void clear_battery();
  const std::string& battery() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_battery(ArgT0&& arg0, ArgT... args);
  std::string* mutable_battery();
  PROTOBUF_NODISCARD std::string* release_battery();
  void set_allocated_battery(std::string* battery);
  private:
  const std::string& _internal_battery() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_battery(const std::string& value);
  std::string* _internal_mutable_battery();
  public:

  // string valid = 14;
  void clear_valid();
  const std::string& valid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_valid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_valid();
  PROTOBUF_NODISCARD std::string* release_valid();
  void set_allocated_valid(std::string* valid);
  private:
  const std::string& _internal_valid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_valid(const std::string& value);
  std::string* _internal_mutable_valid();
  public:

  // string lmuser = 15;
  void clear_lmuser();
  const std::string& lmuser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmuser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmuser();
  PROTOBUF_NODISCARD std::string* release_lmuser();
  void set_allocated_lmuser(std::string* lmuser);
  private:
  const std::string& _internal_lmuser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmuser(const std::string& value);
  std::string* _internal_mutable_lmuser();
  public:

  // string lmdate = 16;
  void clear_lmdate();
  const std::string& lmdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lmdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lmdate();
  PROTOBUF_NODISCARD std::string* release_lmdate();
  void set_allocated_lmdate(std::string* lmdate);
  private:
  const std::string& _internal_lmdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lmdate(const std::string& value);
  std::string* _internal_mutable_lmdate();
  public:

  // double rated_load = 8;
  void clear_rated_load();
  double rated_load() const;
  void set_rated_load(double value);
  private:
  double _internal_rated_load() const;
  void _internal_set_rated_load(double value);
  public:

  // int32 number = 3;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // int32 run_time = 13;
  void clear_run_time();
  int32_t run_time() const;
  void set_run_time(int32_t value);
  private:
  int32_t _internal_run_time() const;
  void _internal_set_run_time(int32_t value);
  public:

  // double length = 9;
  void clear_length();
  double length() const;
  void set_length(double value);
  private:
  double _internal_length() const;
  void _internal_set_length(double value);
  public:

  // double width = 10;
  void clear_width();
  double width() const;
  void set_width(double value);
  private:
  double _internal_width() const;
  void _internal_set_width(double value);
  public:

  // double margin = 11;
  void clear_margin();
  double margin() const;
  void set_margin(double value);
  private:
  double _internal_margin() const;
  void _internal_set_margin(double value);
  public:

  // double reference_point = 12;
  void clear_reference_point();
  double reference_point() const;
  void set_reference_point(double value);
  private:
  double _internal_reference_point() const;
  void _internal_set_reference_point(double value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.CarManagemet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr car_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battery_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr valid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmuser_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lmdate_;
    double rated_load_;
    int32_t number_;
    int32_t run_time_;
    double length_;
    double width_;
    double margin_;
    double reference_point_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap_CoordOffset final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap.CoordOffset) */ {
 public:
  inline ISeeMap_CoordOffset() : ISeeMap_CoordOffset(nullptr) {}
  ~ISeeMap_CoordOffset() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap_CoordOffset(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap_CoordOffset(const ISeeMap_CoordOffset& from);
  ISeeMap_CoordOffset(ISeeMap_CoordOffset&& from) noexcept
    : ISeeMap_CoordOffset() {
    *this = ::std::move(from);
  }

  inline ISeeMap_CoordOffset& operator=(const ISeeMap_CoordOffset& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap_CoordOffset& operator=(ISeeMap_CoordOffset&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap_CoordOffset& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap_CoordOffset* internal_default_instance() {
    return reinterpret_cast<const ISeeMap_CoordOffset*>(
               &_ISeeMap_CoordOffset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ISeeMap_CoordOffset& a, ISeeMap_CoordOffset& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap_CoordOffset* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap_CoordOffset* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap_CoordOffset* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap_CoordOffset>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap_CoordOffset& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap_CoordOffset& from) {
    ISeeMap_CoordOffset::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap_CoordOffset* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap.CoordOffset";
  }
  protected:
  explicit ISeeMap_CoordOffset(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationNameFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
  };
  // string station_name = 1;
  void clear_station_name();
  const std::string& station_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_station_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_station_name();
  PROTOBUF_NODISCARD std::string* release_station_name();
  void set_allocated_station_name(std::string* station_name);
  private:
  const std::string& _internal_station_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_station_name(const std::string& value);
  std::string* _internal_mutable_station_name();
  public:

  // float x = 2;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 3;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:ISeeMap.CoordOffset)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr station_name_;
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// -------------------------------------------------------------------

class ISeeMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ISeeMap) */ {
 public:
  inline ISeeMap() : ISeeMap(nullptr) {}
  ~ISeeMap() override;
  explicit PROTOBUF_CONSTEXPR ISeeMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ISeeMap(const ISeeMap& from);
  ISeeMap(ISeeMap&& from) noexcept
    : ISeeMap() {
    *this = ::std::move(from);
  }

  inline ISeeMap& operator=(const ISeeMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ISeeMap& operator=(ISeeMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ISeeMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ISeeMap* internal_default_instance() {
    return reinterpret_cast<const ISeeMap*>(
               &_ISeeMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ISeeMap& a, ISeeMap& b) {
    a.Swap(&b);
  }
  inline void Swap(ISeeMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ISeeMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ISeeMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ISeeMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ISeeMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ISeeMap& from) {
    ISeeMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ISeeMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ISeeMap";
  }
  protected:
  explicit ISeeMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ISeeMap_Region Region;
  typedef ISeeMap_Area Area;
  typedef ISeeMap_Path Path;
  typedef ISeeMap_Station Station;
  typedef ISeeMap_Configuration Configuration;
  typedef ISeeMap_TaskAction TaskAction;
  typedef ISeeMap_CarManagemet CarManagemet;
  typedef ISeeMap_CoordOffset CoordOffset;

  // accessors -------------------------------------------------------

  enum : int {
    kAreaListFieldNumber = 2,
    kPathListFieldNumber = 3,
    kStationListFieldNumber = 4,
    kConfigurationListFieldNumber = 5,
    kTaskActionListFieldNumber = 6,
    kCarMngListFieldNumber = 7,
    kCoordOffsetFieldNumber = 8,
    kRegionFieldNumber = 1,
  };
  // repeated .ISeeMap.Area areaList = 2;
  int arealist_size() const;
  private:
  int _internal_arealist_size() const;
  public:
  void clear_arealist();
  ::ISeeMap_Area* mutable_arealist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Area >*
      mutable_arealist();
  private:
  const ::ISeeMap_Area& _internal_arealist(int index) const;
  ::ISeeMap_Area* _internal_add_arealist();
  public:
  const ::ISeeMap_Area& arealist(int index) const;
  ::ISeeMap_Area* add_arealist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Area >&
      arealist() const;

  // repeated .ISeeMap.Path pathList = 3;
  int pathlist_size() const;
  private:
  int _internal_pathlist_size() const;
  public:
  void clear_pathlist();
  ::ISeeMap_Path* mutable_pathlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Path >*
      mutable_pathlist();
  private:
  const ::ISeeMap_Path& _internal_pathlist(int index) const;
  ::ISeeMap_Path* _internal_add_pathlist();
  public:
  const ::ISeeMap_Path& pathlist(int index) const;
  ::ISeeMap_Path* add_pathlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Path >&
      pathlist() const;

  // repeated .ISeeMap.Station stationList = 4;
  int stationlist_size() const;
  private:
  int _internal_stationlist_size() const;
  public:
  void clear_stationlist();
  ::ISeeMap_Station* mutable_stationlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Station >*
      mutable_stationlist();
  private:
  const ::ISeeMap_Station& _internal_stationlist(int index) const;
  ::ISeeMap_Station* _internal_add_stationlist();
  public:
  const ::ISeeMap_Station& stationlist(int index) const;
  ::ISeeMap_Station* add_stationlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Station >&
      stationlist() const;

  // repeated .ISeeMap.Configuration configurationList = 5;
  int configurationlist_size() const;
  private:
  int _internal_configurationlist_size() const;
  public:
  void clear_configurationlist();
  ::ISeeMap_Configuration* mutable_configurationlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Configuration >*
      mutable_configurationlist();
  private:
  const ::ISeeMap_Configuration& _internal_configurationlist(int index) const;
  ::ISeeMap_Configuration* _internal_add_configurationlist();
  public:
  const ::ISeeMap_Configuration& configurationlist(int index) const;
  ::ISeeMap_Configuration* add_configurationlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Configuration >&
      configurationlist() const;

  // repeated .ISeeMap.TaskAction taskActionList = 6;
  int taskactionlist_size() const;
  private:
  int _internal_taskactionlist_size() const;
  public:
  void clear_taskactionlist();
  ::ISeeMap_TaskAction* mutable_taskactionlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_TaskAction >*
      mutable_taskactionlist();
  private:
  const ::ISeeMap_TaskAction& _internal_taskactionlist(int index) const;
  ::ISeeMap_TaskAction* _internal_add_taskactionlist();
  public:
  const ::ISeeMap_TaskAction& taskactionlist(int index) const;
  ::ISeeMap_TaskAction* add_taskactionlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_TaskAction >&
      taskactionlist() const;

  // repeated .ISeeMap.CarManagemet carMngList = 7;
  int carmnglist_size() const;
  private:
  int _internal_carmnglist_size() const;
  public:
  void clear_carmnglist();
  ::ISeeMap_CarManagemet* mutable_carmnglist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CarManagemet >*
      mutable_carmnglist();
  private:
  const ::ISeeMap_CarManagemet& _internal_carmnglist(int index) const;
  ::ISeeMap_CarManagemet* _internal_add_carmnglist();
  public:
  const ::ISeeMap_CarManagemet& carmnglist(int index) const;
  ::ISeeMap_CarManagemet* add_carmnglist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CarManagemet >&
      carmnglist() const;

  // repeated .ISeeMap.CoordOffset coordOffset = 8;
  int coordoffset_size() const;
  private:
  int _internal_coordoffset_size() const;
  public:
  void clear_coordoffset();
  ::ISeeMap_CoordOffset* mutable_coordoffset(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CoordOffset >*
      mutable_coordoffset();
  private:
  const ::ISeeMap_CoordOffset& _internal_coordoffset(int index) const;
  ::ISeeMap_CoordOffset* _internal_add_coordoffset();
  public:
  const ::ISeeMap_CoordOffset& coordoffset(int index) const;
  ::ISeeMap_CoordOffset* add_coordoffset();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CoordOffset >&
      coordoffset() const;

  // .ISeeMap.Region region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::ISeeMap_Region& region() const;
  PROTOBUF_NODISCARD ::ISeeMap_Region* release_region();
  ::ISeeMap_Region* mutable_region();
  void set_allocated_region(::ISeeMap_Region* region);
  private:
  const ::ISeeMap_Region& _internal_region() const;
  ::ISeeMap_Region* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::ISeeMap_Region* region);
  ::ISeeMap_Region* unsafe_arena_release_region();

  // @@protoc_insertion_point(class_scope:ISeeMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Area > arealist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Path > pathlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Station > stationlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Configuration > configurationlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_TaskAction > taskactionlist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CarManagemet > carmnglist_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CoordOffset > coordoffset_;
    ::ISeeMap_Region* region_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2ddb_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ISeeMap_Region

// string id = 1;
inline void ISeeMap_Region::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.id)
}
inline std::string* ISeeMap_Region::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.id)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ISeeMap_Region::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.id)
  return _impl_.id_.Release();
}
inline void ISeeMap_Region::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.id)
}

// bytes description = 2;
inline void ISeeMap_Region::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::description() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.description)
}
inline std::string* ISeeMap_Region::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.description)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_description() const {
  return _impl_.description_.Get();
}
inline void ISeeMap_Region::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_description() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.description)
  return _impl_.description_.Release();
}
inline void ISeeMap_Region::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.description)
}

// bytes name = 3;
inline void ISeeMap_Region::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.name)
}
inline std::string* ISeeMap_Region::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.name)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ISeeMap_Region::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.name)
  return _impl_.name_.Release();
}
inline void ISeeMap_Region::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.name)
}

// int32 floor_number = 4;
inline void ISeeMap_Region::clear_floor_number() {
  _impl_.floor_number_ = 0;
}
inline int32_t ISeeMap_Region::_internal_floor_number() const {
  return _impl_.floor_number_;
}
inline int32_t ISeeMap_Region::floor_number() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.floor_number)
  return _internal_floor_number();
}
inline void ISeeMap_Region::_internal_set_floor_number(int32_t value) {
  
  _impl_.floor_number_ = value;
}
inline void ISeeMap_Region::set_floor_number(int32_t value) {
  _internal_set_floor_number(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Region.floor_number)
}

// string valid = 5;
inline void ISeeMap_Region::clear_valid() {
  _impl_.valid_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::valid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.valid)
  return _internal_valid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_valid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.valid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.valid)
}
inline std::string* ISeeMap_Region::mutable_valid() {
  std::string* _s = _internal_mutable_valid();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.valid)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_valid() const {
  return _impl_.valid_.Get();
}
inline void ISeeMap_Region::_internal_set_valid(const std::string& value) {
  
  _impl_.valid_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_valid() {
  
  return _impl_.valid_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_valid() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.valid)
  return _impl_.valid_.Release();
}
inline void ISeeMap_Region::set_allocated_valid(std::string* valid) {
  if (valid != nullptr) {
    
  } else {
    
  }
  _impl_.valid_.SetAllocated(valid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valid_.IsDefault()) {
    _impl_.valid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.valid)
}

// bytes lmuser = 6;
inline void ISeeMap_Region::clear_lmuser() {
  _impl_.lmuser_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::lmuser() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.lmuser)
  return _internal_lmuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_lmuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmuser_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.lmuser)
}
inline std::string* ISeeMap_Region::mutable_lmuser() {
  std::string* _s = _internal_mutable_lmuser();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.lmuser)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_lmuser() const {
  return _impl_.lmuser_.Get();
}
inline void ISeeMap_Region::_internal_set_lmuser(const std::string& value) {
  
  _impl_.lmuser_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_lmuser() {
  
  return _impl_.lmuser_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_lmuser() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.lmuser)
  return _impl_.lmuser_.Release();
}
inline void ISeeMap_Region::set_allocated_lmuser(std::string* lmuser) {
  if (lmuser != nullptr) {
    
  } else {
    
  }
  _impl_.lmuser_.SetAllocated(lmuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmuser_.IsDefault()) {
    _impl_.lmuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.lmuser)
}

// bytes mapVersion = 7;
inline void ISeeMap_Region::clear_mapversion() {
  _impl_.mapversion_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::mapversion() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.mapVersion)
  return _internal_mapversion();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_mapversion(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mapversion_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.mapVersion)
}
inline std::string* ISeeMap_Region::mutable_mapversion() {
  std::string* _s = _internal_mutable_mapversion();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.mapVersion)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_mapversion() const {
  return _impl_.mapversion_.Get();
}
inline void ISeeMap_Region::_internal_set_mapversion(const std::string& value) {
  
  _impl_.mapversion_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_mapversion() {
  
  return _impl_.mapversion_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_mapversion() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.mapVersion)
  return _impl_.mapversion_.Release();
}
inline void ISeeMap_Region::set_allocated_mapversion(std::string* mapversion) {
  if (mapversion != nullptr) {
    
  } else {
    
  }
  _impl_.mapversion_.SetAllocated(mapversion, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mapversion_.IsDefault()) {
    _impl_.mapversion_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.mapVersion)
}

// string lmdate = 8;
inline void ISeeMap_Region::clear_lmdate() {
  _impl_.lmdate_.ClearToEmpty();
}
inline const std::string& ISeeMap_Region::lmdate() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Region.lmdate)
  return _internal_lmdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Region::set_lmdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Region.lmdate)
}
inline std::string* ISeeMap_Region::mutable_lmdate() {
  std::string* _s = _internal_mutable_lmdate();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Region.lmdate)
  return _s;
}
inline const std::string& ISeeMap_Region::_internal_lmdate() const {
  return _impl_.lmdate_.Get();
}
inline void ISeeMap_Region::_internal_set_lmdate(const std::string& value) {
  
  _impl_.lmdate_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::_internal_mutable_lmdate() {
  
  return _impl_.lmdate_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Region::release_lmdate() {
  // @@protoc_insertion_point(field_release:ISeeMap.Region.lmdate)
  return _impl_.lmdate_.Release();
}
inline void ISeeMap_Region::set_allocated_lmdate(std::string* lmdate) {
  if (lmdate != nullptr) {
    
  } else {
    
  }
  _impl_.lmdate_.SetAllocated(lmdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmdate_.IsDefault()) {
    _impl_.lmdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Region.lmdate)
}

// -------------------------------------------------------------------

// ISeeMap_Area

// string id = 1;
inline void ISeeMap_Area::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Area::id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Area.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Area::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Area.id)
}
inline std::string* ISeeMap_Area::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Area.id)
  return _s;
}
inline const std::string& ISeeMap_Area::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ISeeMap_Area::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::release_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Area.id)
  return _impl_.id_.Release();
}
inline void ISeeMap_Area::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Area.id)
}

// string name = 2;
inline void ISeeMap_Area::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ISeeMap_Area::name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Area.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Area::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Area.name)
}
inline std::string* ISeeMap_Area::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Area.name)
  return _s;
}
inline const std::string& ISeeMap_Area::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ISeeMap_Area::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::release_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.Area.name)
  return _impl_.name_.Release();
}
inline void ISeeMap_Area::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Area.name)
}

// int32 fork_lift_height = 3;
inline void ISeeMap_Area::clear_fork_lift_height() {
  _impl_.fork_lift_height_ = 0;
}
inline int32_t ISeeMap_Area::_internal_fork_lift_height() const {
  return _impl_.fork_lift_height_;
}
inline int32_t ISeeMap_Area::fork_lift_height() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Area.fork_lift_height)
  return _internal_fork_lift_height();
}
inline void ISeeMap_Area::_internal_set_fork_lift_height(int32_t value) {
  
  _impl_.fork_lift_height_ = value;
}
inline void ISeeMap_Area::set_fork_lift_height(int32_t value) {
  _internal_set_fork_lift_height(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Area.fork_lift_height)
}

// string region_id = 4;
inline void ISeeMap_Area::clear_region_id() {
  _impl_.region_id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Area::region_id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Area.region_id)
  return _internal_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Area::set_region_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Area.region_id)
}
inline std::string* ISeeMap_Area::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Area.region_id)
  return _s;
}
inline const std::string& ISeeMap_Area::_internal_region_id() const {
  return _impl_.region_id_.Get();
}
inline void ISeeMap_Area::_internal_set_region_id(const std::string& value) {
  
  _impl_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::_internal_mutable_region_id() {
  
  return _impl_.region_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Area::release_region_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Area.region_id)
  return _impl_.region_id_.Release();
}
inline void ISeeMap_Area::set_allocated_region_id(std::string* region_id) {
  if (region_id != nullptr) {
    
  } else {
    
  }
  _impl_.region_id_.SetAllocated(region_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_id_.IsDefault()) {
    _impl_.region_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Area.region_id)
}

// -------------------------------------------------------------------

// ISeeMap_Path

// string id = 1;
inline void ISeeMap_Path::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.id)
}
inline std::string* ISeeMap_Path::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.id)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ISeeMap_Path::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.id)
  return _impl_.id_.Release();
}
inline void ISeeMap_Path::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.id)
}

// string from_station_rfid = 2;
inline void ISeeMap_Path::clear_from_station_rfid() {
  _impl_.from_station_rfid_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::from_station_rfid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.from_station_rfid)
  return _internal_from_station_rfid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_from_station_rfid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.from_station_rfid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.from_station_rfid)
}
inline std::string* ISeeMap_Path::mutable_from_station_rfid() {
  std::string* _s = _internal_mutable_from_station_rfid();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.from_station_rfid)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_from_station_rfid() const {
  return _impl_.from_station_rfid_.Get();
}
inline void ISeeMap_Path::_internal_set_from_station_rfid(const std::string& value) {
  
  _impl_.from_station_rfid_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_from_station_rfid() {
  
  return _impl_.from_station_rfid_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_from_station_rfid() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.from_station_rfid)
  return _impl_.from_station_rfid_.Release();
}
inline void ISeeMap_Path::set_allocated_from_station_rfid(std::string* from_station_rfid) {
  if (from_station_rfid != nullptr) {
    
  } else {
    
  }
  _impl_.from_station_rfid_.SetAllocated(from_station_rfid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.from_station_rfid_.IsDefault()) {
    _impl_.from_station_rfid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.from_station_rfid)
}

// string to_station_rfid = 3;
inline void ISeeMap_Path::clear_to_station_rfid() {
  _impl_.to_station_rfid_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::to_station_rfid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.to_station_rfid)
  return _internal_to_station_rfid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_to_station_rfid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.to_station_rfid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.to_station_rfid)
}
inline std::string* ISeeMap_Path::mutable_to_station_rfid() {
  std::string* _s = _internal_mutable_to_station_rfid();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.to_station_rfid)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_to_station_rfid() const {
  return _impl_.to_station_rfid_.Get();
}
inline void ISeeMap_Path::_internal_set_to_station_rfid(const std::string& value) {
  
  _impl_.to_station_rfid_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_to_station_rfid() {
  
  return _impl_.to_station_rfid_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_to_station_rfid() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.to_station_rfid)
  return _impl_.to_station_rfid_.Release();
}
inline void ISeeMap_Path::set_allocated_to_station_rfid(std::string* to_station_rfid) {
  if (to_station_rfid != nullptr) {
    
  } else {
    
  }
  _impl_.to_station_rfid_.SetAllocated(to_station_rfid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.to_station_rfid_.IsDefault()) {
    _impl_.to_station_rfid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.to_station_rfid)
}

// float goals_angle = 4;
inline void ISeeMap_Path::clear_goals_angle() {
  _impl_.goals_angle_ = 0;
}
inline float ISeeMap_Path::_internal_goals_angle() const {
  return _impl_.goals_angle_;
}
inline float ISeeMap_Path::goals_angle() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.goals_angle)
  return _internal_goals_angle();
}
inline void ISeeMap_Path::_internal_set_goals_angle(float value) {
  
  _impl_.goals_angle_ = value;
}
inline void ISeeMap_Path::set_goals_angle(float value) {
  _internal_set_goals_angle(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.goals_angle)
}

// float goals_height = 5;
inline void ISeeMap_Path::clear_goals_height() {
  _impl_.goals_height_ = 0;
}
inline float ISeeMap_Path::_internal_goals_height() const {
  return _impl_.goals_height_;
}
inline float ISeeMap_Path::goals_height() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.goals_height)
  return _internal_goals_height();
}
inline void ISeeMap_Path::_internal_set_goals_height(float value) {
  
  _impl_.goals_height_ = value;
}
inline void ISeeMap_Path::set_goals_height(float value) {
  _internal_set_goals_height(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.goals_height)
}

// float angle_compensate = 6;
inline void ISeeMap_Path::clear_angle_compensate() {
  _impl_.angle_compensate_ = 0;
}
inline float ISeeMap_Path::_internal_angle_compensate() const {
  return _impl_.angle_compensate_;
}
inline float ISeeMap_Path::angle_compensate() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.angle_compensate)
  return _internal_angle_compensate();
}
inline void ISeeMap_Path::_internal_set_angle_compensate(float value) {
  
  _impl_.angle_compensate_ = value;
}
inline void ISeeMap_Path::set_angle_compensate(float value) {
  _internal_set_angle_compensate(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.angle_compensate)
}

// float laser_head_height = 7;
inline void ISeeMap_Path::clear_laser_head_height() {
  _impl_.laser_head_height_ = 0;
}
inline float ISeeMap_Path::_internal_laser_head_height() const {
  return _impl_.laser_head_height_;
}
inline float ISeeMap_Path::laser_head_height() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.laser_head_height)
  return _internal_laser_head_height();
}
inline void ISeeMap_Path::_internal_set_laser_head_height(float value) {
  
  _impl_.laser_head_height_ = value;
}
inline void ISeeMap_Path::set_laser_head_height(float value) {
  _internal_set_laser_head_height(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.laser_head_height)
}

// float uncertainty = 8;
inline void ISeeMap_Path::clear_uncertainty() {
  _impl_.uncertainty_ = 0;
}
inline float ISeeMap_Path::_internal_uncertainty() const {
  return _impl_.uncertainty_;
}
inline float ISeeMap_Path::uncertainty() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.uncertainty)
  return _internal_uncertainty();
}
inline void ISeeMap_Path::_internal_set_uncertainty(float value) {
  
  _impl_.uncertainty_ = value;
}
inline void ISeeMap_Path::set_uncertainty(float value) {
  _internal_set_uncertainty(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.uncertainty)
}

// int32 music = 9;
inline void ISeeMap_Path::clear_music() {
  _impl_.music_ = 0;
}
inline int32_t ISeeMap_Path::_internal_music() const {
  return _impl_.music_;
}
inline int32_t ISeeMap_Path::music() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.music)
  return _internal_music();
}
inline void ISeeMap_Path::_internal_set_music(int32_t value) {
  
  _impl_.music_ = value;
}
inline void ISeeMap_Path::set_music(int32_t value) {
  _internal_set_music(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.music)
}

// int32 dedect_zone1 = 10;
inline void ISeeMap_Path::clear_dedect_zone1() {
  _impl_.dedect_zone1_ = 0;
}
inline int32_t ISeeMap_Path::_internal_dedect_zone1() const {
  return _impl_.dedect_zone1_;
}
inline int32_t ISeeMap_Path::dedect_zone1() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.dedect_zone1)
  return _internal_dedect_zone1();
}
inline void ISeeMap_Path::_internal_set_dedect_zone1(int32_t value) {
  
  _impl_.dedect_zone1_ = value;
}
inline void ISeeMap_Path::set_dedect_zone1(int32_t value) {
  _internal_set_dedect_zone1(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.dedect_zone1)
}

// int32 dedect_zone2 = 11;
inline void ISeeMap_Path::clear_dedect_zone2() {
  _impl_.dedect_zone2_ = 0;
}
inline int32_t ISeeMap_Path::_internal_dedect_zone2() const {
  return _impl_.dedect_zone2_;
}
inline int32_t ISeeMap_Path::dedect_zone2() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.dedect_zone2)
  return _internal_dedect_zone2();
}
inline void ISeeMap_Path::_internal_set_dedect_zone2(int32_t value) {
  
  _impl_.dedect_zone2_ = value;
}
inline void ISeeMap_Path::set_dedect_zone2(int32_t value) {
  _internal_set_dedect_zone2(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.dedect_zone2)
}

// float velocity_max = 12;
inline void ISeeMap_Path::clear_velocity_max() {
  _impl_.velocity_max_ = 0;
}
inline float ISeeMap_Path::_internal_velocity_max() const {
  return _impl_.velocity_max_;
}
inline float ISeeMap_Path::velocity_max() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.velocity_max)
  return _internal_velocity_max();
}
inline void ISeeMap_Path::_internal_set_velocity_max(float value) {
  
  _impl_.velocity_max_ = value;
}
inline void ISeeMap_Path::set_velocity_max(float value) {
  _internal_set_velocity_max(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.velocity_max)
}

// float radius = 13;
inline void ISeeMap_Path::clear_radius() {
  _impl_.radius_ = 0;
}
inline float ISeeMap_Path::_internal_radius() const {
  return _impl_.radius_;
}
inline float ISeeMap_Path::radius() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.radius)
  return _internal_radius();
}
inline void ISeeMap_Path::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void ISeeMap_Path::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.radius)
}

// float destination_range = 14;
inline void ISeeMap_Path::clear_destination_range() {
  _impl_.destination_range_ = 0;
}
inline float ISeeMap_Path::_internal_destination_range() const {
  return _impl_.destination_range_;
}
inline float ISeeMap_Path::destination_range() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.destination_range)
  return _internal_destination_range();
}
inline void ISeeMap_Path::_internal_set_destination_range(float value) {
  
  _impl_.destination_range_ = value;
}
inline void ISeeMap_Path::set_destination_range(float value) {
  _internal_set_destination_range(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.destination_range)
}

// float distance_zone_interchange = 15;
inline void ISeeMap_Path::clear_distance_zone_interchange() {
  _impl_.distance_zone_interchange_ = 0;
}
inline float ISeeMap_Path::_internal_distance_zone_interchange() const {
  return _impl_.distance_zone_interchange_;
}
inline float ISeeMap_Path::distance_zone_interchange() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.distance_zone_interchange)
  return _internal_distance_zone_interchange();
}
inline void ISeeMap_Path::_internal_set_distance_zone_interchange(float value) {
  
  _impl_.distance_zone_interchange_ = value;
}
inline void ISeeMap_Path::set_distance_zone_interchange(float value) {
  _internal_set_distance_zone_interchange(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.distance_zone_interchange)
}

// int32 is_running = 16;
inline void ISeeMap_Path::clear_is_running() {
  _impl_.is_running_ = 0;
}
inline int32_t ISeeMap_Path::_internal_is_running() const {
  return _impl_.is_running_;
}
inline int32_t ISeeMap_Path::is_running() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.is_running)
  return _internal_is_running();
}
inline void ISeeMap_Path::_internal_set_is_running(int32_t value) {
  
  _impl_.is_running_ = value;
}
inline void ISeeMap_Path::set_is_running(int32_t value) {
  _internal_set_is_running(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.is_running)
}

// int32 height_step = 17;
inline void ISeeMap_Path::clear_height_step() {
  _impl_.height_step_ = 0;
}
inline int32_t ISeeMap_Path::_internal_height_step() const {
  return _impl_.height_step_;
}
inline int32_t ISeeMap_Path::height_step() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.height_step)
  return _internal_height_step();
}
inline void ISeeMap_Path::_internal_set_height_step(int32_t value) {
  
  _impl_.height_step_ = value;
}
inline void ISeeMap_Path::set_height_step(int32_t value) {
  _internal_set_height_step(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.height_step)
}

// int32 cargo = 18;
inline void ISeeMap_Path::clear_cargo() {
  _impl_.cargo_ = 0;
}
inline int32_t ISeeMap_Path::_internal_cargo() const {
  return _impl_.cargo_;
}
inline int32_t ISeeMap_Path::cargo() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.cargo)
  return _internal_cargo();
}
inline void ISeeMap_Path::_internal_set_cargo(int32_t value) {
  
  _impl_.cargo_ = value;
}
inline void ISeeMap_Path::set_cargo(int32_t value) {
  _internal_set_cargo(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.cargo)
}

// int32 driving_direction = 19;
inline void ISeeMap_Path::clear_driving_direction() {
  _impl_.driving_direction_ = 0;
}
inline int32_t ISeeMap_Path::_internal_driving_direction() const {
  return _impl_.driving_direction_;
}
inline int32_t ISeeMap_Path::driving_direction() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.driving_direction)
  return _internal_driving_direction();
}
inline void ISeeMap_Path::_internal_set_driving_direction(int32_t value) {
  
  _impl_.driving_direction_ = value;
}
inline void ISeeMap_Path::set_driving_direction(int32_t value) {
  _internal_set_driving_direction(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.driving_direction)
}

// float distance = 20;
inline void ISeeMap_Path::clear_distance() {
  _impl_.distance_ = 0;
}
inline float ISeeMap_Path::_internal_distance() const {
  return _impl_.distance_;
}
inline float ISeeMap_Path::distance() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.distance)
  return _internal_distance();
}
inline void ISeeMap_Path::_internal_set_distance(float value) {
  
  _impl_.distance_ = value;
}
inline void ISeeMap_Path::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.distance)
}

// string flag = 21;
inline void ISeeMap_Path::clear_flag() {
  _impl_.flag_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::flag() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.flag)
  return _internal_flag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_flag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.flag)
}
inline std::string* ISeeMap_Path::mutable_flag() {
  std::string* _s = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.flag)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_flag() const {
  return _impl_.flag_.Get();
}
inline void ISeeMap_Path::_internal_set_flag(const std::string& value) {
  
  _impl_.flag_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_flag() {
  
  return _impl_.flag_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_flag() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.flag)
  return _impl_.flag_.Release();
}
inline void ISeeMap_Path::set_allocated_flag(std::string* flag) {
  if (flag != nullptr) {
    
  } else {
    
  }
  _impl_.flag_.SetAllocated(flag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flag_.IsDefault()) {
    _impl_.flag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.flag)
}

// string lmdate = 22;
inline void ISeeMap_Path::clear_lmdate() {
  _impl_.lmdate_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::lmdate() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.lmdate)
  return _internal_lmdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_lmdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.lmdate)
}
inline std::string* ISeeMap_Path::mutable_lmdate() {
  std::string* _s = _internal_mutable_lmdate();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.lmdate)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_lmdate() const {
  return _impl_.lmdate_.Get();
}
inline void ISeeMap_Path::_internal_set_lmdate(const std::string& value) {
  
  _impl_.lmdate_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_lmdate() {
  
  return _impl_.lmdate_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_lmdate() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.lmdate)
  return _impl_.lmdate_.Release();
}
inline void ISeeMap_Path::set_allocated_lmdate(std::string* lmdate) {
  if (lmdate != nullptr) {
    
  } else {
    
  }
  _impl_.lmdate_.SetAllocated(lmdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmdate_.IsDefault()) {
    _impl_.lmdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.lmdate)
}

// string region_id = 23;
inline void ISeeMap_Path::clear_region_id() {
  _impl_.region_id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::region_id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.region_id)
  return _internal_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_region_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.region_id)
}
inline std::string* ISeeMap_Path::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.region_id)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_region_id() const {
  return _impl_.region_id_.Get();
}
inline void ISeeMap_Path::_internal_set_region_id(const std::string& value) {
  
  _impl_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_region_id() {
  
  return _impl_.region_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_region_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.region_id)
  return _impl_.region_id_.Release();
}
inline void ISeeMap_Path::set_allocated_region_id(std::string* region_id) {
  if (region_id != nullptr) {
    
  } else {
    
  }
  _impl_.region_id_.SetAllocated(region_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_id_.IsDefault()) {
    _impl_.region_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.region_id)
}

// string transit_action = 24;
inline void ISeeMap_Path::clear_transit_action() {
  _impl_.transit_action_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::transit_action() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.transit_action)
  return _internal_transit_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_transit_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.transit_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.transit_action)
}
inline std::string* ISeeMap_Path::mutable_transit_action() {
  std::string* _s = _internal_mutable_transit_action();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.transit_action)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_transit_action() const {
  return _impl_.transit_action_.Get();
}
inline void ISeeMap_Path::_internal_set_transit_action(const std::string& value) {
  
  _impl_.transit_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_transit_action() {
  
  return _impl_.transit_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_transit_action() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.transit_action)
  return _impl_.transit_action_.Release();
}
inline void ISeeMap_Path::set_allocated_transit_action(std::string* transit_action) {
  if (transit_action != nullptr) {
    
  } else {
    
  }
  _impl_.transit_action_.SetAllocated(transit_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.transit_action_.IsDefault()) {
    _impl_.transit_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.transit_action)
}

// string enter_action = 25;
inline void ISeeMap_Path::clear_enter_action() {
  _impl_.enter_action_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::enter_action() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.enter_action)
  return _internal_enter_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_enter_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enter_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.enter_action)
}
inline std::string* ISeeMap_Path::mutable_enter_action() {
  std::string* _s = _internal_mutable_enter_action();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.enter_action)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_enter_action() const {
  return _impl_.enter_action_.Get();
}
inline void ISeeMap_Path::_internal_set_enter_action(const std::string& value) {
  
  _impl_.enter_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_enter_action() {
  
  return _impl_.enter_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_enter_action() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.enter_action)
  return _impl_.enter_action_.Release();
}
inline void ISeeMap_Path::set_allocated_enter_action(std::string* enter_action) {
  if (enter_action != nullptr) {
    
  } else {
    
  }
  _impl_.enter_action_.SetAllocated(enter_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enter_action_.IsDefault()) {
    _impl_.enter_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.enter_action)
}

// string exit_action = 26;
inline void ISeeMap_Path::clear_exit_action() {
  _impl_.exit_action_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::exit_action() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.exit_action)
  return _internal_exit_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_exit_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exit_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.exit_action)
}
inline std::string* ISeeMap_Path::mutable_exit_action() {
  std::string* _s = _internal_mutable_exit_action();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.exit_action)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_exit_action() const {
  return _impl_.exit_action_.Get();
}
inline void ISeeMap_Path::_internal_set_exit_action(const std::string& value) {
  
  _impl_.exit_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_exit_action() {
  
  return _impl_.exit_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_exit_action() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.exit_action)
  return _impl_.exit_action_.Release();
}
inline void ISeeMap_Path::set_allocated_exit_action(std::string* exit_action) {
  if (exit_action != nullptr) {
    
  } else {
    
  }
  _impl_.exit_action_.SetAllocated(exit_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exit_action_.IsDefault()) {
    _impl_.exit_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.exit_action)
}

// bool allow_auto_avoid = 27;
inline void ISeeMap_Path::clear_allow_auto_avoid() {
  _impl_.allow_auto_avoid_ = false;
}
inline bool ISeeMap_Path::_internal_allow_auto_avoid() const {
  return _impl_.allow_auto_avoid_;
}
inline bool ISeeMap_Path::allow_auto_avoid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.allow_auto_avoid)
  return _internal_allow_auto_avoid();
}
inline void ISeeMap_Path::_internal_set_allow_auto_avoid(bool value) {
  
  _impl_.allow_auto_avoid_ = value;
}
inline void ISeeMap_Path::set_allow_auto_avoid(bool value) {
  _internal_set_allow_auto_avoid(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Path.allow_auto_avoid)
}

// string car_type = 28;
inline void ISeeMap_Path::clear_car_type() {
  _impl_.car_type_.ClearToEmpty();
}
inline const std::string& ISeeMap_Path::car_type() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Path.car_type)
  return _internal_car_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Path::set_car_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.car_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Path.car_type)
}
inline std::string* ISeeMap_Path::mutable_car_type() {
  std::string* _s = _internal_mutable_car_type();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Path.car_type)
  return _s;
}
inline const std::string& ISeeMap_Path::_internal_car_type() const {
  return _impl_.car_type_.Get();
}
inline void ISeeMap_Path::_internal_set_car_type(const std::string& value) {
  
  _impl_.car_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::_internal_mutable_car_type() {
  
  return _impl_.car_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Path::release_car_type() {
  // @@protoc_insertion_point(field_release:ISeeMap.Path.car_type)
  return _impl_.car_type_.Release();
}
inline void ISeeMap_Path::set_allocated_car_type(std::string* car_type) {
  if (car_type != nullptr) {
    
  } else {
    
  }
  _impl_.car_type_.SetAllocated(car_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.car_type_.IsDefault()) {
    _impl_.car_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Path.car_type)
}

// -------------------------------------------------------------------

// ISeeMap_Station

// string id = 1;
inline void ISeeMap_Station::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.id)
}
inline std::string* ISeeMap_Station::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.id)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ISeeMap_Station::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.id)
  return _impl_.id_.Release();
}
inline void ISeeMap_Station::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.id)
}

// string station_rfid = 2;
inline void ISeeMap_Station::clear_station_rfid() {
  _impl_.station_rfid_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::station_rfid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.station_rfid)
  return _internal_station_rfid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_station_rfid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_rfid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.station_rfid)
}
inline std::string* ISeeMap_Station::mutable_station_rfid() {
  std::string* _s = _internal_mutable_station_rfid();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.station_rfid)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_station_rfid() const {
  return _impl_.station_rfid_.Get();
}
inline void ISeeMap_Station::_internal_set_station_rfid(const std::string& value) {
  
  _impl_.station_rfid_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_station_rfid() {
  
  return _impl_.station_rfid_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_station_rfid() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.station_rfid)
  return _impl_.station_rfid_.Release();
}
inline void ISeeMap_Station::set_allocated_station_rfid(std::string* station_rfid) {
  if (station_rfid != nullptr) {
    
  } else {
    
  }
  _impl_.station_rfid_.SetAllocated(station_rfid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_rfid_.IsDefault()) {
    _impl_.station_rfid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.station_rfid)
}

// string station_name = 3;
inline void ISeeMap_Station::clear_station_name() {
  _impl_.station_name_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::station_name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.station_name)
  return _internal_station_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_station_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.station_name)
}
inline std::string* ISeeMap_Station::mutable_station_name() {
  std::string* _s = _internal_mutable_station_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.station_name)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_station_name() const {
  return _impl_.station_name_.Get();
}
inline void ISeeMap_Station::_internal_set_station_name(const std::string& value) {
  
  _impl_.station_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_station_name() {
  
  return _impl_.station_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_station_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.station_name)
  return _impl_.station_name_.Release();
}
inline void ISeeMap_Station::set_allocated_station_name(std::string* station_name) {
  if (station_name != nullptr) {
    
  } else {
    
  }
  _impl_.station_name_.SetAllocated(station_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_name_.IsDefault()) {
    _impl_.station_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.station_name)
}

// string station_type = 4;
inline void ISeeMap_Station::clear_station_type() {
  _impl_.station_type_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::station_type() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.station_type)
  return _internal_station_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_station_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.station_type)
}
inline std::string* ISeeMap_Station::mutable_station_type() {
  std::string* _s = _internal_mutable_station_type();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.station_type)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_station_type() const {
  return _impl_.station_type_.Get();
}
inline void ISeeMap_Station::_internal_set_station_type(const std::string& value) {
  
  _impl_.station_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_station_type() {
  
  return _impl_.station_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_station_type() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.station_type)
  return _impl_.station_type_.Release();
}
inline void ISeeMap_Station::set_allocated_station_type(std::string* station_type) {
  if (station_type != nullptr) {
    
  } else {
    
  }
  _impl_.station_type_.SetAllocated(station_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_type_.IsDefault()) {
    _impl_.station_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.station_type)
}

// float space_x = 5;
inline void ISeeMap_Station::clear_space_x() {
  _impl_.space_x_ = 0;
}
inline float ISeeMap_Station::_internal_space_x() const {
  return _impl_.space_x_;
}
inline float ISeeMap_Station::space_x() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.space_x)
  return _internal_space_x();
}
inline void ISeeMap_Station::_internal_set_space_x(float value) {
  
  _impl_.space_x_ = value;
}
inline void ISeeMap_Station::set_space_x(float value) {
  _internal_set_space_x(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Station.space_x)
}

// float space_y = 6;
inline void ISeeMap_Station::clear_space_y() {
  _impl_.space_y_ = 0;
}
inline float ISeeMap_Station::_internal_space_y() const {
  return _impl_.space_y_;
}
inline float ISeeMap_Station::space_y() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.space_y)
  return _internal_space_y();
}
inline void ISeeMap_Station::_internal_set_space_y(float value) {
  
  _impl_.space_y_ = value;
}
inline void ISeeMap_Station::set_space_y(float value) {
  _internal_set_space_y(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Station.space_y)
}

// float z_axis = 7;
inline void ISeeMap_Station::clear_z_axis() {
  _impl_.z_axis_ = 0;
}
inline float ISeeMap_Station::_internal_z_axis() const {
  return _impl_.z_axis_;
}
inline float ISeeMap_Station::z_axis() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.z_axis)
  return _internal_z_axis();
}
inline void ISeeMap_Station::_internal_set_z_axis(float value) {
  
  _impl_.z_axis_ = value;
}
inline void ISeeMap_Station::set_z_axis(float value) {
  _internal_set_z_axis(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Station.z_axis)
}

// string related_id = 8;
inline void ISeeMap_Station::clear_related_id() {
  _impl_.related_id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::related_id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.related_id)
  return _internal_related_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_related_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.related_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.related_id)
}
inline std::string* ISeeMap_Station::mutable_related_id() {
  std::string* _s = _internal_mutable_related_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.related_id)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_related_id() const {
  return _impl_.related_id_.Get();
}
inline void ISeeMap_Station::_internal_set_related_id(const std::string& value) {
  
  _impl_.related_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_related_id() {
  
  return _impl_.related_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_related_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.related_id)
  return _impl_.related_id_.Release();
}
inline void ISeeMap_Station::set_allocated_related_id(std::string* related_id) {
  if (related_id != nullptr) {
    
  } else {
    
  }
  _impl_.related_id_.SetAllocated(related_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.related_id_.IsDefault()) {
    _impl_.related_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.related_id)
}

// string flag = 9;
inline void ISeeMap_Station::clear_flag() {
  _impl_.flag_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::flag() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.flag)
  return _internal_flag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_flag(ArgT0&& arg0, ArgT... args) {
 
 _impl_.flag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.flag)
}
inline std::string* ISeeMap_Station::mutable_flag() {
  std::string* _s = _internal_mutable_flag();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.flag)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_flag() const {
  return _impl_.flag_.Get();
}
inline void ISeeMap_Station::_internal_set_flag(const std::string& value) {
  
  _impl_.flag_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_flag() {
  
  return _impl_.flag_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_flag() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.flag)
  return _impl_.flag_.Release();
}
inline void ISeeMap_Station::set_allocated_flag(std::string* flag) {
  if (flag != nullptr) {
    
  } else {
    
  }
  _impl_.flag_.SetAllocated(flag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.flag_.IsDefault()) {
    _impl_.flag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.flag)
}

// string lmdate = 10;
inline void ISeeMap_Station::clear_lmdate() {
  _impl_.lmdate_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::lmdate() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.lmdate)
  return _internal_lmdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_lmdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.lmdate)
}
inline std::string* ISeeMap_Station::mutable_lmdate() {
  std::string* _s = _internal_mutable_lmdate();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.lmdate)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_lmdate() const {
  return _impl_.lmdate_.Get();
}
inline void ISeeMap_Station::_internal_set_lmdate(const std::string& value) {
  
  _impl_.lmdate_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_lmdate() {
  
  return _impl_.lmdate_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_lmdate() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.lmdate)
  return _impl_.lmdate_.Release();
}
inline void ISeeMap_Station::set_allocated_lmdate(std::string* lmdate) {
  if (lmdate != nullptr) {
    
  } else {
    
  }
  _impl_.lmdate_.SetAllocated(lmdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmdate_.IsDefault()) {
    _impl_.lmdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.lmdate)
}

// string region_id = 11;
inline void ISeeMap_Station::clear_region_id() {
  _impl_.region_id_.ClearToEmpty();
}
inline const std::string& ISeeMap_Station::region_id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.region_id)
  return _internal_region_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Station::set_region_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.region_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Station.region_id)
}
inline std::string* ISeeMap_Station::mutable_region_id() {
  std::string* _s = _internal_mutable_region_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Station.region_id)
  return _s;
}
inline const std::string& ISeeMap_Station::_internal_region_id() const {
  return _impl_.region_id_.Get();
}
inline void ISeeMap_Station::_internal_set_region_id(const std::string& value) {
  
  _impl_.region_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::_internal_mutable_region_id() {
  
  return _impl_.region_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Station::release_region_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.Station.region_id)
  return _impl_.region_id_.Release();
}
inline void ISeeMap_Station::set_allocated_region_id(std::string* region_id) {
  if (region_id != nullptr) {
    
  } else {
    
  }
  _impl_.region_id_.SetAllocated(region_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.region_id_.IsDefault()) {
    _impl_.region_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Station.region_id)
}

// uint32 QR_id = 12;
inline void ISeeMap_Station::clear_qr_id() {
  _impl_.qr_id_ = 0u;
}
inline uint32_t ISeeMap_Station::_internal_qr_id() const {
  return _impl_.qr_id_;
}
inline uint32_t ISeeMap_Station::qr_id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.QR_id)
  return _internal_qr_id();
}
inline void ISeeMap_Station::_internal_set_qr_id(uint32_t value) {
  
  _impl_.qr_id_ = value;
}
inline void ISeeMap_Station::set_qr_id(uint32_t value) {
  _internal_set_qr_id(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Station.QR_id)
}

// float QR_angle = 13;
inline void ISeeMap_Station::clear_qr_angle() {
  _impl_.qr_angle_ = 0;
}
inline float ISeeMap_Station::_internal_qr_angle() const {
  return _impl_.qr_angle_;
}
inline float ISeeMap_Station::qr_angle() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Station.QR_angle)
  return _internal_qr_angle();
}
inline void ISeeMap_Station::_internal_set_qr_angle(float value) {
  
  _impl_.qr_angle_ = value;
}
inline void ISeeMap_Station::set_qr_angle(float value) {
  _internal_set_qr_angle(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Station.QR_angle)
}

// -------------------------------------------------------------------

// ISeeMap_Configuration

// string area_name = 1;
inline void ISeeMap_Configuration::clear_area_name() {
  _impl_.area_name_.ClearToEmpty();
}
inline const std::string& ISeeMap_Configuration::area_name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.area_name)
  return _internal_area_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Configuration::set_area_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.area_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.area_name)
}
inline std::string* ISeeMap_Configuration::mutable_area_name() {
  std::string* _s = _internal_mutable_area_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Configuration.area_name)
  return _s;
}
inline const std::string& ISeeMap_Configuration::_internal_area_name() const {
  return _impl_.area_name_.Get();
}
inline void ISeeMap_Configuration::_internal_set_area_name(const std::string& value) {
  
  _impl_.area_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Configuration::_internal_mutable_area_name() {
  
  return _impl_.area_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Configuration::release_area_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.Configuration.area_name)
  return _impl_.area_name_.Release();
}
inline void ISeeMap_Configuration::set_allocated_area_name(std::string* area_name) {
  if (area_name != nullptr) {
    
  } else {
    
  }
  _impl_.area_name_.SetAllocated(area_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.area_name_.IsDefault()) {
    _impl_.area_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Configuration.area_name)
}

// string task_type = 2;
inline void ISeeMap_Configuration::clear_task_type() {
  _impl_.task_type_.ClearToEmpty();
}
inline const std::string& ISeeMap_Configuration::task_type() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.task_type)
  return _internal_task_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_Configuration::set_task_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.task_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.task_type)
}
inline std::string* ISeeMap_Configuration::mutable_task_type() {
  std::string* _s = _internal_mutable_task_type();
  // @@protoc_insertion_point(field_mutable:ISeeMap.Configuration.task_type)
  return _s;
}
inline const std::string& ISeeMap_Configuration::_internal_task_type() const {
  return _impl_.task_type_.Get();
}
inline void ISeeMap_Configuration::_internal_set_task_type(const std::string& value) {
  
  _impl_.task_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_Configuration::_internal_mutable_task_type() {
  
  return _impl_.task_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_Configuration::release_task_type() {
  // @@protoc_insertion_point(field_release:ISeeMap.Configuration.task_type)
  return _impl_.task_type_.Release();
}
inline void ISeeMap_Configuration::set_allocated_task_type(std::string* task_type) {
  if (task_type != nullptr) {
    
  } else {
    
  }
  _impl_.task_type_.SetAllocated(task_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.task_type_.IsDefault()) {
    _impl_.task_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.Configuration.task_type)
}

// int32 section = 3;
inline void ISeeMap_Configuration::clear_section() {
  _impl_.section_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_section() const {
  return _impl_.section_;
}
inline int32_t ISeeMap_Configuration::section() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.section)
  return _internal_section();
}
inline void ISeeMap_Configuration::_internal_set_section(int32_t value) {
  
  _impl_.section_ = value;
}
inline void ISeeMap_Configuration::set_section(int32_t value) {
  _internal_set_section(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.section)
}

// int32 laser_head_height = 4;
inline void ISeeMap_Configuration::clear_laser_head_height() {
  _impl_.laser_head_height_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_laser_head_height() const {
  return _impl_.laser_head_height_;
}
inline int32_t ISeeMap_Configuration::laser_head_height() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.laser_head_height)
  return _internal_laser_head_height();
}
inline void ISeeMap_Configuration::_internal_set_laser_head_height(int32_t value) {
  
  _impl_.laser_head_height_ = value;
}
inline void ISeeMap_Configuration::set_laser_head_height(int32_t value) {
  _internal_set_laser_head_height(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.laser_head_height)
}

// int32 dedect_zone1 = 5;
inline void ISeeMap_Configuration::clear_dedect_zone1() {
  _impl_.dedect_zone1_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_dedect_zone1() const {
  return _impl_.dedect_zone1_;
}
inline int32_t ISeeMap_Configuration::dedect_zone1() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.dedect_zone1)
  return _internal_dedect_zone1();
}
inline void ISeeMap_Configuration::_internal_set_dedect_zone1(int32_t value) {
  
  _impl_.dedect_zone1_ = value;
}
inline void ISeeMap_Configuration::set_dedect_zone1(int32_t value) {
  _internal_set_dedect_zone1(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.dedect_zone1)
}

// int32 dedect_zone2 = 6;
inline void ISeeMap_Configuration::clear_dedect_zone2() {
  _impl_.dedect_zone2_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_dedect_zone2() const {
  return _impl_.dedect_zone2_;
}
inline int32_t ISeeMap_Configuration::dedect_zone2() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.dedect_zone2)
  return _internal_dedect_zone2();
}
inline void ISeeMap_Configuration::_internal_set_dedect_zone2(int32_t value) {
  
  _impl_.dedect_zone2_ = value;
}
inline void ISeeMap_Configuration::set_dedect_zone2(int32_t value) {
  _internal_set_dedect_zone2(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.dedect_zone2)
}

// int32 distance_zone_interchange = 7;
inline void ISeeMap_Configuration::clear_distance_zone_interchange() {
  _impl_.distance_zone_interchange_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_distance_zone_interchange() const {
  return _impl_.distance_zone_interchange_;
}
inline int32_t ISeeMap_Configuration::distance_zone_interchange() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.distance_zone_interchange)
  return _internal_distance_zone_interchange();
}
inline void ISeeMap_Configuration::_internal_set_distance_zone_interchange(int32_t value) {
  
  _impl_.distance_zone_interchange_ = value;
}
inline void ISeeMap_Configuration::set_distance_zone_interchange(int32_t value) {
  _internal_set_distance_zone_interchange(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.distance_zone_interchange)
}

// int32 destination_range = 8;
inline void ISeeMap_Configuration::clear_destination_range() {
  _impl_.destination_range_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_destination_range() const {
  return _impl_.destination_range_;
}
inline int32_t ISeeMap_Configuration::destination_range() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.destination_range)
  return _internal_destination_range();
}
inline void ISeeMap_Configuration::_internal_set_destination_range(int32_t value) {
  
  _impl_.destination_range_ = value;
}
inline void ISeeMap_Configuration::set_destination_range(int32_t value) {
  _internal_set_destination_range(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.destination_range)
}

// int32 height_step = 9;
inline void ISeeMap_Configuration::clear_height_step() {
  _impl_.height_step_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_height_step() const {
  return _impl_.height_step_;
}
inline int32_t ISeeMap_Configuration::height_step() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.height_step)
  return _internal_height_step();
}
inline void ISeeMap_Configuration::_internal_set_height_step(int32_t value) {
  
  _impl_.height_step_ = value;
}
inline void ISeeMap_Configuration::set_height_step(int32_t value) {
  _internal_set_height_step(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.height_step)
}

// int32 cargo = 10;
inline void ISeeMap_Configuration::clear_cargo() {
  _impl_.cargo_ = 0;
}
inline int32_t ISeeMap_Configuration::_internal_cargo() const {
  return _impl_.cargo_;
}
inline int32_t ISeeMap_Configuration::cargo() const {
  // @@protoc_insertion_point(field_get:ISeeMap.Configuration.cargo)
  return _internal_cargo();
}
inline void ISeeMap_Configuration::_internal_set_cargo(int32_t value) {
  
  _impl_.cargo_ = value;
}
inline void ISeeMap_Configuration::set_cargo(int32_t value) {
  _internal_set_cargo(value);
  // @@protoc_insertion_point(field_set:ISeeMap.Configuration.cargo)
}

// -------------------------------------------------------------------

// ISeeMap_TaskAction

// bytes action_name = 1;
inline void ISeeMap_TaskAction::clear_action_name() {
  _impl_.action_name_.ClearToEmpty();
}
inline const std::string& ISeeMap_TaskAction::action_name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.TaskAction.action_name)
  return _internal_action_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_TaskAction::set_action_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.action_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.TaskAction.action_name)
}
inline std::string* ISeeMap_TaskAction::mutable_action_name() {
  std::string* _s = _internal_mutable_action_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.TaskAction.action_name)
  return _s;
}
inline const std::string& ISeeMap_TaskAction::_internal_action_name() const {
  return _impl_.action_name_.Get();
}
inline void ISeeMap_TaskAction::_internal_set_action_name(const std::string& value) {
  
  _impl_.action_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::_internal_mutable_action_name() {
  
  return _impl_.action_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::release_action_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.TaskAction.action_name)
  return _impl_.action_name_.Release();
}
inline void ISeeMap_TaskAction::set_allocated_action_name(std::string* action_name) {
  if (action_name != nullptr) {
    
  } else {
    
  }
  _impl_.action_name_.SetAllocated(action_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.action_name_.IsDefault()) {
    _impl_.action_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.TaskAction.action_name)
}

// string enter_action = 2;
inline void ISeeMap_TaskAction::clear_enter_action() {
  _impl_.enter_action_.ClearToEmpty();
}
inline const std::string& ISeeMap_TaskAction::enter_action() const {
  // @@protoc_insertion_point(field_get:ISeeMap.TaskAction.enter_action)
  return _internal_enter_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_TaskAction::set_enter_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.enter_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.TaskAction.enter_action)
}
inline std::string* ISeeMap_TaskAction::mutable_enter_action() {
  std::string* _s = _internal_mutable_enter_action();
  // @@protoc_insertion_point(field_mutable:ISeeMap.TaskAction.enter_action)
  return _s;
}
inline const std::string& ISeeMap_TaskAction::_internal_enter_action() const {
  return _impl_.enter_action_.Get();
}
inline void ISeeMap_TaskAction::_internal_set_enter_action(const std::string& value) {
  
  _impl_.enter_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::_internal_mutable_enter_action() {
  
  return _impl_.enter_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::release_enter_action() {
  // @@protoc_insertion_point(field_release:ISeeMap.TaskAction.enter_action)
  return _impl_.enter_action_.Release();
}
inline void ISeeMap_TaskAction::set_allocated_enter_action(std::string* enter_action) {
  if (enter_action != nullptr) {
    
  } else {
    
  }
  _impl_.enter_action_.SetAllocated(enter_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.enter_action_.IsDefault()) {
    _impl_.enter_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.TaskAction.enter_action)
}

// string exit_action = 3;
inline void ISeeMap_TaskAction::clear_exit_action() {
  _impl_.exit_action_.ClearToEmpty();
}
inline const std::string& ISeeMap_TaskAction::exit_action() const {
  // @@protoc_insertion_point(field_get:ISeeMap.TaskAction.exit_action)
  return _internal_exit_action();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_TaskAction::set_exit_action(ArgT0&& arg0, ArgT... args) {
 
 _impl_.exit_action_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.TaskAction.exit_action)
}
inline std::string* ISeeMap_TaskAction::mutable_exit_action() {
  std::string* _s = _internal_mutable_exit_action();
  // @@protoc_insertion_point(field_mutable:ISeeMap.TaskAction.exit_action)
  return _s;
}
inline const std::string& ISeeMap_TaskAction::_internal_exit_action() const {
  return _impl_.exit_action_.Get();
}
inline void ISeeMap_TaskAction::_internal_set_exit_action(const std::string& value) {
  
  _impl_.exit_action_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::_internal_mutable_exit_action() {
  
  return _impl_.exit_action_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_TaskAction::release_exit_action() {
  // @@protoc_insertion_point(field_release:ISeeMap.TaskAction.exit_action)
  return _impl_.exit_action_.Release();
}
inline void ISeeMap_TaskAction::set_allocated_exit_action(std::string* exit_action) {
  if (exit_action != nullptr) {
    
  } else {
    
  }
  _impl_.exit_action_.SetAllocated(exit_action, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.exit_action_.IsDefault()) {
    _impl_.exit_action_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.TaskAction.exit_action)
}

// -------------------------------------------------------------------

// ISeeMap_CarManagemet

// string id = 1;
inline void ISeeMap_CarManagemet::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::id() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.id)
}
inline std::string* ISeeMap_CarManagemet::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.id)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_id() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.id)
  return _impl_.id_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.id)
}

// bytes name = 2;
inline void ISeeMap_CarManagemet::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.name)
}
inline std::string* ISeeMap_CarManagemet::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.name)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_name() const {
  return _impl_.name_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.name)
  return _impl_.name_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.name)
}

// int32 number = 3;
inline void ISeeMap_CarManagemet::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t ISeeMap_CarManagemet::_internal_number() const {
  return _impl_.number_;
}
inline int32_t ISeeMap_CarManagemet::number() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.number)
  return _internal_number();
}
inline void ISeeMap_CarManagemet::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void ISeeMap_CarManagemet::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.number)
}

// string mac = 4;
inline void ISeeMap_CarManagemet::clear_mac() {
  _impl_.mac_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::mac() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_mac(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mac_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.mac)
}
inline std::string* ISeeMap_CarManagemet::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.mac)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_mac() const {
  return _impl_.mac_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_mac(const std::string& value) {
  
  _impl_.mac_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_mac() {
  
  return _impl_.mac_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_mac() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.mac)
  return _impl_.mac_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  _impl_.mac_.SetAllocated(mac, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mac_.IsDefault()) {
    _impl_.mac_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.mac)
}

// string ip = 5;
inline void ISeeMap_CarManagemet::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::ip() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.ip)
}
inline std::string* ISeeMap_CarManagemet::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.ip)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_ip() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.ip)
  return _impl_.ip_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.ip)
}

// bytes car_type = 6;
inline void ISeeMap_CarManagemet::clear_car_type() {
  _impl_.car_type_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::car_type() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.car_type)
  return _internal_car_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_car_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.car_type_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.car_type)
}
inline std::string* ISeeMap_CarManagemet::mutable_car_type() {
  std::string* _s = _internal_mutable_car_type();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.car_type)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_car_type() const {
  return _impl_.car_type_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_car_type(const std::string& value) {
  
  _impl_.car_type_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_car_type() {
  
  return _impl_.car_type_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_car_type() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.car_type)
  return _impl_.car_type_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_car_type(std::string* car_type) {
  if (car_type != nullptr) {
    
  } else {
    
  }
  _impl_.car_type_.SetAllocated(car_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.car_type_.IsDefault()) {
    _impl_.car_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.car_type)
}

// string battery = 7;
inline void ISeeMap_CarManagemet::clear_battery() {
  _impl_.battery_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::battery() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.battery)
  return _internal_battery();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_battery(ArgT0&& arg0, ArgT... args) {
 
 _impl_.battery_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.battery)
}
inline std::string* ISeeMap_CarManagemet::mutable_battery() {
  std::string* _s = _internal_mutable_battery();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.battery)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_battery() const {
  return _impl_.battery_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_battery(const std::string& value) {
  
  _impl_.battery_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_battery() {
  
  return _impl_.battery_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_battery() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.battery)
  return _impl_.battery_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_battery(std::string* battery) {
  if (battery != nullptr) {
    
  } else {
    
  }
  _impl_.battery_.SetAllocated(battery, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.battery_.IsDefault()) {
    _impl_.battery_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.battery)
}

// double rated_load = 8;
inline void ISeeMap_CarManagemet::clear_rated_load() {
  _impl_.rated_load_ = 0;
}
inline double ISeeMap_CarManagemet::_internal_rated_load() const {
  return _impl_.rated_load_;
}
inline double ISeeMap_CarManagemet::rated_load() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.rated_load)
  return _internal_rated_load();
}
inline void ISeeMap_CarManagemet::_internal_set_rated_load(double value) {
  
  _impl_.rated_load_ = value;
}
inline void ISeeMap_CarManagemet::set_rated_load(double value) {
  _internal_set_rated_load(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.rated_load)
}

// double length = 9;
inline void ISeeMap_CarManagemet::clear_length() {
  _impl_.length_ = 0;
}
inline double ISeeMap_CarManagemet::_internal_length() const {
  return _impl_.length_;
}
inline double ISeeMap_CarManagemet::length() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.length)
  return _internal_length();
}
inline void ISeeMap_CarManagemet::_internal_set_length(double value) {
  
  _impl_.length_ = value;
}
inline void ISeeMap_CarManagemet::set_length(double value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.length)
}

// double width = 10;
inline void ISeeMap_CarManagemet::clear_width() {
  _impl_.width_ = 0;
}
inline double ISeeMap_CarManagemet::_internal_width() const {
  return _impl_.width_;
}
inline double ISeeMap_CarManagemet::width() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.width)
  return _internal_width();
}
inline void ISeeMap_CarManagemet::_internal_set_width(double value) {
  
  _impl_.width_ = value;
}
inline void ISeeMap_CarManagemet::set_width(double value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.width)
}

// double margin = 11;
inline void ISeeMap_CarManagemet::clear_margin() {
  _impl_.margin_ = 0;
}
inline double ISeeMap_CarManagemet::_internal_margin() const {
  return _impl_.margin_;
}
inline double ISeeMap_CarManagemet::margin() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.margin)
  return _internal_margin();
}
inline void ISeeMap_CarManagemet::_internal_set_margin(double value) {
  
  _impl_.margin_ = value;
}
inline void ISeeMap_CarManagemet::set_margin(double value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.margin)
}

// double reference_point = 12;
inline void ISeeMap_CarManagemet::clear_reference_point() {
  _impl_.reference_point_ = 0;
}
inline double ISeeMap_CarManagemet::_internal_reference_point() const {
  return _impl_.reference_point_;
}
inline double ISeeMap_CarManagemet::reference_point() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.reference_point)
  return _internal_reference_point();
}
inline void ISeeMap_CarManagemet::_internal_set_reference_point(double value) {
  
  _impl_.reference_point_ = value;
}
inline void ISeeMap_CarManagemet::set_reference_point(double value) {
  _internal_set_reference_point(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.reference_point)
}

// int32 run_time = 13;
inline void ISeeMap_CarManagemet::clear_run_time() {
  _impl_.run_time_ = 0;
}
inline int32_t ISeeMap_CarManagemet::_internal_run_time() const {
  return _impl_.run_time_;
}
inline int32_t ISeeMap_CarManagemet::run_time() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.run_time)
  return _internal_run_time();
}
inline void ISeeMap_CarManagemet::_internal_set_run_time(int32_t value) {
  
  _impl_.run_time_ = value;
}
inline void ISeeMap_CarManagemet::set_run_time(int32_t value) {
  _internal_set_run_time(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.run_time)
}

// string valid = 14;
inline void ISeeMap_CarManagemet::clear_valid() {
  _impl_.valid_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::valid() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.valid)
  return _internal_valid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_valid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.valid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.valid)
}
inline std::string* ISeeMap_CarManagemet::mutable_valid() {
  std::string* _s = _internal_mutable_valid();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.valid)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_valid() const {
  return _impl_.valid_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_valid(const std::string& value) {
  
  _impl_.valid_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_valid() {
  
  return _impl_.valid_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_valid() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.valid)
  return _impl_.valid_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_valid(std::string* valid) {
  if (valid != nullptr) {
    
  } else {
    
  }
  _impl_.valid_.SetAllocated(valid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.valid_.IsDefault()) {
    _impl_.valid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.valid)
}

// string lmuser = 15;
inline void ISeeMap_CarManagemet::clear_lmuser() {
  _impl_.lmuser_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::lmuser() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.lmuser)
  return _internal_lmuser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_lmuser(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmuser_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.lmuser)
}
inline std::string* ISeeMap_CarManagemet::mutable_lmuser() {
  std::string* _s = _internal_mutable_lmuser();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.lmuser)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_lmuser() const {
  return _impl_.lmuser_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_lmuser(const std::string& value) {
  
  _impl_.lmuser_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_lmuser() {
  
  return _impl_.lmuser_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_lmuser() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.lmuser)
  return _impl_.lmuser_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_lmuser(std::string* lmuser) {
  if (lmuser != nullptr) {
    
  } else {
    
  }
  _impl_.lmuser_.SetAllocated(lmuser, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmuser_.IsDefault()) {
    _impl_.lmuser_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.lmuser)
}

// string lmdate = 16;
inline void ISeeMap_CarManagemet::clear_lmdate() {
  _impl_.lmdate_.ClearToEmpty();
}
inline const std::string& ISeeMap_CarManagemet::lmdate() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CarManagemet.lmdate)
  return _internal_lmdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CarManagemet::set_lmdate(ArgT0&& arg0, ArgT... args) {
 
 _impl_.lmdate_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CarManagemet.lmdate)
}
inline std::string* ISeeMap_CarManagemet::mutable_lmdate() {
  std::string* _s = _internal_mutable_lmdate();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CarManagemet.lmdate)
  return _s;
}
inline const std::string& ISeeMap_CarManagemet::_internal_lmdate() const {
  return _impl_.lmdate_.Get();
}
inline void ISeeMap_CarManagemet::_internal_set_lmdate(const std::string& value) {
  
  _impl_.lmdate_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::_internal_mutable_lmdate() {
  
  return _impl_.lmdate_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CarManagemet::release_lmdate() {
  // @@protoc_insertion_point(field_release:ISeeMap.CarManagemet.lmdate)
  return _impl_.lmdate_.Release();
}
inline void ISeeMap_CarManagemet::set_allocated_lmdate(std::string* lmdate) {
  if (lmdate != nullptr) {
    
  } else {
    
  }
  _impl_.lmdate_.SetAllocated(lmdate, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.lmdate_.IsDefault()) {
    _impl_.lmdate_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CarManagemet.lmdate)
}

// -------------------------------------------------------------------

// ISeeMap_CoordOffset

// string station_name = 1;
inline void ISeeMap_CoordOffset::clear_station_name() {
  _impl_.station_name_.ClearToEmpty();
}
inline const std::string& ISeeMap_CoordOffset::station_name() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CoordOffset.station_name)
  return _internal_station_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ISeeMap_CoordOffset::set_station_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.station_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ISeeMap.CoordOffset.station_name)
}
inline std::string* ISeeMap_CoordOffset::mutable_station_name() {
  std::string* _s = _internal_mutable_station_name();
  // @@protoc_insertion_point(field_mutable:ISeeMap.CoordOffset.station_name)
  return _s;
}
inline const std::string& ISeeMap_CoordOffset::_internal_station_name() const {
  return _impl_.station_name_.Get();
}
inline void ISeeMap_CoordOffset::_internal_set_station_name(const std::string& value) {
  
  _impl_.station_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ISeeMap_CoordOffset::_internal_mutable_station_name() {
  
  return _impl_.station_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ISeeMap_CoordOffset::release_station_name() {
  // @@protoc_insertion_point(field_release:ISeeMap.CoordOffset.station_name)
  return _impl_.station_name_.Release();
}
inline void ISeeMap_CoordOffset::set_allocated_station_name(std::string* station_name) {
  if (station_name != nullptr) {
    
  } else {
    
  }
  _impl_.station_name_.SetAllocated(station_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.station_name_.IsDefault()) {
    _impl_.station_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.CoordOffset.station_name)
}

// float x = 2;
inline void ISeeMap_CoordOffset::clear_x() {
  _impl_.x_ = 0;
}
inline float ISeeMap_CoordOffset::_internal_x() const {
  return _impl_.x_;
}
inline float ISeeMap_CoordOffset::x() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CoordOffset.x)
  return _internal_x();
}
inline void ISeeMap_CoordOffset::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void ISeeMap_CoordOffset::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CoordOffset.x)
}

// float y = 3;
inline void ISeeMap_CoordOffset::clear_y() {
  _impl_.y_ = 0;
}
inline float ISeeMap_CoordOffset::_internal_y() const {
  return _impl_.y_;
}
inline float ISeeMap_CoordOffset::y() const {
  // @@protoc_insertion_point(field_get:ISeeMap.CoordOffset.y)
  return _internal_y();
}
inline void ISeeMap_CoordOffset::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void ISeeMap_CoordOffset::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ISeeMap.CoordOffset.y)
}

// -------------------------------------------------------------------

// ISeeMap

// .ISeeMap.Region region = 1;
inline bool ISeeMap::_internal_has_region() const {
  return this != internal_default_instance() && _impl_.region_ != nullptr;
}
inline bool ISeeMap::has_region() const {
  return _internal_has_region();
}
inline void ISeeMap::clear_region() {
  if (GetArenaForAllocation() == nullptr && _impl_.region_ != nullptr) {
    delete _impl_.region_;
  }
  _impl_.region_ = nullptr;
}
inline const ::ISeeMap_Region& ISeeMap::_internal_region() const {
  const ::ISeeMap_Region* p = _impl_.region_;
  return p != nullptr ? *p : reinterpret_cast<const ::ISeeMap_Region&>(
      ::_ISeeMap_Region_default_instance_);
}
inline const ::ISeeMap_Region& ISeeMap::region() const {
  // @@protoc_insertion_point(field_get:ISeeMap.region)
  return _internal_region();
}
inline void ISeeMap::unsafe_arena_set_allocated_region(
    ::ISeeMap_Region* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.region_);
  }
  _impl_.region_ = region;
  if (region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ISeeMap.region)
}
inline ::ISeeMap_Region* ISeeMap::release_region() {
  
  ::ISeeMap_Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ISeeMap_Region* ISeeMap::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:ISeeMap.region)
  
  ::ISeeMap_Region* temp = _impl_.region_;
  _impl_.region_ = nullptr;
  return temp;
}
inline ::ISeeMap_Region* ISeeMap::_internal_mutable_region() {
  
  if (_impl_.region_ == nullptr) {
    auto* p = CreateMaybeMessage<::ISeeMap_Region>(GetArenaForAllocation());
    _impl_.region_ = p;
  }
  return _impl_.region_;
}
inline ::ISeeMap_Region* ISeeMap::mutable_region() {
  ::ISeeMap_Region* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:ISeeMap.region)
  return _msg;
}
inline void ISeeMap::set_allocated_region(::ISeeMap_Region* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.region_ = region;
  // @@protoc_insertion_point(field_set_allocated:ISeeMap.region)
}

// repeated .ISeeMap.Area areaList = 2;
inline int ISeeMap::_internal_arealist_size() const {
  return _impl_.arealist_.size();
}
inline int ISeeMap::arealist_size() const {
  return _internal_arealist_size();
}
inline void ISeeMap::clear_arealist() {
  _impl_.arealist_.Clear();
}
inline ::ISeeMap_Area* ISeeMap::mutable_arealist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.areaList)
  return _impl_.arealist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Area >*
ISeeMap::mutable_arealist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.areaList)
  return &_impl_.arealist_;
}
inline const ::ISeeMap_Area& ISeeMap::_internal_arealist(int index) const {
  return _impl_.arealist_.Get(index);
}
inline const ::ISeeMap_Area& ISeeMap::arealist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.areaList)
  return _internal_arealist(index);
}
inline ::ISeeMap_Area* ISeeMap::_internal_add_arealist() {
  return _impl_.arealist_.Add();
}
inline ::ISeeMap_Area* ISeeMap::add_arealist() {
  ::ISeeMap_Area* _add = _internal_add_arealist();
  // @@protoc_insertion_point(field_add:ISeeMap.areaList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Area >&
ISeeMap::arealist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.areaList)
  return _impl_.arealist_;
}

// repeated .ISeeMap.Path pathList = 3;
inline int ISeeMap::_internal_pathlist_size() const {
  return _impl_.pathlist_.size();
}
inline int ISeeMap::pathlist_size() const {
  return _internal_pathlist_size();
}
inline void ISeeMap::clear_pathlist() {
  _impl_.pathlist_.Clear();
}
inline ::ISeeMap_Path* ISeeMap::mutable_pathlist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.pathList)
  return _impl_.pathlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Path >*
ISeeMap::mutable_pathlist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.pathList)
  return &_impl_.pathlist_;
}
inline const ::ISeeMap_Path& ISeeMap::_internal_pathlist(int index) const {
  return _impl_.pathlist_.Get(index);
}
inline const ::ISeeMap_Path& ISeeMap::pathlist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.pathList)
  return _internal_pathlist(index);
}
inline ::ISeeMap_Path* ISeeMap::_internal_add_pathlist() {
  return _impl_.pathlist_.Add();
}
inline ::ISeeMap_Path* ISeeMap::add_pathlist() {
  ::ISeeMap_Path* _add = _internal_add_pathlist();
  // @@protoc_insertion_point(field_add:ISeeMap.pathList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Path >&
ISeeMap::pathlist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.pathList)
  return _impl_.pathlist_;
}

// repeated .ISeeMap.Station stationList = 4;
inline int ISeeMap::_internal_stationlist_size() const {
  return _impl_.stationlist_.size();
}
inline int ISeeMap::stationlist_size() const {
  return _internal_stationlist_size();
}
inline void ISeeMap::clear_stationlist() {
  _impl_.stationlist_.Clear();
}
inline ::ISeeMap_Station* ISeeMap::mutable_stationlist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.stationList)
  return _impl_.stationlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Station >*
ISeeMap::mutable_stationlist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.stationList)
  return &_impl_.stationlist_;
}
inline const ::ISeeMap_Station& ISeeMap::_internal_stationlist(int index) const {
  return _impl_.stationlist_.Get(index);
}
inline const ::ISeeMap_Station& ISeeMap::stationlist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.stationList)
  return _internal_stationlist(index);
}
inline ::ISeeMap_Station* ISeeMap::_internal_add_stationlist() {
  return _impl_.stationlist_.Add();
}
inline ::ISeeMap_Station* ISeeMap::add_stationlist() {
  ::ISeeMap_Station* _add = _internal_add_stationlist();
  // @@protoc_insertion_point(field_add:ISeeMap.stationList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Station >&
ISeeMap::stationlist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.stationList)
  return _impl_.stationlist_;
}

// repeated .ISeeMap.Configuration configurationList = 5;
inline int ISeeMap::_internal_configurationlist_size() const {
  return _impl_.configurationlist_.size();
}
inline int ISeeMap::configurationlist_size() const {
  return _internal_configurationlist_size();
}
inline void ISeeMap::clear_configurationlist() {
  _impl_.configurationlist_.Clear();
}
inline ::ISeeMap_Configuration* ISeeMap::mutable_configurationlist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.configurationList)
  return _impl_.configurationlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Configuration >*
ISeeMap::mutable_configurationlist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.configurationList)
  return &_impl_.configurationlist_;
}
inline const ::ISeeMap_Configuration& ISeeMap::_internal_configurationlist(int index) const {
  return _impl_.configurationlist_.Get(index);
}
inline const ::ISeeMap_Configuration& ISeeMap::configurationlist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.configurationList)
  return _internal_configurationlist(index);
}
inline ::ISeeMap_Configuration* ISeeMap::_internal_add_configurationlist() {
  return _impl_.configurationlist_.Add();
}
inline ::ISeeMap_Configuration* ISeeMap::add_configurationlist() {
  ::ISeeMap_Configuration* _add = _internal_add_configurationlist();
  // @@protoc_insertion_point(field_add:ISeeMap.configurationList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_Configuration >&
ISeeMap::configurationlist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.configurationList)
  return _impl_.configurationlist_;
}

// repeated .ISeeMap.TaskAction taskActionList = 6;
inline int ISeeMap::_internal_taskactionlist_size() const {
  return _impl_.taskactionlist_.size();
}
inline int ISeeMap::taskactionlist_size() const {
  return _internal_taskactionlist_size();
}
inline void ISeeMap::clear_taskactionlist() {
  _impl_.taskactionlist_.Clear();
}
inline ::ISeeMap_TaskAction* ISeeMap::mutable_taskactionlist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.taskActionList)
  return _impl_.taskactionlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_TaskAction >*
ISeeMap::mutable_taskactionlist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.taskActionList)
  return &_impl_.taskactionlist_;
}
inline const ::ISeeMap_TaskAction& ISeeMap::_internal_taskactionlist(int index) const {
  return _impl_.taskactionlist_.Get(index);
}
inline const ::ISeeMap_TaskAction& ISeeMap::taskactionlist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.taskActionList)
  return _internal_taskactionlist(index);
}
inline ::ISeeMap_TaskAction* ISeeMap::_internal_add_taskactionlist() {
  return _impl_.taskactionlist_.Add();
}
inline ::ISeeMap_TaskAction* ISeeMap::add_taskactionlist() {
  ::ISeeMap_TaskAction* _add = _internal_add_taskactionlist();
  // @@protoc_insertion_point(field_add:ISeeMap.taskActionList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_TaskAction >&
ISeeMap::taskactionlist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.taskActionList)
  return _impl_.taskactionlist_;
}

// repeated .ISeeMap.CarManagemet carMngList = 7;
inline int ISeeMap::_internal_carmnglist_size() const {
  return _impl_.carmnglist_.size();
}
inline int ISeeMap::carmnglist_size() const {
  return _internal_carmnglist_size();
}
inline void ISeeMap::clear_carmnglist() {
  _impl_.carmnglist_.Clear();
}
inline ::ISeeMap_CarManagemet* ISeeMap::mutable_carmnglist(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.carMngList)
  return _impl_.carmnglist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CarManagemet >*
ISeeMap::mutable_carmnglist() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.carMngList)
  return &_impl_.carmnglist_;
}
inline const ::ISeeMap_CarManagemet& ISeeMap::_internal_carmnglist(int index) const {
  return _impl_.carmnglist_.Get(index);
}
inline const ::ISeeMap_CarManagemet& ISeeMap::carmnglist(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.carMngList)
  return _internal_carmnglist(index);
}
inline ::ISeeMap_CarManagemet* ISeeMap::_internal_add_carmnglist() {
  return _impl_.carmnglist_.Add();
}
inline ::ISeeMap_CarManagemet* ISeeMap::add_carmnglist() {
  ::ISeeMap_CarManagemet* _add = _internal_add_carmnglist();
  // @@protoc_insertion_point(field_add:ISeeMap.carMngList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CarManagemet >&
ISeeMap::carmnglist() const {
  // @@protoc_insertion_point(field_list:ISeeMap.carMngList)
  return _impl_.carmnglist_;
}

// repeated .ISeeMap.CoordOffset coordOffset = 8;
inline int ISeeMap::_internal_coordoffset_size() const {
  return _impl_.coordoffset_.size();
}
inline int ISeeMap::coordoffset_size() const {
  return _internal_coordoffset_size();
}
inline void ISeeMap::clear_coordoffset() {
  _impl_.coordoffset_.Clear();
}
inline ::ISeeMap_CoordOffset* ISeeMap::mutable_coordoffset(int index) {
  // @@protoc_insertion_point(field_mutable:ISeeMap.coordOffset)
  return _impl_.coordoffset_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CoordOffset >*
ISeeMap::mutable_coordoffset() {
  // @@protoc_insertion_point(field_mutable_list:ISeeMap.coordOffset)
  return &_impl_.coordoffset_;
}
inline const ::ISeeMap_CoordOffset& ISeeMap::_internal_coordoffset(int index) const {
  return _impl_.coordoffset_.Get(index);
}
inline const ::ISeeMap_CoordOffset& ISeeMap::coordoffset(int index) const {
  // @@protoc_insertion_point(field_get:ISeeMap.coordOffset)
  return _internal_coordoffset(index);
}
inline ::ISeeMap_CoordOffset* ISeeMap::_internal_add_coordoffset() {
  return _impl_.coordoffset_.Add();
}
inline ::ISeeMap_CoordOffset* ISeeMap::add_coordoffset() {
  ::ISeeMap_CoordOffset* _add = _internal_add_coordoffset();
  // @@protoc_insertion_point(field_add:ISeeMap.coordOffset)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ISeeMap_CoordOffset >&
ISeeMap::coordoffset() const {
  // @@protoc_insertion_point(field_list:ISeeMap.coordOffset)
  return _impl_.coordoffset_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_camel_2ddb_2eproto
