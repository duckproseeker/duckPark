// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: camel-grpc.proto
#ifndef GRPC_camel_2dgrpc_2eproto__INCLUDED
#define GRPC_camel_2dgrpc_2eproto__INCLUDED

#include "camel-grpc.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

// 将agv内部数据提供给外部grpc调用者
class AgvService final {
 public:
  static constexpr char const* service_full_name() {
    return "AgvService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // UploadMapData为上传区域数据
    // 客户端传入区域数据流
    // 服务端传出是否成功
    virtual ::grpc::Status UploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncUploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncUploadMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncUploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncUploadMapDataRaw(context, request, cq));
    }
    // 获取当前得版本信息
    // 客户端传入空值
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::Version* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Version>> AsyncGetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Version>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Version>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Version>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // 客户端传入空值
    // 服务端传出AGV状态
    virtual ::grpc::Status GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::AgvInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>> AsyncGetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>>(AsyncGetAgvStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>> PrepareAsyncGetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>>(PrepareAsyncGetAgvStateRaw(context, request, cq));
    }
    // UI向Camel请求配置信息
    virtual ::grpc::Status RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::UIConfig* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>> AsyncRequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>>(AsyncRequestUIConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>> PrepareAsyncRequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>>(PrepareAsyncRequestUIConfigRaw(context, request, cq));
    }
    // 获取系统信息
    virtual ::grpc::Status GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::SystemStatus* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>> AsyncGetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>>(AsyncGetSystemStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>> PrepareAsyncGetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>>(PrepareAsyncGetSystemStatusRaw(context, request, cq));
    }
    // 客户端获取AGVS中得信息.
    // 服务端返回CamelMessage 其中只有 
    virtual ::grpc::Status GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::CamelSysInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>> AsyncGetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>>(AsyncGetAgvStateInAgvsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>> PrepareAsyncGetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>>(PrepareAsyncGetAgvStateInAgvsRaw(context, request, cq));
    }
    // 客户端传入上位机得CamelMessage 其中只用 RequestToAgvs.
    // 返回是否有异常信息
    virtual ::grpc::Status SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSendToAgvsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSendToAgvsRaw(context, request, cq));
    }
    // 客户端传入AGV得一些操作.
    // 返回是否有异常
    virtual ::grpc::Status ControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncControlAgvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncControlAgvRaw(context, request, cq));
    }
    // 设置camel的配置项
    // 服务端传出是否成功
    virtual ::grpc::Status SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSetCamelCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSetCamelCfgRaw(context, request, cq));
    }
    // 客户端传空值
    // 服务端传出camel的配置信息
    virtual ::grpc::Status GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::CamelCfg* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>> AsyncGetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>>(AsyncGetCamelCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>> PrepareAsyncGetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>>(PrepareAsyncGetCamelCfgRaw(context, request, cq));
    }
    // 获取Camel中所有的路径
    virtual ::grpc::Status GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::PathCollection* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>> AsyncGetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>>(AsyncGetCamelPathCollectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>> PrepareAsyncGetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>>(PrepareAsyncGetCamelPathCollectionRaw(context, request, cq));
    }
    // 客户端模拟任务发布
    virtual ::grpc::Status RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncRoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncRoutePlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncRoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncRoutePlanRaw(context, request, cq));
    }
    // 获取所有节点的配置信息
    virtual ::grpc::Status GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::RosNodesCfg* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>> AsyncGetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>>(AsyncGetRosNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>> PrepareAsyncGetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>>(PrepareAsyncGetRosNodeCfgRaw(context, request, cq));
    }
    // 返回设置单个节点的配置信息
    virtual ::grpc::Status SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSetRosNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSetRosNodeCfgRaw(context, request, cq));
    }
    // 删除单个节点
    // master节点不允许删除
    virtual ::grpc::Status DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncDeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncDeleteNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncDeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncDeleteNodeCfgRaw(context, request, cq));
    }
    // 停止单个节点
    virtual ::grpc::Status StopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncStopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncStopRosnodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncStopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncStopRosnodeRaw(context, request, cq));
    }
    // 获取rosout输出的所有信息，保存一百条
    virtual ::grpc::Status GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::RosoutMsg* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>> AsyncGetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>>(AsyncGetRosoutMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>> PrepareAsyncGetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>>(PrepareAsyncGetRosoutMsgRaw(context, request, cq));
    }
    // 设置避障区域
    virtual ::grpc::Status SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncSetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncSetAvoidanceAreaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncSetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncSetAvoidanceAreaRaw(context, request, cq));
    }
    // 日志导出
    virtual ::grpc::Status LogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::LogResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>> AsyncLogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>>(AsyncLogExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>> PrepareAsyncLogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>>(PrepareAsyncLogExportRaw(context, request, cq));
    }
    // 上报报警给Camel
    // cleared: true(清除)/false(新增)
    virtual ::grpc::Status AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncAlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncAlarmUploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncAlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncAlarmUploadRaw(context, request, cq));
    }
    // 查询网络信息
    virtual ::grpc::Status QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::NetworkConfigCollection* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>> AsyncQueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>>(AsyncQueryNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>> PrepareAsyncQueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>>(PrepareAsyncQueryNetworkInformationRaw(context, request, cq));
    }
    // 设置网络
    virtual ::grpc::Status SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncSetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncSetNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncSetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncSetNetworkInformationRaw(context, request, cq));
    }
    // 搜索WIFI列表
    virtual ::grpc::Status SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::WLANList* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>> AsyncSearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>>(AsyncSearchWLANListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>> PrepareAsyncSearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>>(PrepareAsyncSearchWLANListRaw(context, request, cq));
    }
    // 连接WIFI
    virtual ::grpc::Status ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncConnectWLANRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncConnectWLANRaw(context, request, cq));
    }
    // 软件升级（Result: Code -> 0 成功, Message-> 非零时的错误消息）
    // 若成功则会在5s后重启电脑！！！
    virtual ::grpc::Status SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSoftwareUpgradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSoftwareUpgradeRaw(context, request, cq));
    }
    // 软件备份
    virtual ::grpc::Status SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSoftwareBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSoftwareBackupRaw(context, request, cq));
    }
    // 软件还原
    virtual ::grpc::Status SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSoftwareRollbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSoftwareRollbackRaw(context, request, cq));
    }
    // 版本回退（Result: Code -> 0 成功, Message-> 非零时的错误消息）
    // 若成功则会在5s后重启电脑！！！
    virtual ::grpc::Status SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncSoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncSoftwareDowngradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncSoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncSoftwareDowngradeRaw(context, request, cq));
    }
    // 模拟手柄控制小车
    virtual ::grpc::Status StickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncStickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncStickControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncStickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncStickControlRaw(context, request, cq));
    }
    // 申请手柄控制
    virtual ::grpc::Status ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::Token* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Token>> AsyncApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Token>>(AsyncApplyStickControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Token>> PrepareAsyncApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Token>>(PrepareAsyncApplyStickControlRaw(context, request, cq));
    }
    // 设置匹配点
    virtual ::grpc::Status ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncModifyMatchPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncModifyMatchPointRaw(context, request, cq));
    }
    // 获取匹配点
    virtual ::grpc::Status GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::MatchPoints* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>> AsyncGetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>>(AsyncGetMatchPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>> PrepareAsyncGetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>>(PrepareAsyncGetMatchPointRaw(context, request, cq));
    }
    // 重启小车
    virtual ::grpc::Status CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> AsyncCarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(AsyncCarRestartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>> PrepareAsyncCarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>>(PrepareAsyncCarRestartRaw(context, request, cq));
    }
    // 更新站点坐标
    virtual ::grpc::Status UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::UpdatePose* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>> AsyncUpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>>(AsyncUpdateStationPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>> PrepareAsyncUpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>>(PrepareAsyncUpdateStationPoseRaw(context, request, cq));
    }
    // 任务点配置
    virtual ::grpc::Status TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::GrpcTaskAllocations* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>> AsyncTaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>>(AsyncTaskAllocationOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>> PrepareAsyncTaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>>(PrepareAsyncTaskAllocationOperationRaw(context, request, cq));
    }
    // 重置任务列表
    virtual ::grpc::Status AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::Result* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> AsyncAssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(AsyncAssignAllocationTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>> PrepareAsyncAssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Result>>(PrepareAsyncAssignAllocationTasksRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // UploadMapData为上传区域数据
      // 客户端传入区域数据流
      // 服务端传出是否成功
      virtual void UploadMapData(::grpc::ClientContext* context, const ::ISeeMap* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UploadMapData(::grpc::ClientContext* context, const ::ISeeMap* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取当前得版本信息
      // 客户端传入空值
      virtual void GetVersion(::grpc::ClientContext* context, const ::ISeeMap* request, ::Version* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetVersion(::grpc::ClientContext* context, const ::ISeeMap* request, ::Version* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端传入空值
      // 服务端传出AGV状态
      virtual void GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // UI向Camel请求配置信息
      virtual void RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取系统信息
      virtual void GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端获取AGVS中得信息.
      // 服务端返回CamelMessage 其中只有 
      virtual void GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端传入上位机得CamelMessage 其中只用 RequestToAgvs.
      // 返回是否有异常信息
      virtual void SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端传入AGV得一些操作.
      // 返回是否有异常
      virtual void ControlAgv(::grpc::ClientContext* context, const ::Operation* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ControlAgv(::grpc::ClientContext* context, const ::Operation* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 设置camel的配置项
      // 服务端传出是否成功
      virtual void SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端传空值
      // 服务端传出camel的配置信息
      virtual void GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取Camel中所有的路径
      virtual void GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 客户端模拟任务发布
      virtual void RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取所有节点的配置信息
      virtual void GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 返回设置单个节点的配置信息
      virtual void SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 删除单个节点
      // master节点不允许删除
      virtual void DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 停止单个节点
      virtual void StopRosnode(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopRosnode(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取rosout输出的所有信息，保存一百条
      virtual void GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 设置避障区域
      virtual void SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 日志导出
      virtual void LogExport(::grpc::ClientContext* context, const ::LogRequest* request, ::LogResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LogExport(::grpc::ClientContext* context, const ::LogRequest* request, ::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 上报报警给Camel
      // cleared: true(清除)/false(新增)
      virtual void AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 查询网络信息
      virtual void QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response, std::function<void(::grpc::Status)>) = 0;
      virtual void QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 设置网络
      virtual void SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 搜索WIFI列表
      virtual void SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::WLANList* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::WLANList* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 连接WIFI
      virtual void ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 软件升级（Result: Code -> 0 成功, Message-> 非零时的错误消息）
      // 若成功则会在5s后重启电脑！！！
      virtual void SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 软件备份
      virtual void SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 软件还原
      virtual void SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 版本回退（Result: Code -> 0 成功, Message-> 非零时的错误消息）
      // 若成功则会在5s后重启电脑！！！
      virtual void SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 模拟手柄控制小车
      virtual void StickControl(::grpc::ClientContext* context, const ::Gamepad* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StickControl(::grpc::ClientContext* context, const ::Gamepad* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 申请手柄控制
      virtual void ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl* request, ::Token* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl* request, ::Token* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 设置匹配点
      virtual void ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 获取匹配点
      virtual void GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 重启小车
      virtual void CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 更新站点坐标
      virtual void UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation* request, ::UpdatePose* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation* request, ::UpdatePose* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 任务点配置
      virtual void TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // 重置任务列表
      virtual void AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations* request, ::Result* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncUploadMapDataRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncUploadMapDataRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Version>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Version>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>* AsyncGetAgvStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::AgvInfo>* PrepareAsyncGetAgvStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>* AsyncRequestUIConfigRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UIConfig>* PrepareAsyncRequestUIConfigRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>* AsyncGetSystemStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::SystemStatus>* PrepareAsyncGetSystemStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>* AsyncGetAgvStateInAgvsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CamelSysInfo>* PrepareAsyncGetAgvStateInAgvsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSendToAgvsRaw(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSendToAgvsRaw(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncControlAgvRaw(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncControlAgvRaw(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSetCamelCfgRaw(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSetCamelCfgRaw(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>* AsyncGetCamelCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::CamelCfg>* PrepareAsyncGetCamelCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>* AsyncGetCamelPathCollectionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PathCollection>* PrepareAsyncGetCamelPathCollectionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncRoutePlanRaw(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncRoutePlanRaw(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>* AsyncGetRosNodeCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RosNodesCfg>* PrepareAsyncGetRosNodeCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSetRosNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSetRosNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncDeleteNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncDeleteNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncStopRosnodeRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncStopRosnodeRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>* AsyncGetRosoutMsgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RosoutMsg>* PrepareAsyncGetRosoutMsgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncSetAvoidanceAreaRaw(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncSetAvoidanceAreaRaw(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>* AsyncLogExportRaw(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::LogResponse>* PrepareAsyncLogExportRaw(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncAlarmUploadRaw(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncAlarmUploadRaw(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>* AsyncQueryNetworkInformationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::NetworkConfigCollection>* PrepareAsyncQueryNetworkInformationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncSetNetworkInformationRaw(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncSetNetworkInformationRaw(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>* AsyncSearchWLANListRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::WLANList>* PrepareAsyncSearchWLANListRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncConnectWLANRaw(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncConnectWLANRaw(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSoftwareUpgradeRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSoftwareUpgradeRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSoftwareBackupRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSoftwareBackupRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSoftwareRollbackRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSoftwareRollbackRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncSoftwareDowngradeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncSoftwareDowngradeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncStickControlRaw(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncStickControlRaw(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Token>* AsyncApplyStickControlRaw(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Token>* PrepareAsyncApplyStickControlRaw(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncModifyMatchPointRaw(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncModifyMatchPointRaw(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>* AsyncGetMatchPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::MatchPoints>* PrepareAsyncGetMatchPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* AsyncCarRestartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::google::protobuf::Empty>* PrepareAsyncCarRestartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>* AsyncUpdateStationPoseRaw(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::UpdatePose>* PrepareAsyncUpdateStationPoseRaw(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>* AsyncTaskAllocationOperationRaw(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::GrpcTaskAllocations>* PrepareAsyncTaskAllocationOperationRaw(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* AsyncAssignAllocationTasksRaw(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Result>* PrepareAsyncAssignAllocationTasksRaw(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status UploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncUploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncUploadMapDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncUploadMapData(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncUploadMapDataRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::Version* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Version>> AsyncGetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Version>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Version>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Version>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::AgvInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AgvInfo>> AsyncGetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AgvInfo>>(AsyncGetAgvStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AgvInfo>> PrepareAsyncGetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::AgvInfo>>(PrepareAsyncGetAgvStateRaw(context, request, cq));
    }
    ::grpc::Status RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::UIConfig* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UIConfig>> AsyncRequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UIConfig>>(AsyncRequestUIConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UIConfig>> PrepareAsyncRequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UIConfig>>(PrepareAsyncRequestUIConfigRaw(context, request, cq));
    }
    ::grpc::Status GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::SystemStatus* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SystemStatus>> AsyncGetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SystemStatus>>(AsyncGetSystemStatusRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SystemStatus>> PrepareAsyncGetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::SystemStatus>>(PrepareAsyncGetSystemStatusRaw(context, request, cq));
    }
    ::grpc::Status GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::CamelSysInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>> AsyncGetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>>(AsyncGetAgvStateInAgvsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>> PrepareAsyncGetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>>(PrepareAsyncGetAgvStateInAgvsRaw(context, request, cq));
    }
    ::grpc::Status SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSendToAgvsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSendToAgvs(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSendToAgvsRaw(context, request, cq));
    }
    ::grpc::Status ControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncControlAgvRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncControlAgv(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncControlAgvRaw(context, request, cq));
    }
    ::grpc::Status SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSetCamelCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSetCamelCfgRaw(context, request, cq));
    }
    ::grpc::Status GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::CamelCfg* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelCfg>> AsyncGetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelCfg>>(AsyncGetCamelCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelCfg>> PrepareAsyncGetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::CamelCfg>>(PrepareAsyncGetCamelCfgRaw(context, request, cq));
    }
    ::grpc::Status GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::PathCollection* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PathCollection>> AsyncGetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PathCollection>>(AsyncGetCamelPathCollectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PathCollection>> PrepareAsyncGetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PathCollection>>(PrepareAsyncGetCamelPathCollectionRaw(context, request, cq));
    }
    ::grpc::Status RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncRoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncRoutePlanRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncRoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncRoutePlanRaw(context, request, cq));
    }
    ::grpc::Status GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::RosNodesCfg* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>> AsyncGetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>>(AsyncGetRosNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>> PrepareAsyncGetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>>(PrepareAsyncGetRosNodeCfgRaw(context, request, cq));
    }
    ::grpc::Status SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSetRosNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSetRosNodeCfgRaw(context, request, cq));
    }
    ::grpc::Status DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncDeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncDeleteNodeCfgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncDeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncDeleteNodeCfgRaw(context, request, cq));
    }
    ::grpc::Status StopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncStopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncStopRosnodeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncStopRosnode(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncStopRosnodeRaw(context, request, cq));
    }
    ::grpc::Status GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::RosoutMsg* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosoutMsg>> AsyncGetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosoutMsg>>(AsyncGetRosoutMsgRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosoutMsg>> PrepareAsyncGetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RosoutMsg>>(PrepareAsyncGetRosoutMsgRaw(context, request, cq));
    }
    ::grpc::Status SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncSetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncSetAvoidanceAreaRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncSetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncSetAvoidanceAreaRaw(context, request, cq));
    }
    ::grpc::Status LogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::LogResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LogResponse>> AsyncLogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LogResponse>>(AsyncLogExportRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LogResponse>> PrepareAsyncLogExport(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::LogResponse>>(PrepareAsyncLogExportRaw(context, request, cq));
    }
    ::grpc::Status AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncAlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncAlarmUploadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncAlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncAlarmUploadRaw(context, request, cq));
    }
    ::grpc::Status QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::NetworkConfigCollection* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>> AsyncQueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>>(AsyncQueryNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>> PrepareAsyncQueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>>(PrepareAsyncQueryNetworkInformationRaw(context, request, cq));
    }
    ::grpc::Status SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncSetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncSetNetworkInformationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncSetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncSetNetworkInformationRaw(context, request, cq));
    }
    ::grpc::Status SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::WLANList* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::WLANList>> AsyncSearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::WLANList>>(AsyncSearchWLANListRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::WLANList>> PrepareAsyncSearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::WLANList>>(PrepareAsyncSearchWLANListRaw(context, request, cq));
    }
    ::grpc::Status ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncConnectWLANRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncConnectWLANRaw(context, request, cq));
    }
    ::grpc::Status SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSoftwareUpgradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSoftwareUpgradeRaw(context, request, cq));
    }
    ::grpc::Status SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSoftwareBackupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSoftwareBackupRaw(context, request, cq));
    }
    ::grpc::Status SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSoftwareRollbackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSoftwareRollback(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSoftwareRollbackRaw(context, request, cq));
    }
    ::grpc::Status SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncSoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncSoftwareDowngradeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncSoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncSoftwareDowngradeRaw(context, request, cq));
    }
    ::grpc::Status StickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncStickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncStickControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncStickControl(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncStickControlRaw(context, request, cq));
    }
    ::grpc::Status ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::Token* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Token>> AsyncApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Token>>(AsyncApplyStickControlRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Token>> PrepareAsyncApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Token>>(PrepareAsyncApplyStickControlRaw(context, request, cq));
    }
    ::grpc::Status ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncModifyMatchPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncModifyMatchPointRaw(context, request, cq));
    }
    ::grpc::Status GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::MatchPoints* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MatchPoints>> AsyncGetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MatchPoints>>(AsyncGetMatchPointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MatchPoints>> PrepareAsyncGetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::MatchPoints>>(PrepareAsyncGetMatchPointRaw(context, request, cq));
    }
    ::grpc::Status CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::google::protobuf::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> AsyncCarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(AsyncCarRestartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>> PrepareAsyncCarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>>(PrepareAsyncCarRestartRaw(context, request, cq));
    }
    ::grpc::Status UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::UpdatePose* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UpdatePose>> AsyncUpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UpdatePose>>(AsyncUpdateStationPoseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UpdatePose>> PrepareAsyncUpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::UpdatePose>>(PrepareAsyncUpdateStationPoseRaw(context, request, cq));
    }
    ::grpc::Status TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::GrpcTaskAllocations* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>> AsyncTaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>>(AsyncTaskAllocationOperationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>> PrepareAsyncTaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>>(PrepareAsyncTaskAllocationOperationRaw(context, request, cq));
    }
    ::grpc::Status AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::Result* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> AsyncAssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(AsyncAssignAllocationTasksRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>> PrepareAsyncAssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Result>>(PrepareAsyncAssignAllocationTasksRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void UploadMapData(::grpc::ClientContext* context, const ::ISeeMap* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void UploadMapData(::grpc::ClientContext* context, const ::ISeeMap* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetVersion(::grpc::ClientContext* context, const ::ISeeMap* request, ::Version* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::ISeeMap* request, ::Version* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response, std::function<void(::grpc::Status)>) override;
      void GetAgvState(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response, std::function<void(::grpc::Status)>) override;
      void RequestUIConfig(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response, std::function<void(::grpc::Status)>) override;
      void GetSystemStatus(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response, std::function<void(::grpc::Status)>) override;
      void GetAgvStateInAgvs(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SendToAgvs(::grpc::ClientContext* context, const ::CamelMessage* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ControlAgv(::grpc::ClientContext* context, const ::Operation* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void ControlAgv(::grpc::ClientContext* context, const ::Operation* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SetCamelCfg(::grpc::ClientContext* context, const ::CamelCfg* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response, std::function<void(::grpc::Status)>) override;
      void GetCamelCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response, std::function<void(::grpc::Status)>) override;
      void GetCamelPathCollection(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void RoutePlan(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response, std::function<void(::grpc::Status)>) override;
      void GetRosNodeCfg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SetRosNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void DeleteNodeCfg(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopRosnode(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void StopRosnode(::grpc::ClientContext* context, const ::RosNode* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response, std::function<void(::grpc::Status)>) override;
      void GetRosoutMsg(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetAvoidanceArea(::grpc::ClientContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LogExport(::grpc::ClientContext* context, const ::LogRequest* request, ::LogResponse* response, std::function<void(::grpc::Status)>) override;
      void LogExport(::grpc::ClientContext* context, const ::LogRequest* request, ::LogResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void AlarmUpload(::grpc::ClientContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response, std::function<void(::grpc::Status)>) override;
      void QueryNetworkInformation(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void SetNetworkInformation(::grpc::ClientContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::WLANList* response, std::function<void(::grpc::Status)>) override;
      void SearchWLANList(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::WLANList* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void ConnectWLAN(::grpc::ClientContext* context, const ::WirlessConfig* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SoftwareUpgrade(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SoftwareBackup(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SoftwareRollback(::grpc::ClientContext* context, const ::InstallPack* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void SoftwareDowngrade(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StickControl(::grpc::ClientContext* context, const ::Gamepad* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void StickControl(::grpc::ClientContext* context, const ::Gamepad* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl* request, ::Token* response, std::function<void(::grpc::Status)>) override;
      void ApplyStickControl(::grpc::ClientContext* context, const ::GamepadControl* request, ::Token* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void ModifyMatchPoint(::grpc::ClientContext* context, const ::MatchPointCommand* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response, std::function<void(::grpc::Status)>) override;
      void GetMatchPoint(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, std::function<void(::grpc::Status)>) override;
      void CarRestart(::grpc::ClientContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation* request, ::UpdatePose* response, std::function<void(::grpc::Status)>) override;
      void UpdateStationPose(::grpc::ClientContext* context, const ::UpdateStation* request, ::UpdatePose* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response, std::function<void(::grpc::Status)>) override;
      void TaskAllocationOperation(::grpc::ClientContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations* request, ::Result* response, std::function<void(::grpc::Status)>) override;
      void AssignAllocationTasks(::grpc::ClientContext* context, const ::GrpcTaskAllocations* request, ::Result* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncUploadMapDataRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncUploadMapDataRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Version>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Version>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::ISeeMap& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AgvInfo>* AsyncGetAgvStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::AgvInfo>* PrepareAsyncGetAgvStateRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UIConfig>* AsyncRequestUIConfigRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UIConfig>* PrepareAsyncRequestUIConfigRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SystemStatus>* AsyncGetSystemStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::SystemStatus>* PrepareAsyncGetSystemStatusRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>* AsyncGetAgvStateInAgvsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CamelSysInfo>* PrepareAsyncGetAgvStateInAgvsRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSendToAgvsRaw(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSendToAgvsRaw(::grpc::ClientContext* context, const ::CamelMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncControlAgvRaw(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncControlAgvRaw(::grpc::ClientContext* context, const ::Operation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSetCamelCfgRaw(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSetCamelCfgRaw(::grpc::ClientContext* context, const ::CamelCfg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CamelCfg>* AsyncGetCamelCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::CamelCfg>* PrepareAsyncGetCamelCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PathCollection>* AsyncGetCamelPathCollectionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PathCollection>* PrepareAsyncGetCamelPathCollectionRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncRoutePlanRaw(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncRoutePlanRaw(::grpc::ClientContext* context, const ::CamelMessage_MissonFromAgvs& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>* AsyncGetRosNodeCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RosNodesCfg>* PrepareAsyncGetRosNodeCfgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSetRosNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSetRosNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncDeleteNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncDeleteNodeCfgRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncStopRosnodeRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncStopRosnodeRaw(::grpc::ClientContext* context, const ::RosNode& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RosoutMsg>* AsyncGetRosoutMsgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RosoutMsg>* PrepareAsyncGetRosoutMsgRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncSetAvoidanceAreaRaw(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncSetAvoidanceAreaRaw(::grpc::ClientContext* context, const ::AvoidanceAreaCollection& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LogResponse>* AsyncLogExportRaw(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::LogResponse>* PrepareAsyncLogExportRaw(::grpc::ClientContext* context, const ::LogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncAlarmUploadRaw(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncAlarmUploadRaw(::grpc::ClientContext* context, const ::AlarmMsg& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>* AsyncQueryNetworkInformationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::NetworkConfigCollection>* PrepareAsyncQueryNetworkInformationRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncSetNetworkInformationRaw(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncSetNetworkInformationRaw(::grpc::ClientContext* context, const ::NetworkConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::WLANList>* AsyncSearchWLANListRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::WLANList>* PrepareAsyncSearchWLANListRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncConnectWLANRaw(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncConnectWLANRaw(::grpc::ClientContext* context, const ::WirlessConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSoftwareUpgradeRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSoftwareUpgradeRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSoftwareBackupRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSoftwareBackupRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSoftwareRollbackRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSoftwareRollbackRaw(::grpc::ClientContext* context, const ::InstallPack& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncSoftwareDowngradeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncSoftwareDowngradeRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncStickControlRaw(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncStickControlRaw(::grpc::ClientContext* context, const ::Gamepad& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Token>* AsyncApplyStickControlRaw(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Token>* PrepareAsyncApplyStickControlRaw(::grpc::ClientContext* context, const ::GamepadControl& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncModifyMatchPointRaw(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncModifyMatchPointRaw(::grpc::ClientContext* context, const ::MatchPointCommand& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MatchPoints>* AsyncGetMatchPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::MatchPoints>* PrepareAsyncGetMatchPointRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* AsyncCarRestartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::google::protobuf::Empty>* PrepareAsyncCarRestartRaw(::grpc::ClientContext* context, const ::google::protobuf::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UpdatePose>* AsyncUpdateStationPoseRaw(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::UpdatePose>* PrepareAsyncUpdateStationPoseRaw(::grpc::ClientContext* context, const ::UpdateStation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>* AsyncTaskAllocationOperationRaw(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::GrpcTaskAllocations>* PrepareAsyncTaskAllocationOperationRaw(::grpc::ClientContext* context, const ::GrpcTaskOperation& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* AsyncAssignAllocationTasksRaw(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Result>* PrepareAsyncAssignAllocationTasksRaw(::grpc::ClientContext* context, const ::GrpcTaskAllocations& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_UploadMapData_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAgvState_;
    const ::grpc::internal::RpcMethod rpcmethod_RequestUIConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSystemStatus_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAgvStateInAgvs_;
    const ::grpc::internal::RpcMethod rpcmethod_SendToAgvs_;
    const ::grpc::internal::RpcMethod rpcmethod_ControlAgv_;
    const ::grpc::internal::RpcMethod rpcmethod_SetCamelCfg_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCamelCfg_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCamelPathCollection_;
    const ::grpc::internal::RpcMethod rpcmethod_RoutePlan_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRosNodeCfg_;
    const ::grpc::internal::RpcMethod rpcmethod_SetRosNodeCfg_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteNodeCfg_;
    const ::grpc::internal::RpcMethod rpcmethod_StopRosnode_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRosoutMsg_;
    const ::grpc::internal::RpcMethod rpcmethod_SetAvoidanceArea_;
    const ::grpc::internal::RpcMethod rpcmethod_LogExport_;
    const ::grpc::internal::RpcMethod rpcmethod_AlarmUpload_;
    const ::grpc::internal::RpcMethod rpcmethod_QueryNetworkInformation_;
    const ::grpc::internal::RpcMethod rpcmethod_SetNetworkInformation_;
    const ::grpc::internal::RpcMethod rpcmethod_SearchWLANList_;
    const ::grpc::internal::RpcMethod rpcmethod_ConnectWLAN_;
    const ::grpc::internal::RpcMethod rpcmethod_SoftwareUpgrade_;
    const ::grpc::internal::RpcMethod rpcmethod_SoftwareBackup_;
    const ::grpc::internal::RpcMethod rpcmethod_SoftwareRollback_;
    const ::grpc::internal::RpcMethod rpcmethod_SoftwareDowngrade_;
    const ::grpc::internal::RpcMethod rpcmethod_StickControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ApplyStickControl_;
    const ::grpc::internal::RpcMethod rpcmethod_ModifyMatchPoint_;
    const ::grpc::internal::RpcMethod rpcmethod_GetMatchPoint_;
    const ::grpc::internal::RpcMethod rpcmethod_CarRestart_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateStationPose_;
    const ::grpc::internal::RpcMethod rpcmethod_TaskAllocationOperation_;
    const ::grpc::internal::RpcMethod rpcmethod_AssignAllocationTasks_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // UploadMapData为上传区域数据
    // 客户端传入区域数据流
    // 服务端传出是否成功
    virtual ::grpc::Status UploadMapData(::grpc::ServerContext* context, const ::ISeeMap* request, ::Result* response);
    // 获取当前得版本信息
    // 客户端传入空值
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::ISeeMap* request, ::Version* response);
    // 客户端传入空值
    // 服务端传出AGV状态
    virtual ::grpc::Status GetAgvState(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response);
    // UI向Camel请求配置信息
    virtual ::grpc::Status RequestUIConfig(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response);
    // 获取系统信息
    virtual ::grpc::Status GetSystemStatus(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response);
    // 客户端获取AGVS中得信息.
    // 服务端返回CamelMessage 其中只有 
    virtual ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response);
    // 客户端传入上位机得CamelMessage 其中只用 RequestToAgvs.
    // 返回是否有异常信息
    virtual ::grpc::Status SendToAgvs(::grpc::ServerContext* context, const ::CamelMessage* request, ::Result* response);
    // 客户端传入AGV得一些操作.
    // 返回是否有异常
    virtual ::grpc::Status ControlAgv(::grpc::ServerContext* context, const ::Operation* request, ::Result* response);
    // 设置camel的配置项
    // 服务端传出是否成功
    virtual ::grpc::Status SetCamelCfg(::grpc::ServerContext* context, const ::CamelCfg* request, ::Result* response);
    // 客户端传空值
    // 服务端传出camel的配置信息
    virtual ::grpc::Status GetCamelCfg(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response);
    // 获取Camel中所有的路径
    virtual ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response);
    // 客户端模拟任务发布
    virtual ::grpc::Status RoutePlan(::grpc::ServerContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response);
    // 获取所有节点的配置信息
    virtual ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response);
    // 返回设置单个节点的配置信息
    virtual ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* context, const ::RosNode* request, ::Result* response);
    // 删除单个节点
    // master节点不允许删除
    virtual ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* context, const ::RosNode* request, ::Result* response);
    // 停止单个节点
    virtual ::grpc::Status StopRosnode(::grpc::ServerContext* context, const ::RosNode* request, ::Result* response);
    // 获取rosout输出的所有信息，保存一百条
    virtual ::grpc::Status GetRosoutMsg(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response);
    // 设置避障区域
    virtual ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response);
    // 日志导出
    virtual ::grpc::Status LogExport(::grpc::ServerContext* context, const ::LogRequest* request, ::LogResponse* response);
    // 上报报警给Camel
    // cleared: true(清除)/false(新增)
    virtual ::grpc::Status AlarmUpload(::grpc::ServerContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response);
    // 查询网络信息
    virtual ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response);
    // 设置网络
    virtual ::grpc::Status SetNetworkInformation(::grpc::ServerContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response);
    // 搜索WIFI列表
    virtual ::grpc::Status SearchWLANList(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::WLANList* response);
    // 连接WIFI
    virtual ::grpc::Status ConnectWLAN(::grpc::ServerContext* context, const ::WirlessConfig* request, ::Result* response);
    // 软件升级（Result: Code -> 0 成功, Message-> 非零时的错误消息）
    // 若成功则会在5s后重启电脑！！！
    virtual ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* context, const ::InstallPack* request, ::Result* response);
    // 软件备份
    virtual ::grpc::Status SoftwareBackup(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::Result* response);
    // 软件还原
    virtual ::grpc::Status SoftwareRollback(::grpc::ServerContext* context, const ::InstallPack* request, ::Result* response);
    // 版本回退（Result: Code -> 0 成功, Message-> 非零时的错误消息）
    // 若成功则会在5s后重启电脑！！！
    virtual ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::Result* response);
    // 模拟手柄控制小车
    virtual ::grpc::Status StickControl(::grpc::ServerContext* context, const ::Gamepad* request, ::Result* response);
    // 申请手柄控制
    virtual ::grpc::Status ApplyStickControl(::grpc::ServerContext* context, const ::GamepadControl* request, ::Token* response);
    // 设置匹配点
    virtual ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* context, const ::MatchPointCommand* request, ::Result* response);
    // 获取匹配点
    virtual ::grpc::Status GetMatchPoint(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response);
    // 重启小车
    virtual ::grpc::Status CarRestart(::grpc::ServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response);
    // 更新站点坐标
    virtual ::grpc::Status UpdateStationPose(::grpc::ServerContext* context, const ::UpdateStation* request, ::UpdatePose* response);
    // 任务点配置
    virtual ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response);
    // 重置任务列表
    virtual ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* context, const ::GrpcTaskAllocations* request, ::Result* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UploadMapData() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadMapData(::grpc::ServerContext* context, ::ISeeMap* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::ISeeMap* request, ::grpc::ServerAsyncResponseWriter< ::Version>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAgvState() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAgvState(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::AgvInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestUIConfig(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::UIConfig>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSystemStatus(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::SystemStatus>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAgvStateInAgvs(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::CamelSysInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToAgvs(::grpc::ServerContext* context, ::CamelMessage* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControlAgv() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlAgv(::grpc::ServerContext* context, ::Operation* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCamelCfg(::grpc::ServerContext* context, ::CamelCfg* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCamelCfg(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::CamelCfg>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCamelPathCollection(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::PathCollection>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RoutePlan() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRoutePlan(::grpc::ServerContext* context, ::CamelMessage_MissonFromAgvs* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRosNodeCfg(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RosNodesCfg>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRosNodeCfg(::grpc::ServerContext* context, ::RosNode* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteNodeCfg(::grpc::ServerContext* context, ::RosNode* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopRosnode() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRosnode(::grpc::ServerContext* context, ::RosNode* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRosoutMsg(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RosoutMsg>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAvoidanceArea(::grpc::ServerContext* context, ::AvoidanceAreaCollection* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LogExport() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogExport(::grpc::ServerContext* context, ::LogRequest* request, ::grpc::ServerAsyncResponseWriter< ::LogResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAlarmUpload(::grpc::ServerContext* context, ::AlarmMsg* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryNetworkInformation(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::NetworkConfigCollection>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetNetworkInformation(::grpc::ServerContext* context, ::NetworkConfig* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSearchWLANList(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::WLANList>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectWLAN(::grpc::ServerContext* context, ::WirlessConfig* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareUpgrade(::grpc::ServerContext* context, ::InstallPack* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareBackup(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareRollback(::grpc::ServerContext* context, ::InstallPack* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareDowngrade(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StickControl() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStickControl(::grpc::ServerContext* context, ::Gamepad* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyStickControl(::grpc::ServerContext* context, ::GamepadControl* request, ::grpc::ServerAsyncResponseWriter< ::Token>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyMatchPoint(::grpc::ServerContext* context, ::MatchPointCommand* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMatchPoint(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::MatchPoints>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CarRestart() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCarRestart(::grpc::ServerContext* context, ::google::protobuf::Empty* request, ::grpc::ServerAsyncResponseWriter< ::google::protobuf::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodAsync(33);
    }
    ~WithAsyncMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStationPose(::grpc::ServerContext* context, ::UpdateStation* request, ::grpc::ServerAsyncResponseWriter< ::UpdatePose>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodAsync(34);
    }
    ~WithAsyncMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskAllocationOperation(::grpc::ServerContext* context, ::GrpcTaskOperation* request, ::grpc::ServerAsyncResponseWriter< ::GrpcTaskAllocations>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodAsync(35);
    }
    ~WithAsyncMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignAllocationTasks(::grpc::ServerContext* context, ::GrpcTaskAllocations* request, ::grpc::ServerAsyncResponseWriter< ::Result>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_UploadMapData<WithAsyncMethod_GetVersion<WithAsyncMethod_GetAgvState<WithAsyncMethod_RequestUIConfig<WithAsyncMethod_GetSystemStatus<WithAsyncMethod_GetAgvStateInAgvs<WithAsyncMethod_SendToAgvs<WithAsyncMethod_ControlAgv<WithAsyncMethod_SetCamelCfg<WithAsyncMethod_GetCamelCfg<WithAsyncMethod_GetCamelPathCollection<WithAsyncMethod_RoutePlan<WithAsyncMethod_GetRosNodeCfg<WithAsyncMethod_SetRosNodeCfg<WithAsyncMethod_DeleteNodeCfg<WithAsyncMethod_StopRosnode<WithAsyncMethod_GetRosoutMsg<WithAsyncMethod_SetAvoidanceArea<WithAsyncMethod_LogExport<WithAsyncMethod_AlarmUpload<WithAsyncMethod_QueryNetworkInformation<WithAsyncMethod_SetNetworkInformation<WithAsyncMethod_SearchWLANList<WithAsyncMethod_ConnectWLAN<WithAsyncMethod_SoftwareUpgrade<WithAsyncMethod_SoftwareBackup<WithAsyncMethod_SoftwareRollback<WithAsyncMethod_SoftwareDowngrade<WithAsyncMethod_StickControl<WithAsyncMethod_ApplyStickControl<WithAsyncMethod_ModifyMatchPoint<WithAsyncMethod_GetMatchPoint<WithAsyncMethod_CarRestart<WithAsyncMethod_UpdateStationPose<WithAsyncMethod_TaskAllocationOperation<WithAsyncMethod_AssignAllocationTasks<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UploadMapData() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::ISeeMap, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ISeeMap* request, ::Result* response) { return this->UploadMapData(context, request, response); }));}
    void SetMessageAllocatorFor_UploadMapData(
        ::grpc::MessageAllocator< ::ISeeMap, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ISeeMap, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::ISeeMap, ::Version>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::ISeeMap* request, ::Version* response) { return this->GetVersion(context, request, response); }));}
    void SetMessageAllocatorFor_GetVersion(
        ::grpc::MessageAllocator< ::ISeeMap, ::Version>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::ISeeMap, ::Version>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAgvState() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::AgvInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::AgvInfo* response) { return this->GetAgvState(context, request, response); }));}
    void SetMessageAllocatorFor_GetAgvState(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::AgvInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::AgvInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAgvState(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::UIConfig>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::UIConfig* response) { return this->RequestUIConfig(context, request, response); }));}
    void SetMessageAllocatorFor_RequestUIConfig(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::UIConfig>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::UIConfig>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestUIConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::SystemStatus>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::SystemStatus* response) { return this->GetSystemStatus(context, request, response); }));}
    void SetMessageAllocatorFor_GetSystemStatus(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::SystemStatus>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::SystemStatus>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSystemStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::CamelSysInfo>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::CamelSysInfo* response) { return this->GetAgvStateInAgvs(context, request, response); }));}
    void SetMessageAllocatorFor_GetAgvStateInAgvs(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::CamelSysInfo>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::CamelSysInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAgvStateInAgvs(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::CamelMessage, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CamelMessage* request, ::Result* response) { return this->SendToAgvs(context, request, response); }));}
    void SetMessageAllocatorFor_SendToAgvs(
        ::grpc::MessageAllocator< ::CamelMessage, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CamelMessage, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendToAgvs(
      ::grpc::CallbackServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ControlAgv() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::Operation, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Operation* request, ::Result* response) { return this->ControlAgv(context, request, response); }));}
    void SetMessageAllocatorFor_ControlAgv(
        ::grpc::MessageAllocator< ::Operation, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Operation, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlAgv(
      ::grpc::CallbackServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::CamelCfg, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CamelCfg* request, ::Result* response) { return this->SetCamelCfg(context, request, response); }));}
    void SetMessageAllocatorFor_SetCamelCfg(
        ::grpc::MessageAllocator< ::CamelCfg, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CamelCfg, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCamelCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::CamelCfg>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::CamelCfg* response) { return this->GetCamelCfg(context, request, response); }));}
    void SetMessageAllocatorFor_GetCamelCfg(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::CamelCfg>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::CamelCfg>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCamelCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::PathCollection>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::PathCollection* response) { return this->GetCamelPathCollection(context, request, response); }));}
    void SetMessageAllocatorFor_GetCamelPathCollection(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::PathCollection>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::PathCollection>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCamelPathCollection(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RoutePlan() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::CamelMessage_MissonFromAgvs, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::CamelMessage_MissonFromAgvs* request, ::google::protobuf::Empty* response) { return this->RoutePlan(context, request, response); }));}
    void SetMessageAllocatorFor_RoutePlan(
        ::grpc::MessageAllocator< ::CamelMessage_MissonFromAgvs, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::CamelMessage_MissonFromAgvs, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RoutePlan(
      ::grpc::CallbackServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::RosNodesCfg>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::RosNodesCfg* response) { return this->GetRosNodeCfg(context, request, response); }));}
    void SetMessageAllocatorFor_GetRosNodeCfg(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::RosNodesCfg>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::RosNodesCfg>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRosNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RosNode* request, ::Result* response) { return this->SetRosNodeCfg(context, request, response); }));}
    void SetMessageAllocatorFor_SetRosNodeCfg(
        ::grpc::MessageAllocator< ::RosNode, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRosNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RosNode* request, ::Result* response) { return this->DeleteNodeCfg(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteNodeCfg(
        ::grpc::MessageAllocator< ::RosNode, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopRosnode() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RosNode* request, ::Result* response) { return this->StopRosnode(context, request, response); }));}
    void SetMessageAllocatorFor_StopRosnode(
        ::grpc::MessageAllocator< ::RosNode, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RosNode, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRosnode(
      ::grpc::CallbackServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::RosoutMsg>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::RosoutMsg* response) { return this->GetRosoutMsg(context, request, response); }));}
    void SetMessageAllocatorFor_GetRosoutMsg(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::RosoutMsg>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::RosoutMsg>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRosoutMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::AvoidanceAreaCollection, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::AvoidanceAreaCollection* request, ::google::protobuf::Empty* response) { return this->SetAvoidanceArea(context, request, response); }));}
    void SetMessageAllocatorFor_SetAvoidanceArea(
        ::grpc::MessageAllocator< ::AvoidanceAreaCollection, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::AvoidanceAreaCollection, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAvoidanceArea(
      ::grpc::CallbackServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LogExport() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::LogRequest, ::LogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::LogRequest* request, ::LogResponse* response) { return this->LogExport(context, request, response); }));}
    void SetMessageAllocatorFor_LogExport(
        ::grpc::MessageAllocator< ::LogRequest, ::LogResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::LogRequest, ::LogResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LogExport(
      ::grpc::CallbackServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::AlarmMsg, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::AlarmMsg* request, ::google::protobuf::Empty* response) { return this->AlarmUpload(context, request, response); }));}
    void SetMessageAllocatorFor_AlarmUpload(
        ::grpc::MessageAllocator< ::AlarmMsg, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::AlarmMsg, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AlarmUpload(
      ::grpc::CallbackServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::NetworkConfigCollection>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::NetworkConfigCollection* response) { return this->QueryNetworkInformation(context, request, response); }));}
    void SetMessageAllocatorFor_QueryNetworkInformation(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::NetworkConfigCollection>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::NetworkConfigCollection>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryNetworkInformation(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::NetworkConfig, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::NetworkConfig* request, ::google::protobuf::Empty* response) { return this->SetNetworkInformation(context, request, response); }));}
    void SetMessageAllocatorFor_SetNetworkInformation(
        ::grpc::MessageAllocator< ::NetworkConfig, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::NetworkConfig, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetNetworkInformation(
      ::grpc::CallbackServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::WLANList>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::WLANList* response) { return this->SearchWLANList(context, request, response); }));}
    void SetMessageAllocatorFor_SearchWLANList(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::WLANList>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::WLANList>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SearchWLANList(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::WirlessConfig, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::WirlessConfig* request, ::Result* response) { return this->ConnectWLAN(context, request, response); }));}
    void SetMessageAllocatorFor_ConnectWLAN(
        ::grpc::MessageAllocator< ::WirlessConfig, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::WirlessConfig, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectWLAN(
      ::grpc::CallbackServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::InstallPack, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::InstallPack* request, ::Result* response) { return this->SoftwareUpgrade(context, request, response); }));}
    void SetMessageAllocatorFor_SoftwareUpgrade(
        ::grpc::MessageAllocator< ::InstallPack, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::InstallPack, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareUpgrade(
      ::grpc::CallbackServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::Result* response) { return this->SoftwareBackup(context, request, response); }));}
    void SetMessageAllocatorFor_SoftwareBackup(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::InstallPack, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::InstallPack* request, ::Result* response) { return this->SoftwareRollback(context, request, response); }));}
    void SetMessageAllocatorFor_SoftwareRollback(
        ::grpc::MessageAllocator< ::InstallPack, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::InstallPack, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareRollback(
      ::grpc::CallbackServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::Result* response) { return this->SoftwareDowngrade(context, request, response); }));}
    void SetMessageAllocatorFor_SoftwareDowngrade(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareDowngrade(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StickControl() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::Gamepad, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::Gamepad* request, ::Result* response) { return this->StickControl(context, request, response); }));}
    void SetMessageAllocatorFor_StickControl(
        ::grpc::MessageAllocator< ::Gamepad, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::Gamepad, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StickControl(
      ::grpc::CallbackServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::GamepadControl, ::Token>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GamepadControl* request, ::Token* response) { return this->ApplyStickControl(context, request, response); }));}
    void SetMessageAllocatorFor_ApplyStickControl(
        ::grpc::MessageAllocator< ::GamepadControl, ::Token>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GamepadControl, ::Token>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyStickControl(
      ::grpc::CallbackServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::MatchPointCommand, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::MatchPointCommand* request, ::Result* response) { return this->ModifyMatchPoint(context, request, response); }));}
    void SetMessageAllocatorFor_ModifyMatchPoint(
        ::grpc::MessageAllocator< ::MatchPointCommand, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::MatchPointCommand, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyMatchPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::MatchPoints>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::MatchPoints* response) { return this->GetMatchPoint(context, request, response); }));}
    void SetMessageAllocatorFor_GetMatchPoint(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::MatchPoints>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(31);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::MatchPoints>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMatchPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CarRestart() {
      ::grpc::Service::MarkMethodCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::google::protobuf::Empty* request, ::google::protobuf::Empty* response) { return this->CarRestart(context, request, response); }));}
    void SetMessageAllocatorFor_CarRestart(
        ::grpc::MessageAllocator< ::google::protobuf::Empty, ::google::protobuf::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(32);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::google::protobuf::Empty, ::google::protobuf::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CarRestart(
      ::grpc::CallbackServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::UpdateStation, ::UpdatePose>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::UpdateStation* request, ::UpdatePose* response) { return this->UpdateStationPose(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateStationPose(
        ::grpc::MessageAllocator< ::UpdateStation, ::UpdatePose>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(33);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::UpdateStation, ::UpdatePose>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateStationPose(
      ::grpc::CallbackServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::GrpcTaskOperation, ::GrpcTaskAllocations>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GrpcTaskOperation* request, ::GrpcTaskAllocations* response) { return this->TaskAllocationOperation(context, request, response); }));}
    void SetMessageAllocatorFor_TaskAllocationOperation(
        ::grpc::MessageAllocator< ::GrpcTaskOperation, ::GrpcTaskAllocations>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(34);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GrpcTaskOperation, ::GrpcTaskAllocations>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskAllocationOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::GrpcTaskAllocations, ::Result>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::GrpcTaskAllocations* request, ::Result* response) { return this->AssignAllocationTasks(context, request, response); }));}
    void SetMessageAllocatorFor_AssignAllocationTasks(
        ::grpc::MessageAllocator< ::GrpcTaskAllocations, ::Result>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(35);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::GrpcTaskAllocations, ::Result>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AssignAllocationTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_UploadMapData<WithCallbackMethod_GetVersion<WithCallbackMethod_GetAgvState<WithCallbackMethod_RequestUIConfig<WithCallbackMethod_GetSystemStatus<WithCallbackMethod_GetAgvStateInAgvs<WithCallbackMethod_SendToAgvs<WithCallbackMethod_ControlAgv<WithCallbackMethod_SetCamelCfg<WithCallbackMethod_GetCamelCfg<WithCallbackMethod_GetCamelPathCollection<WithCallbackMethod_RoutePlan<WithCallbackMethod_GetRosNodeCfg<WithCallbackMethod_SetRosNodeCfg<WithCallbackMethod_DeleteNodeCfg<WithCallbackMethod_StopRosnode<WithCallbackMethod_GetRosoutMsg<WithCallbackMethod_SetAvoidanceArea<WithCallbackMethod_LogExport<WithCallbackMethod_AlarmUpload<WithCallbackMethod_QueryNetworkInformation<WithCallbackMethod_SetNetworkInformation<WithCallbackMethod_SearchWLANList<WithCallbackMethod_ConnectWLAN<WithCallbackMethod_SoftwareUpgrade<WithCallbackMethod_SoftwareBackup<WithCallbackMethod_SoftwareRollback<WithCallbackMethod_SoftwareDowngrade<WithCallbackMethod_StickControl<WithCallbackMethod_ApplyStickControl<WithCallbackMethod_ModifyMatchPoint<WithCallbackMethod_GetMatchPoint<WithCallbackMethod_CarRestart<WithCallbackMethod_UpdateStationPose<WithCallbackMethod_TaskAllocationOperation<WithCallbackMethod_AssignAllocationTasks<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UploadMapData() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAgvState() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControlAgv() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RoutePlan() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopRosnode() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LogExport() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StickControl() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CarRestart() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodGeneric(33);
    }
    ~WithGenericMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodGeneric(34);
    }
    ~WithGenericMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodGeneric(35);
    }
    ~WithGenericMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UploadMapData() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUploadMapData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAgvState() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAgvState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRequestUIConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSystemStatus(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAgvStateInAgvs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendToAgvs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControlAgv() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControlAgv(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetCamelCfg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCamelCfg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCamelPathCollection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RoutePlan() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRoutePlan(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRosNodeCfg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetRosNodeCfg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteNodeCfg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopRosnode() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopRosnode(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRosoutMsg(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetAvoidanceArea(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LogExport() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLogExport(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAlarmUpload(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueryNetworkInformation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetNetworkInformation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSearchWLANList(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConnectWLAN(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareUpgrade(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareBackup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareRollback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSoftwareDowngrade(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StickControl() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStickControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestApplyStickControl(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestModifyMatchPoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMatchPoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(31, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CarRestart() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCarRestart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(32, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodRaw(33);
    }
    ~WithRawMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateStationPose(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(33, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodRaw(34);
    }
    ~WithRawMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTaskAllocationOperation(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(34, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodRaw(35);
    }
    ~WithRawMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAssignAllocationTasks(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(35, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UploadMapData() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UploadMapData(context, request, response); }));
    }
    ~WithRawCallbackMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UploadMapData(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetVersion() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetVersion(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetVersion(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAgvState() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAgvState(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAgvState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RequestUIConfig(context, request, response); }));
    }
    ~WithRawCallbackMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RequestUIConfig(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetSystemStatus(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetSystemStatus(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAgvStateInAgvs(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetAgvStateInAgvs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendToAgvs(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendToAgvs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ControlAgv() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControlAgv(context, request, response); }));
    }
    ~WithRawCallbackMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ControlAgv(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetCamelCfg(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetCamelCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCamelCfg(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCamelCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCamelPathCollection(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCamelPathCollection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RoutePlan() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RoutePlan(context, request, response); }));
    }
    ~WithRawCallbackMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RoutePlan(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRosNodeCfg(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRosNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetRosNodeCfg(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetRosNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteNodeCfg(context, request, response); }));
    }
    ~WithRawCallbackMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DeleteNodeCfg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopRosnode() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopRosnode(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopRosnode(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetRosoutMsg(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetRosoutMsg(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetAvoidanceArea(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetAvoidanceArea(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LogExport() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LogExport(context, request, response); }));
    }
    ~WithRawCallbackMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LogExport(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AlarmUpload(context, request, response); }));
    }
    ~WithRawCallbackMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AlarmUpload(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->QueryNetworkInformation(context, request, response); }));
    }
    ~WithRawCallbackMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* QueryNetworkInformation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetNetworkInformation(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetNetworkInformation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SearchWLANList(context, request, response); }));
    }
    ~WithRawCallbackMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SearchWLANList(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConnectWLAN(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConnectWLAN(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SoftwareUpgrade(context, request, response); }));
    }
    ~WithRawCallbackMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareUpgrade(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SoftwareBackup(context, request, response); }));
    }
    ~WithRawCallbackMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareBackup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SoftwareRollback(context, request, response); }));
    }
    ~WithRawCallbackMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareRollback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SoftwareDowngrade(context, request, response); }));
    }
    ~WithRawCallbackMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SoftwareDowngrade(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StickControl() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StickControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StickControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ApplyStickControl(context, request, response); }));
    }
    ~WithRawCallbackMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ApplyStickControl(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ModifyMatchPoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ModifyMatchPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetMatchPoint(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetMatchPoint(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CarRestart() {
      ::grpc::Service::MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CarRestart(context, request, response); }));
    }
    ~WithRawCallbackMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CarRestart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodRawCallback(33,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateStationPose(context, request, response); }));
    }
    ~WithRawCallbackMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UpdateStationPose(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodRawCallback(34,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TaskAllocationOperation(context, request, response); }));
    }
    ~WithRawCallbackMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TaskAllocationOperation(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodRawCallback(35,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AssignAllocationTasks(context, request, response); }));
    }
    ~WithRawCallbackMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AssignAllocationTasks(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UploadMapData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UploadMapData() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ISeeMap, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ISeeMap, ::Result>* streamer) {
                       return this->StreamedUploadMapData(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UploadMapData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UploadMapData(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUploadMapData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ISeeMap,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::ISeeMap, ::Version>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::ISeeMap, ::Version>* streamer) {
                       return this->StreamedGetVersion(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* /*context*/, const ::ISeeMap* /*request*/, ::Version* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ISeeMap,::Version>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAgvState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAgvState() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::AgvInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::AgvInfo>* streamer) {
                       return this->StreamedGetAgvState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAgvState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAgvState(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::AgvInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAgvState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::AgvInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RequestUIConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RequestUIConfig() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::UIConfig>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::UIConfig>* streamer) {
                       return this->StreamedRequestUIConfig(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RequestUIConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RequestUIConfig(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::UIConfig* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRequestUIConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::UIConfig>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSystemStatus : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetSystemStatus() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::SystemStatus>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::SystemStatus>* streamer) {
                       return this->StreamedGetSystemStatus(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetSystemStatus() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSystemStatus(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::SystemStatus* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSystemStatus(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::SystemStatus>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAgvStateInAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAgvStateInAgvs() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::CamelSysInfo>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::CamelSysInfo>* streamer) {
                       return this->StreamedGetAgvStateInAgvs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAgvStateInAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAgvStateInAgvs(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelSysInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAgvStateInAgvs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::CamelSysInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendToAgvs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendToAgvs() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CamelMessage, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CamelMessage, ::Result>* streamer) {
                       return this->StreamedSendToAgvs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendToAgvs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendToAgvs(::grpc::ServerContext* /*context*/, const ::CamelMessage* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendToAgvs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CamelMessage,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControlAgv : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControlAgv() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Operation, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Operation, ::Result>* streamer) {
                       return this->StreamedControlAgv(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControlAgv() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControlAgv(::grpc::ServerContext* /*context*/, const ::Operation* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControlAgv(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Operation,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetCamelCfg() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CamelCfg, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CamelCfg, ::Result>* streamer) {
                       return this->StreamedSetCamelCfg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetCamelCfg(::grpc::ServerContext* /*context*/, const ::CamelCfg* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetCamelCfg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CamelCfg,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCamelCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCamelCfg() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::CamelCfg>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::CamelCfg>* streamer) {
                       return this->StreamedGetCamelCfg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCamelCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCamelCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::CamelCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCamelCfg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::CamelCfg>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCamelPathCollection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCamelPathCollection() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::PathCollection>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::PathCollection>* streamer) {
                       return this->StreamedGetCamelPathCollection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCamelPathCollection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCamelPathCollection(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::PathCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCamelPathCollection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::PathCollection>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RoutePlan : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RoutePlan() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::CamelMessage_MissonFromAgvs, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::CamelMessage_MissonFromAgvs, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedRoutePlan(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RoutePlan() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RoutePlan(::grpc::ServerContext* /*context*/, const ::CamelMessage_MissonFromAgvs* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRoutePlan(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::CamelMessage_MissonFromAgvs,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRosNodeCfg() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::RosNodesCfg>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::RosNodesCfg>* streamer) {
                       return this->StreamedGetRosNodeCfg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosNodesCfg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRosNodeCfg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::RosNodesCfg>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetRosNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetRosNodeCfg() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RosNode, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RosNode, ::Result>* streamer) {
                       return this->StreamedSetRosNodeCfg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetRosNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetRosNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetRosNodeCfg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RosNode,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteNodeCfg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteNodeCfg() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RosNode, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RosNode, ::Result>* streamer) {
                       return this->StreamedDeleteNodeCfg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteNodeCfg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteNodeCfg(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteNodeCfg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RosNode,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopRosnode : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopRosnode() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RosNode, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RosNode, ::Result>* streamer) {
                       return this->StreamedStopRosnode(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopRosnode() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopRosnode(::grpc::ServerContext* /*context*/, const ::RosNode* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopRosnode(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RosNode,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRosoutMsg : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRosoutMsg() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::RosoutMsg>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::RosoutMsg>* streamer) {
                       return this->StreamedGetRosoutMsg(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetRosoutMsg() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRosoutMsg(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::RosoutMsg* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRosoutMsg(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::RosoutMsg>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetAvoidanceArea : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetAvoidanceArea() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::AvoidanceAreaCollection, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::AvoidanceAreaCollection, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedSetAvoidanceArea(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetAvoidanceArea() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetAvoidanceArea(::grpc::ServerContext* /*context*/, const ::AvoidanceAreaCollection* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetAvoidanceArea(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AvoidanceAreaCollection,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LogExport : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LogExport() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::LogRequest, ::LogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::LogRequest, ::LogResponse>* streamer) {
                       return this->StreamedLogExport(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LogExport() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LogExport(::grpc::ServerContext* /*context*/, const ::LogRequest* /*request*/, ::LogResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLogExport(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::LogRequest,::LogResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AlarmUpload : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AlarmUpload() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::AlarmMsg, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::AlarmMsg, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedAlarmUpload(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AlarmUpload() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AlarmUpload(::grpc::ServerContext* /*context*/, const ::AlarmMsg* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAlarmUpload(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::AlarmMsg,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_QueryNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_QueryNetworkInformation() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::NetworkConfigCollection>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::NetworkConfigCollection>* streamer) {
                       return this->StreamedQueryNetworkInformation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_QueryNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status QueryNetworkInformation(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::NetworkConfigCollection* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueryNetworkInformation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::NetworkConfigCollection>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetNetworkInformation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetNetworkInformation() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::NetworkConfig, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::NetworkConfig, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedSetNetworkInformation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetNetworkInformation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetNetworkInformation(::grpc::ServerContext* /*context*/, const ::NetworkConfig* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetNetworkInformation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::NetworkConfig,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SearchWLANList : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SearchWLANList() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::WLANList>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::WLANList>* streamer) {
                       return this->StreamedSearchWLANList(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SearchWLANList() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SearchWLANList(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::WLANList* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSearchWLANList(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::WLANList>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConnectWLAN : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConnectWLAN() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::WirlessConfig, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::WirlessConfig, ::Result>* streamer) {
                       return this->StreamedConnectWLAN(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConnectWLAN() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConnectWLAN(::grpc::ServerContext* /*context*/, const ::WirlessConfig* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConnectWLAN(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::WirlessConfig,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SoftwareUpgrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SoftwareUpgrade() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InstallPack, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::InstallPack, ::Result>* streamer) {
                       return this->StreamedSoftwareUpgrade(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SoftwareUpgrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SoftwareUpgrade(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSoftwareUpgrade(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InstallPack,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SoftwareBackup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SoftwareBackup() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::Result>* streamer) {
                       return this->StreamedSoftwareBackup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SoftwareBackup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SoftwareBackup(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSoftwareBackup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SoftwareRollback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SoftwareRollback() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::InstallPack, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::InstallPack, ::Result>* streamer) {
                       return this->StreamedSoftwareRollback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SoftwareRollback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SoftwareRollback(::grpc::ServerContext* /*context*/, const ::InstallPack* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSoftwareRollback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InstallPack,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SoftwareDowngrade : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SoftwareDowngrade() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::Result>* streamer) {
                       return this->StreamedSoftwareDowngrade(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SoftwareDowngrade() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SoftwareDowngrade(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSoftwareDowngrade(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StickControl() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::Gamepad, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::Gamepad, ::Result>* streamer) {
                       return this->StreamedStickControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StickControl(::grpc::ServerContext* /*context*/, const ::Gamepad* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStickControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Gamepad,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ApplyStickControl : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ApplyStickControl() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GamepadControl, ::Token>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GamepadControl, ::Token>* streamer) {
                       return this->StreamedApplyStickControl(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ApplyStickControl() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ApplyStickControl(::grpc::ServerContext* /*context*/, const ::GamepadControl* /*request*/, ::Token* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedApplyStickControl(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GamepadControl,::Token>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ModifyMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ModifyMatchPoint() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::MatchPointCommand, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::MatchPointCommand, ::Result>* streamer) {
                       return this->StreamedModifyMatchPoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ModifyMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ModifyMatchPoint(::grpc::ServerContext* /*context*/, const ::MatchPointCommand* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedModifyMatchPoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::MatchPointCommand,::Result>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMatchPoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMatchPoint() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::MatchPoints>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::MatchPoints>* streamer) {
                       return this->StreamedGetMatchPoint(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetMatchPoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMatchPoint(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::MatchPoints* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMatchPoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::MatchPoints>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CarRestart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CarRestart() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::StreamedUnaryHandler<
          ::google::protobuf::Empty, ::google::protobuf::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::google::protobuf::Empty, ::google::protobuf::Empty>* streamer) {
                       return this->StreamedCarRestart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CarRestart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CarRestart(::grpc::ServerContext* /*context*/, const ::google::protobuf::Empty* /*request*/, ::google::protobuf::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCarRestart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::google::protobuf::Empty,::google::protobuf::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateStationPose : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateStationPose() {
      ::grpc::Service::MarkMethodStreamed(33,
        new ::grpc::internal::StreamedUnaryHandler<
          ::UpdateStation, ::UpdatePose>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::UpdateStation, ::UpdatePose>* streamer) {
                       return this->StreamedUpdateStationPose(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateStationPose() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateStationPose(::grpc::ServerContext* /*context*/, const ::UpdateStation* /*request*/, ::UpdatePose* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateStationPose(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UpdateStation,::UpdatePose>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TaskAllocationOperation : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TaskAllocationOperation() {
      ::grpc::Service::MarkMethodStreamed(34,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GrpcTaskOperation, ::GrpcTaskAllocations>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GrpcTaskOperation, ::GrpcTaskAllocations>* streamer) {
                       return this->StreamedTaskAllocationOperation(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TaskAllocationOperation() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TaskAllocationOperation(::grpc::ServerContext* /*context*/, const ::GrpcTaskOperation* /*request*/, ::GrpcTaskAllocations* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTaskAllocationOperation(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GrpcTaskOperation,::GrpcTaskAllocations>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AssignAllocationTasks : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AssignAllocationTasks() {
      ::grpc::Service::MarkMethodStreamed(35,
        new ::grpc::internal::StreamedUnaryHandler<
          ::GrpcTaskAllocations, ::Result>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::GrpcTaskAllocations, ::Result>* streamer) {
                       return this->StreamedAssignAllocationTasks(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AssignAllocationTasks() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AssignAllocationTasks(::grpc::ServerContext* /*context*/, const ::GrpcTaskAllocations* /*request*/, ::Result* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAssignAllocationTasks(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::GrpcTaskAllocations,::Result>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_UploadMapData<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetAgvState<WithStreamedUnaryMethod_RequestUIConfig<WithStreamedUnaryMethod_GetSystemStatus<WithStreamedUnaryMethod_GetAgvStateInAgvs<WithStreamedUnaryMethod_SendToAgvs<WithStreamedUnaryMethod_ControlAgv<WithStreamedUnaryMethod_SetCamelCfg<WithStreamedUnaryMethod_GetCamelCfg<WithStreamedUnaryMethod_GetCamelPathCollection<WithStreamedUnaryMethod_RoutePlan<WithStreamedUnaryMethod_GetRosNodeCfg<WithStreamedUnaryMethod_SetRosNodeCfg<WithStreamedUnaryMethod_DeleteNodeCfg<WithStreamedUnaryMethod_StopRosnode<WithStreamedUnaryMethod_GetRosoutMsg<WithStreamedUnaryMethod_SetAvoidanceArea<WithStreamedUnaryMethod_LogExport<WithStreamedUnaryMethod_AlarmUpload<WithStreamedUnaryMethod_QueryNetworkInformation<WithStreamedUnaryMethod_SetNetworkInformation<WithStreamedUnaryMethod_SearchWLANList<WithStreamedUnaryMethod_ConnectWLAN<WithStreamedUnaryMethod_SoftwareUpgrade<WithStreamedUnaryMethod_SoftwareBackup<WithStreamedUnaryMethod_SoftwareRollback<WithStreamedUnaryMethod_SoftwareDowngrade<WithStreamedUnaryMethod_StickControl<WithStreamedUnaryMethod_ApplyStickControl<WithStreamedUnaryMethod_ModifyMatchPoint<WithStreamedUnaryMethod_GetMatchPoint<WithStreamedUnaryMethod_CarRestart<WithStreamedUnaryMethod_UpdateStationPose<WithStreamedUnaryMethod_TaskAllocationOperation<WithStreamedUnaryMethod_AssignAllocationTasks<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_UploadMapData<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetAgvState<WithStreamedUnaryMethod_RequestUIConfig<WithStreamedUnaryMethod_GetSystemStatus<WithStreamedUnaryMethod_GetAgvStateInAgvs<WithStreamedUnaryMethod_SendToAgvs<WithStreamedUnaryMethod_ControlAgv<WithStreamedUnaryMethod_SetCamelCfg<WithStreamedUnaryMethod_GetCamelCfg<WithStreamedUnaryMethod_GetCamelPathCollection<WithStreamedUnaryMethod_RoutePlan<WithStreamedUnaryMethod_GetRosNodeCfg<WithStreamedUnaryMethod_SetRosNodeCfg<WithStreamedUnaryMethod_DeleteNodeCfg<WithStreamedUnaryMethod_StopRosnode<WithStreamedUnaryMethod_GetRosoutMsg<WithStreamedUnaryMethod_SetAvoidanceArea<WithStreamedUnaryMethod_LogExport<WithStreamedUnaryMethod_AlarmUpload<WithStreamedUnaryMethod_QueryNetworkInformation<WithStreamedUnaryMethod_SetNetworkInformation<WithStreamedUnaryMethod_SearchWLANList<WithStreamedUnaryMethod_ConnectWLAN<WithStreamedUnaryMethod_SoftwareUpgrade<WithStreamedUnaryMethod_SoftwareBackup<WithStreamedUnaryMethod_SoftwareRollback<WithStreamedUnaryMethod_SoftwareDowngrade<WithStreamedUnaryMethod_StickControl<WithStreamedUnaryMethod_ApplyStickControl<WithStreamedUnaryMethod_ModifyMatchPoint<WithStreamedUnaryMethod_GetMatchPoint<WithStreamedUnaryMethod_CarRestart<WithStreamedUnaryMethod_UpdateStationPose<WithStreamedUnaryMethod_TaskAllocationOperation<WithStreamedUnaryMethod_AssignAllocationTasks<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};


#endif  // GRPC_camel_2dgrpc_2eproto__INCLUDED
