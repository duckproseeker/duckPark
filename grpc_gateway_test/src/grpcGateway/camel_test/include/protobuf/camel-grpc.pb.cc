// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camel-grpc.proto

#include "camel-grpc.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR AgvInfo_UIStation::AgvInfo_UIStation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stationonmap_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.stationonpath_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.targetstation_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AgvInfo_UIStationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AgvInfo_UIStationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AgvInfo_UIStationDefaultTypeInternal() {}
  union {
    AgvInfo_UIStation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AgvInfo_UIStationDefaultTypeInternal _AgvInfo_UIStation_default_instance_;
PROTOBUF_CONSTEXPR AgvInfo_Motion::AgvInfo_Motion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vx_)*/0
  , /*decltype(_impl_.vy_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_.od1_)*/0
  , /*decltype(_impl_.od2_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AgvInfo_MotionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AgvInfo_MotionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AgvInfo_MotionDefaultTypeInternal() {}
  union {
    AgvInfo_Motion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AgvInfo_MotionDefaultTypeInternal _AgvInfo_Motion_default_instance_;
PROTOBUF_CONSTEXPR AgvInfo_Alarm::AgvInfo_Alarm(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.message_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.time_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AgvInfo_AlarmDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AgvInfo_AlarmDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AgvInfo_AlarmDefaultTypeInternal() {}
  union {
    AgvInfo_Alarm _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AgvInfo_AlarmDefaultTypeInternal _AgvInfo_Alarm_default_instance_;
PROTOBUF_CONSTEXPR AgvInfo_DebugInfo::AgvInfo_DebugInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.vx_)*/0
  , /*decltype(_impl_.vy_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_.goalx_)*/0
  , /*decltype(_impl_.timestamp_)*/uint64_t{0u}
  , /*decltype(_impl_.goaly_)*/0
  , /*decltype(_impl_.taskaveragevelocity_)*/0
  , /*decltype(_impl_.totaltaskaveragevelocity_)*/0
  , /*decltype(_impl_.totalodometry_)*/0
  , /*decltype(_impl_.totalruntime_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AgvInfo_DebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AgvInfo_DebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AgvInfo_DebugInfoDefaultTypeInternal() {}
  union {
    AgvInfo_DebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AgvInfo_DebugInfoDefaultTypeInternal _AgvInfo_DebugInfo_default_instance_;
PROTOBUF_CONSTEXPR AgvInfo::AgvInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.alarm_)*/{}
  , /*decltype(_impl_.montion_)*/nullptr
  , /*decltype(_impl_.postion_)*/nullptr
  , /*decltype(_impl_.station_)*/nullptr
  , /*decltype(_impl_.battery_)*/nullptr
  , /*decltype(_impl_.route_)*/nullptr
  , /*decltype(_impl_.version_)*/nullptr
  , /*decltype(_impl_.debug_)*/nullptr
  , /*decltype(_impl_.agvsinfo_)*/nullptr
  , /*decltype(_impl_.grpctask_)*/nullptr
  , /*decltype(_impl_.runmode_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.runstatus_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AgvInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AgvInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AgvInfoDefaultTypeInternal() {}
  union {
    AgvInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AgvInfoDefaultTypeInternal _AgvInfo_default_instance_;
PROTOBUF_CONSTEXPR UIConfig::UIConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.navendpoint_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.language_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UIConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UIConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UIConfigDefaultTypeInternal() {}
  union {
    UIConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UIConfigDefaultTypeInternal _UIConfig_default_instance_;
PROTOBUF_CONSTEXPR Version::Version(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.camelversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dbversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.defenderversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.packageversion_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VersionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VersionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VersionDefaultTypeInternal() {}
  union {
    Version _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VersionDefaultTypeInternal _Version_default_instance_;
PROTOBUF_CONSTEXPR Operation::Operation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.iscontinue_)*/false
  , /*decltype(_impl_.clearpath_)*/false
  , /*decltype(_impl_.clearaction_)*/false
  , /*decltype(_impl_.disablecargo_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OperationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OperationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OperationDefaultTypeInternal() {}
  union {
    Operation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OperationDefaultTypeInternal _Operation_default_instance_;
PROTOBUF_CONSTEXPR CamelCfg::CamelCfg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.jsonstring_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CamelCfgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CamelCfgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CamelCfgDefaultTypeInternal() {}
  union {
    CamelCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CamelCfgDefaultTypeInternal _CamelCfg_default_instance_;
PROTOBUF_CONSTEXPR CamelSysInfo::CamelSysInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.agvsinfo_)*/nullptr
  , /*decltype(_impl_.taskinfo_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CamelSysInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CamelSysInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CamelSysInfoDefaultTypeInternal() {}
  union {
    CamelSysInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CamelSysInfoDefaultTypeInternal _CamelSysInfo_default_instance_;
PROTOBUF_CONSTEXPR LogRequest::LogRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.modules_)*/{}
  , /*decltype(_impl_.time_)*/{}
  , /*decltype(_impl_.car_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogRequestDefaultTypeInternal() {}
  union {
    LogRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogRequestDefaultTypeInternal _LogRequest_default_instance_;
PROTOBUF_CONSTEXPR LogResponse::LogResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LogResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LogResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LogResponseDefaultTypeInternal() {}
  union {
    LogResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogResponseDefaultTypeInternal _LogResponse_default_instance_;
PROTOBUF_CONSTEXPR RosNode::RosNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.configuration_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.module_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.modify_enable_)*/false
  , /*decltype(_impl_.set_master_)*/false
  , /*decltype(_impl_.is_running_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RosNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RosNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RosNodeDefaultTypeInternal() {}
  union {
    RosNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RosNodeDefaultTypeInternal _RosNode_default_instance_;
PROTOBUF_CONSTEXPR RosNodesCfg::RosNodesCfg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.nodes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RosNodesCfgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RosNodesCfgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RosNodesCfgDefaultTypeInternal() {}
  union {
    RosNodesCfg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RosNodesCfgDefaultTypeInternal _RosNodesCfg_default_instance_;
PROTOBUF_CONSTEXPR RosoutMsg_RosoutInfo::RosoutMsg_RosoutInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.topic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.level_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RosoutMsg_RosoutInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RosoutMsg_RosoutInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RosoutMsg_RosoutInfoDefaultTypeInternal() {}
  union {
    RosoutMsg_RosoutInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RosoutMsg_RosoutInfoDefaultTypeInternal _RosoutMsg_RosoutInfo_default_instance_;
PROTOBUF_CONSTEXPR RosoutMsg::RosoutMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.messages_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RosoutMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RosoutMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RosoutMsgDefaultTypeInternal() {}
  union {
    RosoutMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RosoutMsgDefaultTypeInternal _RosoutMsg_default_instance_;
PROTOBUF_CONSTEXPR AlarmMsg::AlarmMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.code_)*/0
  , /*decltype(_impl_.cleared_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct AlarmMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AlarmMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AlarmMsgDefaultTypeInternal() {}
  union {
    AlarmMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AlarmMsgDefaultTypeInternal _AlarmMsg_default_instance_;
PROTOBUF_CONSTEXPR NetworkConfig::NetworkConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.address_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mac_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.netmask_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.gateway_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dns_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkConfigDefaultTypeInternal() {}
  union {
    NetworkConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkConfigDefaultTypeInternal _NetworkConfig_default_instance_;
PROTOBUF_CONSTEXPR WirlessConfig::WirlessConfig(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ssid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.passwd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.config_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WirlessConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WirlessConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WirlessConfigDefaultTypeInternal() {}
  union {
    WirlessConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WirlessConfigDefaultTypeInternal _WirlessConfig_default_instance_;
PROTOBUF_CONSTEXPR WirlessInfo::WirlessInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ssid_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.signallevel_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WirlessInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WirlessInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WirlessInfoDefaultTypeInternal() {}
  union {
    WirlessInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WirlessInfoDefaultTypeInternal _WirlessInfo_default_instance_;
PROTOBUF_CONSTEXPR WLANList::WLANList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.wirlesslist_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WLANListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WLANListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WLANListDefaultTypeInternal() {}
  union {
    WLANList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WLANListDefaultTypeInternal _WLANList_default_instance_;
PROTOBUF_CONSTEXPR NetworkConfigCollection::NetworkConfigCollection(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.config_collection_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct NetworkConfigCollectionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NetworkConfigCollectionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NetworkConfigCollectionDefaultTypeInternal() {}
  union {
    NetworkConfigCollection _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NetworkConfigCollectionDefaultTypeInternal _NetworkConfigCollection_default_instance_;
PROTOBUF_CONSTEXPR InstallPack::InstallPack(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InstallPackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InstallPackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InstallPackDefaultTypeInternal() {}
  union {
    InstallPack _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InstallPackDefaultTypeInternal _InstallPack_default_instance_;
PROTOBUF_CONSTEXPR SystemStatus::SystemStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cpu_usage_)*/0
  , /*decltype(_impl_.mem_total_)*/0
  , /*decltype(_impl_.mem_used_)*/0
  , /*decltype(_impl_.disk_total_)*/0
  , /*decltype(_impl_.disk_used_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SystemStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SystemStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SystemStatusDefaultTypeInternal() {}
  union {
    SystemStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
PROTOBUF_CONSTEXPR UpdateStation::UpdateStation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.marker_type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdateStationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateStationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateStationDefaultTypeInternal() {}
  union {
    UpdateStation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateStationDefaultTypeInternal _UpdateStation_default_instance_;
PROTOBUF_CONSTEXPR UpdatePose::UpdatePose(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.error_info_)*/nullptr
  , /*decltype(_impl_.pose_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UpdatePoseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdatePoseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdatePoseDefaultTypeInternal() {}
  union {
    UpdatePose _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdatePoseDefaultTypeInternal _UpdatePose_default_instance_;
static ::_pb::Metadata file_level_metadata_camel_2dgrpc_2eproto[26];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_camel_2dgrpc_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_camel_2dgrpc_2eproto = nullptr;

const uint32_t TableStruct_camel_2dgrpc_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_UIStation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_UIStation, _impl_.stationonmap_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_UIStation, _impl_.stationonpath_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_UIStation, _impl_.targetstation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _impl_.vx_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _impl_.vy_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _impl_.w_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _impl_.od1_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Motion, _impl_.od2_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _impl_.message_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _impl_.time_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_Alarm, _impl_.code_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.vx_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.vy_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.w_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.goalx_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.goaly_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.timestamp_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.taskaveragevelocity_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.totaltaskaveragevelocity_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.totalodometry_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo_DebugInfo, _impl_.totalruntime_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.montion_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.postion_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.station_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.alarm_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.battery_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.runmode_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.route_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.runstatus_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.debug_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.agvsinfo_),
  PROTOBUF_FIELD_OFFSET(::AgvInfo, _impl_.grpctask_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UIConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UIConfig, _impl_.navendpoint_),
  PROTOBUF_FIELD_OFFSET(::UIConfig, _impl_.language_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Version, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Version, _impl_.camelversion_),
  PROTOBUF_FIELD_OFFSET(::Version, _impl_.dbversion_),
  PROTOBUF_FIELD_OFFSET(::Version, _impl_.defenderversion_),
  PROTOBUF_FIELD_OFFSET(::Version, _impl_.packageversion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Operation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Operation, _impl_.iscontinue_),
  PROTOBUF_FIELD_OFFSET(::Operation, _impl_.clearpath_),
  PROTOBUF_FIELD_OFFSET(::Operation, _impl_.clearaction_),
  PROTOBUF_FIELD_OFFSET(::Operation, _impl_.disablecargo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CamelCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CamelCfg, _impl_.jsonstring_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CamelSysInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CamelSysInfo, _impl_.agvsinfo_),
  PROTOBUF_FIELD_OFFSET(::CamelSysInfo, _impl_.taskinfo_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LogRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LogRequest, _impl_.car_),
  PROTOBUF_FIELD_OFFSET(::LogRequest, _impl_.modules_),
  PROTOBUF_FIELD_OFFSET(::LogRequest, _impl_.time_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::LogResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::LogResponse, _impl_.path_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RosNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.configuration_),
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.modify_enable_),
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.set_master_),
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.module_),
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::RosNode, _impl_.is_running_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RosNodesCfg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RosNodesCfg, _impl_.nodes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RosoutMsg_RosoutInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RosoutMsg_RosoutInfo, _impl_.level_),
  PROTOBUF_FIELD_OFFSET(::RosoutMsg_RosoutInfo, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::RosoutMsg_RosoutInfo, _impl_.msg_),
  PROTOBUF_FIELD_OFFSET(::RosoutMsg_RosoutInfo, _impl_.topic_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::RosoutMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::RosoutMsg, _impl_.messages_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AlarmMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::AlarmMsg, _impl_.code_),
  PROTOBUF_FIELD_OFFSET(::AlarmMsg, _impl_.cleared_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.address_),
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.mac_),
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.netmask_),
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.gateway_),
  PROTOBUF_FIELD_OFFSET(::NetworkConfig, _impl_.dns_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::WirlessConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::WirlessConfig, _impl_.ssid_),
  PROTOBUF_FIELD_OFFSET(::WirlessConfig, _impl_.passwd_),
  PROTOBUF_FIELD_OFFSET(::WirlessConfig, _impl_.config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::WirlessInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::WirlessInfo, _impl_.ssid_),
  PROTOBUF_FIELD_OFFSET(::WirlessInfo, _impl_.signallevel_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::WLANList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::WLANList, _impl_.wirlesslist_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::NetworkConfigCollection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::NetworkConfigCollection, _impl_.config_collection_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::InstallPack, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::InstallPack, _impl_.filename_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.cpu_usage_),
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.mem_total_),
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.mem_used_),
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.disk_total_),
  PROTOBUF_FIELD_OFFSET(::SystemStatus, _impl_.disk_used_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UpdateStation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UpdateStation, _impl_.marker_type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UpdatePose, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UpdatePose, _impl_.error_info_),
  PROTOBUF_FIELD_OFFSET(::UpdatePose, _impl_.pose_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::AgvInfo_UIStation)},
  { 9, -1, -1, sizeof(::AgvInfo_Motion)},
  { 20, -1, -1, sizeof(::AgvInfo_Alarm)},
  { 31, -1, -1, sizeof(::AgvInfo_DebugInfo)},
  { 47, -1, -1, sizeof(::AgvInfo)},
  { 66, -1, -1, sizeof(::UIConfig)},
  { 74, -1, -1, sizeof(::Version)},
  { 84, -1, -1, sizeof(::Operation)},
  { 94, -1, -1, sizeof(::CamelCfg)},
  { 101, -1, -1, sizeof(::CamelSysInfo)},
  { 109, -1, -1, sizeof(::LogRequest)},
  { 118, -1, -1, sizeof(::LogResponse)},
  { 125, -1, -1, sizeof(::RosNode)},
  { 137, -1, -1, sizeof(::RosNodesCfg)},
  { 144, -1, -1, sizeof(::RosoutMsg_RosoutInfo)},
  { 154, -1, -1, sizeof(::RosoutMsg)},
  { 161, -1, -1, sizeof(::AlarmMsg)},
  { 169, -1, -1, sizeof(::NetworkConfig)},
  { 181, -1, -1, sizeof(::WirlessConfig)},
  { 190, -1, -1, sizeof(::WirlessInfo)},
  { 198, -1, -1, sizeof(::WLANList)},
  { 205, -1, -1, sizeof(::NetworkConfigCollection)},
  { 212, -1, -1, sizeof(::InstallPack)},
  { 219, -1, -1, sizeof(::SystemStatus)},
  { 231, -1, -1, sizeof(::UpdateStation)},
  { 238, -1, -1, sizeof(::UpdatePose)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_AgvInfo_UIStation_default_instance_._instance,
  &::_AgvInfo_Motion_default_instance_._instance,
  &::_AgvInfo_Alarm_default_instance_._instance,
  &::_AgvInfo_DebugInfo_default_instance_._instance,
  &::_AgvInfo_default_instance_._instance,
  &::_UIConfig_default_instance_._instance,
  &::_Version_default_instance_._instance,
  &::_Operation_default_instance_._instance,
  &::_CamelCfg_default_instance_._instance,
  &::_CamelSysInfo_default_instance_._instance,
  &::_LogRequest_default_instance_._instance,
  &::_LogResponse_default_instance_._instance,
  &::_RosNode_default_instance_._instance,
  &::_RosNodesCfg_default_instance_._instance,
  &::_RosoutMsg_RosoutInfo_default_instance_._instance,
  &::_RosoutMsg_default_instance_._instance,
  &::_AlarmMsg_default_instance_._instance,
  &::_NetworkConfig_default_instance_._instance,
  &::_WirlessConfig_default_instance_._instance,
  &::_WirlessInfo_default_instance_._instance,
  &::_WLANList_default_instance_._instance,
  &::_NetworkConfigCollection_default_instance_._instance,
  &::_InstallPack_default_instance_._instance,
  &::_SystemStatus_default_instance_._instance,
  &::_UpdateStation_default_instance_._instance,
  &::_UpdatePose_default_instance_._instance,
};

const char descriptor_table_protodef_camel_2dgrpc_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020camel-grpc.proto\032\020camel-agvs.proto\032\022ca"
  "mel-common.proto\032\016camel-db.proto\032\033google"
  "/protobuf/empty.proto\"\364\007\n\007AgvInfo\022 \n\007mon"
  "tion\030\001 \001(\0132\017.AgvInfo.Motion\022\032\n\007postion\030\002"
  " \001(\0132\t.Position\022#\n\007station\030\003 \001(\0132\022.AgvIn"
  "fo.UIStation\022\035\n\005alarm\030\004 \003(\0132\016.AgvInfo.Al"
  "arm\022\031\n\007battery\030\005 \001(\0132\010.Battery\022\017\n\007runMod"
  "e\030\006 \001(\005\022\016\n\006height\030\007 \001(\002\022\036\n\005route\030\t \001(\0132\017"
  ".PathCollection\022\021\n\trunStatus\030\n \001(\005\022\031\n\007ve"
  "rsion\030\013 \001(\0132\010.Version\022!\n\005debug\030\014 \001(\0132\022.A"
  "gvInfo.DebugInfo\022\037\n\010agvsInfo\030\r \001(\0132\r.Cam"
  "elSysInfo\022%\n\010grpcTask\030\016 \001(\0132\023.GrpcTaskIn"
  "fomation\032O\n\tUIStation\022\024\n\014stationOnMap\030\001 "
  "\001(\t\022\025\n\rstationOnPath\030\002 \001(\t\022\025\n\rtargetStat"
  "ion\030\003 \001(\t\032E\n\006Motion\022\n\n\002vx\030\001 \001(\002\022\n\n\002vy\030\002 "
  "\001(\002\022\t\n\001w\030\003 \001(\002\022\013\n\003od1\030\004 \001(\002\022\013\n\003od2\030\005 \001(\002"
  "\032\213\002\n\005Alarm\022#\n\004type\030\001 \001(\0162\025.AgvInfo.Alarm"
  ".Source\022#\n\005level\030\002 \001(\0162\024.AgvInfo.Alarm.L"
  "evel\022\017\n\007message\030\003 \001(\014\022\014\n\004time\030\004 \001(\014\022\014\n\004c"
  "ode\030\005 \001(\005\"]\n\006Source\022\013\n\007PLC_MCU\020\000\022\t\n\005Came"
  "l\020\001\022\016\n\nController\020\002\022\007\n\003Nav\020\003\022\010\n\004AGVS\020\004\022\014"
  "\n\010Defender\020\005\022\n\n\006Unknow\020\006\",\n\005Level\022\013\n\007Gen"
  "eral\020\000\022\013\n\007Serious\020\001\022\t\n\005Fatal\020\002\032\313\001\n\tDebug"
  "Info\022\n\n\002Vx\030\001 \001(\002\022\n\n\002Vy\030\002 \001(\002\022\t\n\001W\030\003 \001(\002\022"
  "\r\n\005GoalX\030\004 \001(\002\022\r\n\005GoalY\030\005 \001(\002\022\021\n\ttimesta"
  "mp\030\006 \001(\004\022\033\n\023TaskAverageVelocity\030\007 \001(\002\022 \n"
  "\030TotalTaskAverageVelocity\030\010 \001(\002\022\025\n\rTotal"
  "Odometry\030\t \001(\002\022\024\n\014TotalRuntime\030\n \001(\002\"<\n\010"
  "UIConfig\022\023\n\013navEndpoint\030\001 \001(\t\022\033\n\010languag"
  "e\030\002 \001(\0162\t.Language\"c\n\007Version\022\024\n\014CamelVe"
  "rsion\030\001 \001(\t\022\021\n\tDBVersion\030\002 \001(\014\022\027\n\017Defend"
  "erVersion\030\003 \001(\t\022\026\n\016PackageVersion\030\004 \001(\t\""
  "]\n\tOperation\022\022\n\nisContinue\030\001 \001(\010\022\021\n\tclea"
  "rPath\030\002 \001(\010\022\023\n\013clearAction\030\003 \001(\010\022\024\n\014disa"
  "bleCargo\030\004 \001(\010\"\036\n\010CamelCfg\022\022\n\nJsonString"
  "\030\001 \001(\t\"m\n\014CamelSysInfo\022-\n\010agvsInfo\030\001 \001(\013"
  "2\033.CamelMessage.AllowFromAgvs\022.\n\010taskInf"
  "o\030\002 \001(\0132\034.CamelMessage.MissonFromAgvs\"8\n"
  "\nLogRequest\022\013\n\003car\030\001 \001(\t\022\017\n\007modules\030\002 \003("
  "\t\022\014\n\004time\030\003 \003(\t\"\033\n\013LogResponse\022\014\n\004path\030\001"
  " \001(\t\"\201\001\n\007RosNode\022\025\n\rconfiguration\030\001 \001(\t\022"
  "\025\n\rmodify_enable\030\002 \001(\010\022\022\n\nset_master\030\003 \001"
  "(\010\022\016\n\006module\030\004 \001(\t\022\020\n\010filename\030\005 \001(\t\022\022\n\n"
  "is_running\030\006 \001(\010\"&\n\013RosNodesCfg\022\027\n\005nodes"
  "\030\001 \003(\0132\010.RosNode\"{\n\tRosoutMsg\022\'\n\010message"
  "s\030\001 \003(\0132\025.RosoutMsg.RosoutInfo\032E\n\nRosout"
  "Info\022\r\n\005level\030\001 \001(\005\022\014\n\004name\030\002 \001(\t\022\013\n\003msg"
  "\030\003 \001(\t\022\r\n\005topic\030\004 \001(\t\")\n\010AlarmMsg\022\014\n\004cod"
  "e\030\001 \001(\005\022\017\n\007cleared\030\002 \001(\010\"j\n\rNetworkConfi"
  "g\022\014\n\004name\030\001 \001(\t\022\017\n\007address\030\002 \001(\t\022\013\n\003mac\030"
  "\003 \001(\t\022\017\n\007netmask\030\004 \001(\t\022\017\n\007gateway\030\005 \001(\t\022"
  "\013\n\003dns\030\006 \001(\t\"M\n\rWirlessConfig\022\014\n\004ssid\030\001 "
  "\001(\t\022\016\n\006passwd\030\002 \001(\t\022\036\n\006config\030\003 \001(\0132\016.Ne"
  "tworkConfig\"0\n\013WirlessInfo\022\014\n\004ssid\030\001 \001(\t"
  "\022\023\n\013signalLevel\030\002 \001(\005\"-\n\010WLANList\022!\n\013wir"
  "lessList\030\001 \003(\0132\014.WirlessInfo\"D\n\027NetworkC"
  "onfigCollection\022)\n\021config_collection\030\001 \003"
  "(\0132\016.NetworkConfig\"\037\n\013InstallPack\022\020\n\010fil"
  "ename\030\001 \001(\t\"~\n\014SystemStatus\022\017\n\007version\030\001"
  " \001(\t\022\021\n\tcpu_usage\030\002 \001(\002\022\021\n\tmem_total\030\003 \001"
  "(\005\022\020\n\010mem_used\030\004 \001(\005\022\022\n\ndisk_total\030\005 \001(\005"
  "\022\021\n\tdisk_used\030\006 \001(\005\"$\n\rUpdateStation\022\023\n\013"
  "marker_type\030\001 \001(\005\"B\n\nUpdatePose\022\033\n\nerror"
  "_info\030\001 \001(\0132\007.Result\022\027\n\004pose\030\002 \001(\0132\t.Pos"
  "ition* \n\010Language\022\t\n\005en_us\020\000\022\t\n\005zh_cn\020\0012"
  "\227\016\n\nAgvService\022\"\n\rUploadMapData\022\010.ISeeMa"
  "p\032\007.Result\022 \n\nGetVersion\022\010.ISeeMap\032\010.Ver"
  "sion\022/\n\013GetAgvState\022\026.google.protobuf.Em"
  "pty\032\010.AgvInfo\0224\n\017RequestUIConfig\022\026.googl"
  "e.protobuf.Empty\032\t.UIConfig\0228\n\017GetSystem"
  "Status\022\026.google.protobuf.Empty\032\r.SystemS"
  "tatus\022:\n\021GetAgvStateInAgvs\022\026.google.prot"
  "obuf.Empty\032\r.CamelSysInfo\022$\n\nSendToAgvs\022"
  "\r.CamelMessage\032\007.Result\022!\n\nControlAgv\022\n."
  "Operation\032\007.Result\022!\n\013SetCamelCfg\022\t.Came"
  "lCfg\032\007.Result\0220\n\013GetCamelCfg\022\026.google.pr"
  "otobuf.Empty\032\t.CamelCfg\022A\n\026GetCamelPathC"
  "ollection\022\026.google.protobuf.Empty\032\017.Path"
  "Collection\022A\n\tRoutePlan\022\034.CamelMessage.M"
  "issonFromAgvs\032\026.google.protobuf.Empty\0225\n"
  "\rGetRosNodeCfg\022\026.google.protobuf.Empty\032\014"
  ".RosNodesCfg\022\"\n\rSetRosNodeCfg\022\010.RosNode\032"
  "\007.Result\022\"\n\rDeleteNodeCfg\022\010.RosNode\032\007.Re"
  "sult\022 \n\013StopRosnode\022\010.RosNode\032\007.Result\0222"
  "\n\014GetRosoutMsg\022\026.google.protobuf.Empty\032\n"
  ".RosoutMsg\022D\n\020SetAvoidanceArea\022\030.Avoidan"
  "ceAreaCollection\032\026.google.protobuf.Empty"
  "\022&\n\tLogExport\022\013.LogRequest\032\014.LogResponse"
  "\0220\n\013AlarmUpload\022\t.AlarmMsg\032\026.google.prot"
  "obuf.Empty\022K\n\027QueryNetworkInformation\022\026."
  "google.protobuf.Empty\032\030.NetworkConfigCol"
  "lection\022\?\n\025SetNetworkInformation\022\016.Netwo"
  "rkConfig\032\026.google.protobuf.Empty\0223\n\016Sear"
  "chWLANList\022\026.google.protobuf.Empty\032\t.WLA"
  "NList\022&\n\013ConnectWLAN\022\016.WirlessConfig\032\007.R"
  "esult\022(\n\017SoftwareUpgrade\022\014.InstallPack\032\007"
  ".Result\0221\n\016SoftwareBackup\022\026.google.proto"
  "buf.Empty\032\007.Result\022)\n\020SoftwareRollback\022\014"
  ".InstallPack\032\007.Result\0224\n\021SoftwareDowngra"
  "de\022\026.google.protobuf.Empty\032\007.Result\022!\n\014S"
  "tickControl\022\010.Gamepad\032\007.Result\022,\n\021ApplyS"
  "tickControl\022\017.GamepadControl\032\006.Token\022/\n\020"
  "ModifyMatchPoint\022\022.MatchPointCommand\032\007.R"
  "esult\0225\n\rGetMatchPoint\022\026.google.protobuf"
  ".Empty\032\014.MatchPoints\022<\n\nCarRestart\022\026.goo"
  "gle.protobuf.Empty\032\026.google.protobuf.Emp"
  "ty\0220\n\021UpdateStationPose\022\016.UpdateStation\032"
  "\013.UpdatePose\022C\n\027TaskAllocationOperation\022"
  "\022.GrpcTaskOperation\032\024.GrpcTaskAllocation"
  "s\0226\n\025AssignAllocationTasks\022\024.GrpcTaskAll"
  "ocations\032\007.Resultb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_camel_2dgrpc_2eproto_deps[4] = {
  &::descriptor_table_camel_2dagvs_2eproto,
  &::descriptor_table_camel_2dcommon_2eproto,
  &::descriptor_table_camel_2ddb_2eproto,
  &::descriptor_table_google_2fprotobuf_2fempty_2eproto,
};
static ::_pbi::once_flag descriptor_table_camel_2dgrpc_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_camel_2dgrpc_2eproto = {
    false, false, 4425, descriptor_table_protodef_camel_2dgrpc_2eproto,
    "camel-grpc.proto",
    &descriptor_table_camel_2dgrpc_2eproto_once, descriptor_table_camel_2dgrpc_2eproto_deps, 4, 26,
    schemas, file_default_instances, TableStruct_camel_2dgrpc_2eproto::offsets,
    file_level_metadata_camel_2dgrpc_2eproto, file_level_enum_descriptors_camel_2dgrpc_2eproto,
    file_level_service_descriptors_camel_2dgrpc_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_camel_2dgrpc_2eproto_getter() {
  return &descriptor_table_camel_2dgrpc_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_camel_2dgrpc_2eproto(&descriptor_table_camel_2dgrpc_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgvInfo_Alarm_Source_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_camel_2dgrpc_2eproto);
  return file_level_enum_descriptors_camel_2dgrpc_2eproto[0];
}
bool AgvInfo_Alarm_Source_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::PLC_MCU;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Camel;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Controller;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Nav;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::AGVS;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Defender;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Unknow;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Source_MIN;
constexpr AgvInfo_Alarm_Source AgvInfo_Alarm::Source_MAX;
constexpr int AgvInfo_Alarm::Source_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgvInfo_Alarm_Level_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_camel_2dgrpc_2eproto);
  return file_level_enum_descriptors_camel_2dgrpc_2eproto[1];
}
bool AgvInfo_Alarm_Level_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm::General;
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm::Serious;
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm::Fatal;
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm::Level_MIN;
constexpr AgvInfo_Alarm_Level AgvInfo_Alarm::Level_MAX;
constexpr int AgvInfo_Alarm::Level_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_camel_2dgrpc_2eproto);
  return file_level_enum_descriptors_camel_2dgrpc_2eproto[2];
}
bool Language_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AgvInfo_UIStation::_Internal {
 public:
};

AgvInfo_UIStation::AgvInfo_UIStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AgvInfo.UIStation)
}
AgvInfo_UIStation::AgvInfo_UIStation(const AgvInfo_UIStation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AgvInfo_UIStation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stationonmap_){}
    , decltype(_impl_.stationonpath_){}
    , decltype(_impl_.targetstation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.stationonmap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stationonmap_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stationonmap().empty()) {
    _this->_impl_.stationonmap_.Set(from._internal_stationonmap(), 
      _this->GetArenaForAllocation());
  }
  _impl_.stationonpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stationonpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_stationonpath().empty()) {
    _this->_impl_.stationonpath_.Set(from._internal_stationonpath(), 
      _this->GetArenaForAllocation());
  }
  _impl_.targetstation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetstation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_targetstation().empty()) {
    _this->_impl_.targetstation_.Set(from._internal_targetstation(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:AgvInfo.UIStation)
}

inline void AgvInfo_UIStation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stationonmap_){}
    , decltype(_impl_.stationonpath_){}
    , decltype(_impl_.targetstation_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.stationonmap_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stationonmap_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stationonpath_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stationonpath_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.targetstation_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.targetstation_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AgvInfo_UIStation::~AgvInfo_UIStation() {
  // @@protoc_insertion_point(destructor:AgvInfo.UIStation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AgvInfo_UIStation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stationonmap_.Destroy();
  _impl_.stationonpath_.Destroy();
  _impl_.targetstation_.Destroy();
}

void AgvInfo_UIStation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AgvInfo_UIStation::Clear() {
// @@protoc_insertion_point(message_clear_start:AgvInfo.UIStation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stationonmap_.ClearToEmpty();
  _impl_.stationonpath_.ClearToEmpty();
  _impl_.targetstation_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgvInfo_UIStation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string stationOnMap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_stationonmap();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AgvInfo.UIStation.stationOnMap"));
        } else
          goto handle_unusual;
        continue;
      // string stationOnPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_stationonpath();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AgvInfo.UIStation.stationOnPath"));
        } else
          goto handle_unusual;
        continue;
      // string targetStation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_targetstation();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "AgvInfo.UIStation.targetStation"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgvInfo_UIStation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AgvInfo.UIStation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string stationOnMap = 1;
  if (!this->_internal_stationonmap().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stationonmap().data(), static_cast<int>(this->_internal_stationonmap().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AgvInfo.UIStation.stationOnMap");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_stationonmap(), target);
  }

  // string stationOnPath = 2;
  if (!this->_internal_stationonpath().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_stationonpath().data(), static_cast<int>(this->_internal_stationonpath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AgvInfo.UIStation.stationOnPath");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_stationonpath(), target);
  }

  // string targetStation = 3;
  if (!this->_internal_targetstation().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_targetstation().data(), static_cast<int>(this->_internal_targetstation().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AgvInfo.UIStation.targetStation");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_targetstation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AgvInfo.UIStation)
  return target;
}

size_t AgvInfo_UIStation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AgvInfo.UIStation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string stationOnMap = 1;
  if (!this->_internal_stationonmap().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stationonmap());
  }

  // string stationOnPath = 2;
  if (!this->_internal_stationonpath().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_stationonpath());
  }

  // string targetStation = 3;
  if (!this->_internal_targetstation().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_targetstation());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgvInfo_UIStation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AgvInfo_UIStation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgvInfo_UIStation::GetClassData() const { return &_class_data_; }


void AgvInfo_UIStation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AgvInfo_UIStation*>(&to_msg);
  auto& from = static_cast<const AgvInfo_UIStation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AgvInfo.UIStation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_stationonmap().empty()) {
    _this->_internal_set_stationonmap(from._internal_stationonmap());
  }
  if (!from._internal_stationonpath().empty()) {
    _this->_internal_set_stationonpath(from._internal_stationonpath());
  }
  if (!from._internal_targetstation().empty()) {
    _this->_internal_set_targetstation(from._internal_targetstation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgvInfo_UIStation::CopyFrom(const AgvInfo_UIStation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AgvInfo.UIStation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgvInfo_UIStation::IsInitialized() const {
  return true;
}

void AgvInfo_UIStation::InternalSwap(AgvInfo_UIStation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stationonmap_, lhs_arena,
      &other->_impl_.stationonmap_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.stationonpath_, lhs_arena,
      &other->_impl_.stationonpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.targetstation_, lhs_arena,
      &other->_impl_.targetstation_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AgvInfo_UIStation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[0]);
}

// ===================================================================

class AgvInfo_Motion::_Internal {
 public:
};

AgvInfo_Motion::AgvInfo_Motion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AgvInfo.Motion)
}
AgvInfo_Motion::AgvInfo_Motion(const AgvInfo_Motion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AgvInfo_Motion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vx_){}
    , decltype(_impl_.vy_){}
    , decltype(_impl_.w_){}
    , decltype(_impl_.od1_){}
    , decltype(_impl_.od2_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.vx_, &from._impl_.vx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.od2_) -
    reinterpret_cast<char*>(&_impl_.vx_)) + sizeof(_impl_.od2_));
  // @@protoc_insertion_point(copy_constructor:AgvInfo.Motion)
}

inline void AgvInfo_Motion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vx_){0}
    , decltype(_impl_.vy_){0}
    , decltype(_impl_.w_){0}
    , decltype(_impl_.od1_){0}
    , decltype(_impl_.od2_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AgvInfo_Motion::~AgvInfo_Motion() {
  // @@protoc_insertion_point(destructor:AgvInfo.Motion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AgvInfo_Motion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AgvInfo_Motion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AgvInfo_Motion::Clear() {
// @@protoc_insertion_point(message_clear_start:AgvInfo.Motion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.vx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.od2_) -
      reinterpret_cast<char*>(&_impl_.vx_)) + sizeof(_impl_.od2_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgvInfo_Motion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float vx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.vx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.vy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float w = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float od1 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.od1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float od2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.od2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgvInfo_Motion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AgvInfo.Motion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float vx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_vx(), target);
  }

  // float vy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_vy(), target);
  }

  // float w = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_w(), target);
  }

  // float od1 = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od1 = this->_internal_od1();
  uint32_t raw_od1;
  memcpy(&raw_od1, &tmp_od1, sizeof(tmp_od1));
  if (raw_od1 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_od1(), target);
  }

  // float od2 = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od2 = this->_internal_od2();
  uint32_t raw_od2;
  memcpy(&raw_od2, &tmp_od2, sizeof(tmp_od2));
  if (raw_od2 != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_od2(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AgvInfo.Motion)
  return target;
}

size_t AgvInfo_Motion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AgvInfo.Motion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float vx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    total_size += 1 + 4;
  }

  // float vy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    total_size += 1 + 4;
  }

  // float w = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  // float od1 = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od1 = this->_internal_od1();
  uint32_t raw_od1;
  memcpy(&raw_od1, &tmp_od1, sizeof(tmp_od1));
  if (raw_od1 != 0) {
    total_size += 1 + 4;
  }

  // float od2 = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od2 = this->_internal_od2();
  uint32_t raw_od2;
  memcpy(&raw_od2, &tmp_od2, sizeof(tmp_od2));
  if (raw_od2 != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgvInfo_Motion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AgvInfo_Motion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgvInfo_Motion::GetClassData() const { return &_class_data_; }


void AgvInfo_Motion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AgvInfo_Motion*>(&to_msg);
  auto& from = static_cast<const AgvInfo_Motion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AgvInfo.Motion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = from._internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    _this->_internal_set_vx(from._internal_vx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = from._internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    _this->_internal_set_vy(from._internal_vy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od1 = from._internal_od1();
  uint32_t raw_od1;
  memcpy(&raw_od1, &tmp_od1, sizeof(tmp_od1));
  if (raw_od1 != 0) {
    _this->_internal_set_od1(from._internal_od1());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_od2 = from._internal_od2();
  uint32_t raw_od2;
  memcpy(&raw_od2, &tmp_od2, sizeof(tmp_od2));
  if (raw_od2 != 0) {
    _this->_internal_set_od2(from._internal_od2());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgvInfo_Motion::CopyFrom(const AgvInfo_Motion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AgvInfo.Motion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgvInfo_Motion::IsInitialized() const {
  return true;
}

void AgvInfo_Motion::InternalSwap(AgvInfo_Motion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AgvInfo_Motion, _impl_.od2_)
      + sizeof(AgvInfo_Motion::_impl_.od2_)
      - PROTOBUF_FIELD_OFFSET(AgvInfo_Motion, _impl_.vx_)>(
          reinterpret_cast<char*>(&_impl_.vx_),
          reinterpret_cast<char*>(&other->_impl_.vx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AgvInfo_Motion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[1]);
}

// ===================================================================

class AgvInfo_Alarm::_Internal {
 public:
};

AgvInfo_Alarm::AgvInfo_Alarm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AgvInfo.Alarm)
}
AgvInfo_Alarm::AgvInfo_Alarm(const AgvInfo_Alarm& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AgvInfo_Alarm* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.level_){}
    , decltype(_impl_.code_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_message().empty()) {
    _this->_impl_.message_.Set(from._internal_message(), 
      _this->GetArenaForAllocation());
  }
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_time().empty()) {
    _this->_impl_.time_.Set(from._internal_time(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.code_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  // @@protoc_insertion_point(copy_constructor:AgvInfo.Alarm)
}

inline void AgvInfo_Alarm::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.message_){}
    , decltype(_impl_.time_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.level_){0}
    , decltype(_impl_.code_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AgvInfo_Alarm::~AgvInfo_Alarm() {
  // @@protoc_insertion_point(destructor:AgvInfo.Alarm)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AgvInfo_Alarm::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.message_.Destroy();
  _impl_.time_.Destroy();
}

void AgvInfo_Alarm::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AgvInfo_Alarm::Clear() {
// @@protoc_insertion_point(message_clear_start:AgvInfo.Alarm)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.message_.ClearToEmpty();
  _impl_.time_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.code_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.code_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgvInfo_Alarm::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .AgvInfo.Alarm.Source type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::AgvInfo_Alarm_Source>(val));
        } else
          goto handle_unusual;
        continue;
      // .AgvInfo.Alarm.Level level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_level(static_cast<::AgvInfo_Alarm_Level>(val));
        } else
          goto handle_unusual;
        continue;
      // bytes message = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgvInfo_Alarm::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AgvInfo.Alarm)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .AgvInfo.Alarm.Source type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .AgvInfo.Alarm.Level level = 2;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_level(), target);
  }

  // bytes message = 3;
  if (!this->_internal_message().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_message(), target);
  }

  // bytes time = 4;
  if (!this->_internal_time().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_time(), target);
  }

  // int32 code = 5;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AgvInfo.Alarm)
  return target;
}

size_t AgvInfo_Alarm::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AgvInfo.Alarm)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes message = 3;
  if (!this->_internal_message().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_message());
  }

  // bytes time = 4;
  if (!this->_internal_time().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_time());
  }

  // .AgvInfo.Alarm.Source type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // .AgvInfo.Alarm.Level level = 2;
  if (this->_internal_level() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_level());
  }

  // int32 code = 5;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgvInfo_Alarm::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AgvInfo_Alarm::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgvInfo_Alarm::GetClassData() const { return &_class_data_; }


void AgvInfo_Alarm::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AgvInfo_Alarm*>(&to_msg);
  auto& from = static_cast<const AgvInfo_Alarm&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AgvInfo.Alarm)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_message().empty()) {
    _this->_internal_set_message(from._internal_message());
  }
  if (!from._internal_time().empty()) {
    _this->_internal_set_time(from._internal_time());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgvInfo_Alarm::CopyFrom(const AgvInfo_Alarm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AgvInfo.Alarm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgvInfo_Alarm::IsInitialized() const {
  return true;
}

void AgvInfo_Alarm::InternalSwap(AgvInfo_Alarm* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.message_, lhs_arena,
      &other->_impl_.message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.time_, lhs_arena,
      &other->_impl_.time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AgvInfo_Alarm, _impl_.code_)
      + sizeof(AgvInfo_Alarm::_impl_.code_)
      - PROTOBUF_FIELD_OFFSET(AgvInfo_Alarm, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AgvInfo_Alarm::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[2]);
}

// ===================================================================

class AgvInfo_DebugInfo::_Internal {
 public:
};

AgvInfo_DebugInfo::AgvInfo_DebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AgvInfo.DebugInfo)
}
AgvInfo_DebugInfo::AgvInfo_DebugInfo(const AgvInfo_DebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AgvInfo_DebugInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.vx_){}
    , decltype(_impl_.vy_){}
    , decltype(_impl_.w_){}
    , decltype(_impl_.goalx_){}
    , decltype(_impl_.timestamp_){}
    , decltype(_impl_.goaly_){}
    , decltype(_impl_.taskaveragevelocity_){}
    , decltype(_impl_.totaltaskaveragevelocity_){}
    , decltype(_impl_.totalodometry_){}
    , decltype(_impl_.totalruntime_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.vx_, &from._impl_.vx_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.totalruntime_) -
    reinterpret_cast<char*>(&_impl_.vx_)) + sizeof(_impl_.totalruntime_));
  // @@protoc_insertion_point(copy_constructor:AgvInfo.DebugInfo)
}

inline void AgvInfo_DebugInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.vx_){0}
    , decltype(_impl_.vy_){0}
    , decltype(_impl_.w_){0}
    , decltype(_impl_.goalx_){0}
    , decltype(_impl_.timestamp_){uint64_t{0u}}
    , decltype(_impl_.goaly_){0}
    , decltype(_impl_.taskaveragevelocity_){0}
    , decltype(_impl_.totaltaskaveragevelocity_){0}
    , decltype(_impl_.totalodometry_){0}
    , decltype(_impl_.totalruntime_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AgvInfo_DebugInfo::~AgvInfo_DebugInfo() {
  // @@protoc_insertion_point(destructor:AgvInfo.DebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AgvInfo_DebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AgvInfo_DebugInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AgvInfo_DebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:AgvInfo.DebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.vx_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.totalruntime_) -
      reinterpret_cast<char*>(&_impl_.vx_)) + sizeof(_impl_.totalruntime_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgvInfo_DebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float Vx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.vx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float Vy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.vy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float W = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float GoalX = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.goalx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float GoalY = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.goaly_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // uint64 timestamp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float TaskAverageVelocity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.taskaveragevelocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float TotalTaskAverageVelocity = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.totaltaskaveragevelocity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float TotalOdometry = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.totalodometry_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float TotalRuntime = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.totalruntime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgvInfo_DebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AgvInfo.DebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float Vx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_vx(), target);
  }

  // float Vy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_vy(), target);
  }

  // float W = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_w(), target);
  }

  // float GoalX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goalx = this->_internal_goalx();
  uint32_t raw_goalx;
  memcpy(&raw_goalx, &tmp_goalx, sizeof(tmp_goalx));
  if (raw_goalx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_goalx(), target);
  }

  // float GoalY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goaly = this->_internal_goaly();
  uint32_t raw_goaly;
  memcpy(&raw_goaly, &tmp_goaly, sizeof(tmp_goaly));
  if (raw_goaly != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_goaly(), target);
  }

  // uint64 timestamp = 6;
  if (this->_internal_timestamp() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(6, this->_internal_timestamp(), target);
  }

  // float TaskAverageVelocity = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_taskaveragevelocity = this->_internal_taskaveragevelocity();
  uint32_t raw_taskaveragevelocity;
  memcpy(&raw_taskaveragevelocity, &tmp_taskaveragevelocity, sizeof(tmp_taskaveragevelocity));
  if (raw_taskaveragevelocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_taskaveragevelocity(), target);
  }

  // float TotalTaskAverageVelocity = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totaltaskaveragevelocity = this->_internal_totaltaskaveragevelocity();
  uint32_t raw_totaltaskaveragevelocity;
  memcpy(&raw_totaltaskaveragevelocity, &tmp_totaltaskaveragevelocity, sizeof(tmp_totaltaskaveragevelocity));
  if (raw_totaltaskaveragevelocity != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_totaltaskaveragevelocity(), target);
  }

  // float TotalOdometry = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalodometry = this->_internal_totalodometry();
  uint32_t raw_totalodometry;
  memcpy(&raw_totalodometry, &tmp_totalodometry, sizeof(tmp_totalodometry));
  if (raw_totalodometry != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_totalodometry(), target);
  }

  // float TotalRuntime = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalruntime = this->_internal_totalruntime();
  uint32_t raw_totalruntime;
  memcpy(&raw_totalruntime, &tmp_totalruntime, sizeof(tmp_totalruntime));
  if (raw_totalruntime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_totalruntime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AgvInfo.DebugInfo)
  return target;
}

size_t AgvInfo_DebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AgvInfo.DebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float Vx = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    total_size += 1 + 4;
  }

  // float Vy = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    total_size += 1 + 4;
  }

  // float W = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  // float GoalX = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goalx = this->_internal_goalx();
  uint32_t raw_goalx;
  memcpy(&raw_goalx, &tmp_goalx, sizeof(tmp_goalx));
  if (raw_goalx != 0) {
    total_size += 1 + 4;
  }

  // uint64 timestamp = 6;
  if (this->_internal_timestamp() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
  }

  // float GoalY = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goaly = this->_internal_goaly();
  uint32_t raw_goaly;
  memcpy(&raw_goaly, &tmp_goaly, sizeof(tmp_goaly));
  if (raw_goaly != 0) {
    total_size += 1 + 4;
  }

  // float TaskAverageVelocity = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_taskaveragevelocity = this->_internal_taskaveragevelocity();
  uint32_t raw_taskaveragevelocity;
  memcpy(&raw_taskaveragevelocity, &tmp_taskaveragevelocity, sizeof(tmp_taskaveragevelocity));
  if (raw_taskaveragevelocity != 0) {
    total_size += 1 + 4;
  }

  // float TotalTaskAverageVelocity = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totaltaskaveragevelocity = this->_internal_totaltaskaveragevelocity();
  uint32_t raw_totaltaskaveragevelocity;
  memcpy(&raw_totaltaskaveragevelocity, &tmp_totaltaskaveragevelocity, sizeof(tmp_totaltaskaveragevelocity));
  if (raw_totaltaskaveragevelocity != 0) {
    total_size += 1 + 4;
  }

  // float TotalOdometry = 9;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalodometry = this->_internal_totalodometry();
  uint32_t raw_totalodometry;
  memcpy(&raw_totalodometry, &tmp_totalodometry, sizeof(tmp_totalodometry));
  if (raw_totalodometry != 0) {
    total_size += 1 + 4;
  }

  // float TotalRuntime = 10;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalruntime = this->_internal_totalruntime();
  uint32_t raw_totalruntime;
  memcpy(&raw_totalruntime, &tmp_totalruntime, sizeof(tmp_totalruntime));
  if (raw_totalruntime != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgvInfo_DebugInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AgvInfo_DebugInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgvInfo_DebugInfo::GetClassData() const { return &_class_data_; }


void AgvInfo_DebugInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AgvInfo_DebugInfo*>(&to_msg);
  auto& from = static_cast<const AgvInfo_DebugInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AgvInfo.DebugInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = from._internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    _this->_internal_set_vx(from._internal_vx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = from._internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    _this->_internal_set_vy(from._internal_vy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goalx = from._internal_goalx();
  uint32_t raw_goalx;
  memcpy(&raw_goalx, &tmp_goalx, sizeof(tmp_goalx));
  if (raw_goalx != 0) {
    _this->_internal_set_goalx(from._internal_goalx());
  }
  if (from._internal_timestamp() != 0) {
    _this->_internal_set_timestamp(from._internal_timestamp());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_goaly = from._internal_goaly();
  uint32_t raw_goaly;
  memcpy(&raw_goaly, &tmp_goaly, sizeof(tmp_goaly));
  if (raw_goaly != 0) {
    _this->_internal_set_goaly(from._internal_goaly());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_taskaveragevelocity = from._internal_taskaveragevelocity();
  uint32_t raw_taskaveragevelocity;
  memcpy(&raw_taskaveragevelocity, &tmp_taskaveragevelocity, sizeof(tmp_taskaveragevelocity));
  if (raw_taskaveragevelocity != 0) {
    _this->_internal_set_taskaveragevelocity(from._internal_taskaveragevelocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totaltaskaveragevelocity = from._internal_totaltaskaveragevelocity();
  uint32_t raw_totaltaskaveragevelocity;
  memcpy(&raw_totaltaskaveragevelocity, &tmp_totaltaskaveragevelocity, sizeof(tmp_totaltaskaveragevelocity));
  if (raw_totaltaskaveragevelocity != 0) {
    _this->_internal_set_totaltaskaveragevelocity(from._internal_totaltaskaveragevelocity());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalodometry = from._internal_totalodometry();
  uint32_t raw_totalodometry;
  memcpy(&raw_totalodometry, &tmp_totalodometry, sizeof(tmp_totalodometry));
  if (raw_totalodometry != 0) {
    _this->_internal_set_totalodometry(from._internal_totalodometry());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_totalruntime = from._internal_totalruntime();
  uint32_t raw_totalruntime;
  memcpy(&raw_totalruntime, &tmp_totalruntime, sizeof(tmp_totalruntime));
  if (raw_totalruntime != 0) {
    _this->_internal_set_totalruntime(from._internal_totalruntime());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgvInfo_DebugInfo::CopyFrom(const AgvInfo_DebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AgvInfo.DebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgvInfo_DebugInfo::IsInitialized() const {
  return true;
}

void AgvInfo_DebugInfo::InternalSwap(AgvInfo_DebugInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AgvInfo_DebugInfo, _impl_.totalruntime_)
      + sizeof(AgvInfo_DebugInfo::_impl_.totalruntime_)
      - PROTOBUF_FIELD_OFFSET(AgvInfo_DebugInfo, _impl_.vx_)>(
          reinterpret_cast<char*>(&_impl_.vx_),
          reinterpret_cast<char*>(&other->_impl_.vx_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AgvInfo_DebugInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[3]);
}

// ===================================================================

class AgvInfo::_Internal {
 public:
  static const ::AgvInfo_Motion& montion(const AgvInfo* msg);
  static const ::Position& postion(const AgvInfo* msg);
  static const ::AgvInfo_UIStation& station(const AgvInfo* msg);
  static const ::Battery& battery(const AgvInfo* msg);
  static const ::PathCollection& route(const AgvInfo* msg);
  static const ::Version& version(const AgvInfo* msg);
  static const ::AgvInfo_DebugInfo& debug(const AgvInfo* msg);
  static const ::CamelSysInfo& agvsinfo(const AgvInfo* msg);
  static const ::GrpcTaskInfomation& grpctask(const AgvInfo* msg);
};

const ::AgvInfo_Motion&
AgvInfo::_Internal::montion(const AgvInfo* msg) {
  return *msg->_impl_.montion_;
}
const ::Position&
AgvInfo::_Internal::postion(const AgvInfo* msg) {
  return *msg->_impl_.postion_;
}
const ::AgvInfo_UIStation&
AgvInfo::_Internal::station(const AgvInfo* msg) {
  return *msg->_impl_.station_;
}
const ::Battery&
AgvInfo::_Internal::battery(const AgvInfo* msg) {
  return *msg->_impl_.battery_;
}
const ::PathCollection&
AgvInfo::_Internal::route(const AgvInfo* msg) {
  return *msg->_impl_.route_;
}
const ::Version&
AgvInfo::_Internal::version(const AgvInfo* msg) {
  return *msg->_impl_.version_;
}
const ::AgvInfo_DebugInfo&
AgvInfo::_Internal::debug(const AgvInfo* msg) {
  return *msg->_impl_.debug_;
}
const ::CamelSysInfo&
AgvInfo::_Internal::agvsinfo(const AgvInfo* msg) {
  return *msg->_impl_.agvsinfo_;
}
const ::GrpcTaskInfomation&
AgvInfo::_Internal::grpctask(const AgvInfo* msg) {
  return *msg->_impl_.grpctask_;
}
void AgvInfo::clear_postion() {
  if (GetArenaForAllocation() == nullptr && _impl_.postion_ != nullptr) {
    delete _impl_.postion_;
  }
  _impl_.postion_ = nullptr;
}
void AgvInfo::clear_battery() {
  if (GetArenaForAllocation() == nullptr && _impl_.battery_ != nullptr) {
    delete _impl_.battery_;
  }
  _impl_.battery_ = nullptr;
}
void AgvInfo::clear_route() {
  if (GetArenaForAllocation() == nullptr && _impl_.route_ != nullptr) {
    delete _impl_.route_;
  }
  _impl_.route_ = nullptr;
}
void AgvInfo::clear_grpctask() {
  if (GetArenaForAllocation() == nullptr && _impl_.grpctask_ != nullptr) {
    delete _impl_.grpctask_;
  }
  _impl_.grpctask_ = nullptr;
}
AgvInfo::AgvInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AgvInfo)
}
AgvInfo::AgvInfo(const AgvInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AgvInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.alarm_){from._impl_.alarm_}
    , decltype(_impl_.montion_){nullptr}
    , decltype(_impl_.postion_){nullptr}
    , decltype(_impl_.station_){nullptr}
    , decltype(_impl_.battery_){nullptr}
    , decltype(_impl_.route_){nullptr}
    , decltype(_impl_.version_){nullptr}
    , decltype(_impl_.debug_){nullptr}
    , decltype(_impl_.agvsinfo_){nullptr}
    , decltype(_impl_.grpctask_){nullptr}
    , decltype(_impl_.runmode_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.runstatus_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_montion()) {
    _this->_impl_.montion_ = new ::AgvInfo_Motion(*from._impl_.montion_);
  }
  if (from._internal_has_postion()) {
    _this->_impl_.postion_ = new ::Position(*from._impl_.postion_);
  }
  if (from._internal_has_station()) {
    _this->_impl_.station_ = new ::AgvInfo_UIStation(*from._impl_.station_);
  }
  if (from._internal_has_battery()) {
    _this->_impl_.battery_ = new ::Battery(*from._impl_.battery_);
  }
  if (from._internal_has_route()) {
    _this->_impl_.route_ = new ::PathCollection(*from._impl_.route_);
  }
  if (from._internal_has_version()) {
    _this->_impl_.version_ = new ::Version(*from._impl_.version_);
  }
  if (from._internal_has_debug()) {
    _this->_impl_.debug_ = new ::AgvInfo_DebugInfo(*from._impl_.debug_);
  }
  if (from._internal_has_agvsinfo()) {
    _this->_impl_.agvsinfo_ = new ::CamelSysInfo(*from._impl_.agvsinfo_);
  }
  if (from._internal_has_grpctask()) {
    _this->_impl_.grpctask_ = new ::GrpcTaskInfomation(*from._impl_.grpctask_);
  }
  ::memcpy(&_impl_.runmode_, &from._impl_.runmode_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.runstatus_) -
    reinterpret_cast<char*>(&_impl_.runmode_)) + sizeof(_impl_.runstatus_));
  // @@protoc_insertion_point(copy_constructor:AgvInfo)
}

inline void AgvInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.alarm_){arena}
    , decltype(_impl_.montion_){nullptr}
    , decltype(_impl_.postion_){nullptr}
    , decltype(_impl_.station_){nullptr}
    , decltype(_impl_.battery_){nullptr}
    , decltype(_impl_.route_){nullptr}
    , decltype(_impl_.version_){nullptr}
    , decltype(_impl_.debug_){nullptr}
    , decltype(_impl_.agvsinfo_){nullptr}
    , decltype(_impl_.grpctask_){nullptr}
    , decltype(_impl_.runmode_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.runstatus_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AgvInfo::~AgvInfo() {
  // @@protoc_insertion_point(destructor:AgvInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AgvInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.alarm_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.montion_;
  if (this != internal_default_instance()) delete _impl_.postion_;
  if (this != internal_default_instance()) delete _impl_.station_;
  if (this != internal_default_instance()) delete _impl_.battery_;
  if (this != internal_default_instance()) delete _impl_.route_;
  if (this != internal_default_instance()) delete _impl_.version_;
  if (this != internal_default_instance()) delete _impl_.debug_;
  if (this != internal_default_instance()) delete _impl_.agvsinfo_;
  if (this != internal_default_instance()) delete _impl_.grpctask_;
}

void AgvInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AgvInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:AgvInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.alarm_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.montion_ != nullptr) {
    delete _impl_.montion_;
  }
  _impl_.montion_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.postion_ != nullptr) {
    delete _impl_.postion_;
  }
  _impl_.postion_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.station_ != nullptr) {
    delete _impl_.station_;
  }
  _impl_.station_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.battery_ != nullptr) {
    delete _impl_.battery_;
  }
  _impl_.battery_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.route_ != nullptr) {
    delete _impl_.route_;
  }
  _impl_.route_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.version_ != nullptr) {
    delete _impl_.version_;
  }
  _impl_.version_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.debug_ != nullptr) {
    delete _impl_.debug_;
  }
  _impl_.debug_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.agvsinfo_ != nullptr) {
    delete _impl_.agvsinfo_;
  }
  _impl_.agvsinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.grpctask_ != nullptr) {
    delete _impl_.grpctask_;
  }
  _impl_.grpctask_ = nullptr;
  ::memset(&_impl_.runmode_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.runstatus_) -
      reinterpret_cast<char*>(&_impl_.runmode_)) + sizeof(_impl_.runstatus_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AgvInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .AgvInfo.Motion montion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_montion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Position postion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_postion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AgvInfo.UIStation station = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_station(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .AgvInfo.Alarm alarm = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alarm(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Battery battery = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_battery(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 runMode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.runmode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float height = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .PathCollection route = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_route(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 runStatus = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.runstatus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Version version = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_version(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .AgvInfo.DebugInfo debug = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CamelSysInfo agvsInfo = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_agvsinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .GrpcTaskInfomation grpcTask = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_grpctask(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AgvInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AgvInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .AgvInfo.Motion montion = 1;
  if (this->_internal_has_montion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::montion(this),
        _Internal::montion(this).GetCachedSize(), target, stream);
  }

  // .Position postion = 2;
  if (this->_internal_has_postion()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::postion(this),
        _Internal::postion(this).GetCachedSize(), target, stream);
  }

  // .AgvInfo.UIStation station = 3;
  if (this->_internal_has_station()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::station(this),
        _Internal::station(this).GetCachedSize(), target, stream);
  }

  // repeated .AgvInfo.Alarm alarm = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alarm_size()); i < n; i++) {
    const auto& repfield = this->_internal_alarm(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Battery battery = 5;
  if (this->_internal_has_battery()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::battery(this),
        _Internal::battery(this).GetCachedSize(), target, stream);
  }

  // int32 runMode = 6;
  if (this->_internal_runmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_runmode(), target);
  }

  // float height = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_height(), target);
  }

  // .PathCollection route = 9;
  if (this->_internal_has_route()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::route(this),
        _Internal::route(this).GetCachedSize(), target, stream);
  }

  // int32 runStatus = 10;
  if (this->_internal_runstatus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_runstatus(), target);
  }

  // .Version version = 11;
  if (this->_internal_has_version()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::version(this),
        _Internal::version(this).GetCachedSize(), target, stream);
  }

  // .AgvInfo.DebugInfo debug = 12;
  if (this->_internal_has_debug()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::debug(this),
        _Internal::debug(this).GetCachedSize(), target, stream);
  }

  // .CamelSysInfo agvsInfo = 13;
  if (this->_internal_has_agvsinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::agvsinfo(this),
        _Internal::agvsinfo(this).GetCachedSize(), target, stream);
  }

  // .GrpcTaskInfomation grpcTask = 14;
  if (this->_internal_has_grpctask()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::grpctask(this),
        _Internal::grpctask(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AgvInfo)
  return target;
}

size_t AgvInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AgvInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .AgvInfo.Alarm alarm = 4;
  total_size += 1UL * this->_internal_alarm_size();
  for (const auto& msg : this->_impl_.alarm_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .AgvInfo.Motion montion = 1;
  if (this->_internal_has_montion()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.montion_);
  }

  // .Position postion = 2;
  if (this->_internal_has_postion()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.postion_);
  }

  // .AgvInfo.UIStation station = 3;
  if (this->_internal_has_station()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.station_);
  }

  // .Battery battery = 5;
  if (this->_internal_has_battery()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.battery_);
  }

  // .PathCollection route = 9;
  if (this->_internal_has_route()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.route_);
  }

  // .Version version = 11;
  if (this->_internal_has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.version_);
  }

  // .AgvInfo.DebugInfo debug = 12;
  if (this->_internal_has_debug()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.debug_);
  }

  // .CamelSysInfo agvsInfo = 13;
  if (this->_internal_has_agvsinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.agvsinfo_);
  }

  // .GrpcTaskInfomation grpcTask = 14;
  if (this->_internal_has_grpctask()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.grpctask_);
  }

  // int32 runMode = 6;
  if (this->_internal_runmode() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_runmode());
  }

  // float height = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 4;
  }

  // int32 runStatus = 10;
  if (this->_internal_runstatus() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_runstatus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AgvInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AgvInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AgvInfo::GetClassData() const { return &_class_data_; }


void AgvInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AgvInfo*>(&to_msg);
  auto& from = static_cast<const AgvInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AgvInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.alarm_.MergeFrom(from._impl_.alarm_);
  if (from._internal_has_montion()) {
    _this->_internal_mutable_montion()->::AgvInfo_Motion::MergeFrom(
        from._internal_montion());
  }
  if (from._internal_has_postion()) {
    _this->_internal_mutable_postion()->::Position::MergeFrom(
        from._internal_postion());
  }
  if (from._internal_has_station()) {
    _this->_internal_mutable_station()->::AgvInfo_UIStation::MergeFrom(
        from._internal_station());
  }
  if (from._internal_has_battery()) {
    _this->_internal_mutable_battery()->::Battery::MergeFrom(
        from._internal_battery());
  }
  if (from._internal_has_route()) {
    _this->_internal_mutable_route()->::PathCollection::MergeFrom(
        from._internal_route());
  }
  if (from._internal_has_version()) {
    _this->_internal_mutable_version()->::Version::MergeFrom(
        from._internal_version());
  }
  if (from._internal_has_debug()) {
    _this->_internal_mutable_debug()->::AgvInfo_DebugInfo::MergeFrom(
        from._internal_debug());
  }
  if (from._internal_has_agvsinfo()) {
    _this->_internal_mutable_agvsinfo()->::CamelSysInfo::MergeFrom(
        from._internal_agvsinfo());
  }
  if (from._internal_has_grpctask()) {
    _this->_internal_mutable_grpctask()->::GrpcTaskInfomation::MergeFrom(
        from._internal_grpctask());
  }
  if (from._internal_runmode() != 0) {
    _this->_internal_set_runmode(from._internal_runmode());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = from._internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_runstatus() != 0) {
    _this->_internal_set_runstatus(from._internal_runstatus());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AgvInfo::CopyFrom(const AgvInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AgvInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AgvInfo::IsInitialized() const {
  return true;
}

void AgvInfo::InternalSwap(AgvInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.alarm_.InternalSwap(&other->_impl_.alarm_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AgvInfo, _impl_.runstatus_)
      + sizeof(AgvInfo::_impl_.runstatus_)
      - PROTOBUF_FIELD_OFFSET(AgvInfo, _impl_.montion_)>(
          reinterpret_cast<char*>(&_impl_.montion_),
          reinterpret_cast<char*>(&other->_impl_.montion_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AgvInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[4]);
}

// ===================================================================

class UIConfig::_Internal {
 public:
};

UIConfig::UIConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UIConfig)
}
UIConfig::UIConfig(const UIConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UIConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.navendpoint_){}
    , decltype(_impl_.language_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.navendpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.navendpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_navendpoint().empty()) {
    _this->_impl_.navendpoint_.Set(from._internal_navendpoint(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.language_ = from._impl_.language_;
  // @@protoc_insertion_point(copy_constructor:UIConfig)
}

inline void UIConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.navendpoint_){}
    , decltype(_impl_.language_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.navendpoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.navendpoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UIConfig::~UIConfig() {
  // @@protoc_insertion_point(destructor:UIConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UIConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.navendpoint_.Destroy();
}

void UIConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UIConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:UIConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.navendpoint_.ClearToEmpty();
  _impl_.language_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UIConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string navEndpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_navendpoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "UIConfig.navEndpoint"));
        } else
          goto handle_unusual;
        continue;
      // .Language language = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_language(static_cast<::Language>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UIConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UIConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string navEndpoint = 1;
  if (!this->_internal_navendpoint().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_navendpoint().data(), static_cast<int>(this->_internal_navendpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "UIConfig.navEndpoint");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_navendpoint(), target);
  }

  // .Language language = 2;
  if (this->_internal_language() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UIConfig)
  return target;
}

size_t UIConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UIConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string navEndpoint = 1;
  if (!this->_internal_navendpoint().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_navendpoint());
  }

  // .Language language = 2;
  if (this->_internal_language() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_language());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UIConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UIConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UIConfig::GetClassData() const { return &_class_data_; }


void UIConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UIConfig*>(&to_msg);
  auto& from = static_cast<const UIConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UIConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_navendpoint().empty()) {
    _this->_internal_set_navendpoint(from._internal_navendpoint());
  }
  if (from._internal_language() != 0) {
    _this->_internal_set_language(from._internal_language());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UIConfig::CopyFrom(const UIConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UIConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UIConfig::IsInitialized() const {
  return true;
}

void UIConfig::InternalSwap(UIConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.navendpoint_, lhs_arena,
      &other->_impl_.navendpoint_, rhs_arena
  );
  swap(_impl_.language_, other->_impl_.language_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UIConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[5]);
}

// ===================================================================

class Version::_Internal {
 public:
};

Version::Version(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Version)
}
Version::Version(const Version& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Version* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.camelversion_){}
    , decltype(_impl_.dbversion_){}
    , decltype(_impl_.defenderversion_){}
    , decltype(_impl_.packageversion_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.camelversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.camelversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_camelversion().empty()) {
    _this->_impl_.camelversion_.Set(from._internal_camelversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dbversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dbversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dbversion().empty()) {
    _this->_impl_.dbversion_.Set(from._internal_dbversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.defenderversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.defenderversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_defenderversion().empty()) {
    _this->_impl_.defenderversion_.Set(from._internal_defenderversion(), 
      _this->GetArenaForAllocation());
  }
  _impl_.packageversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packageversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_packageversion().empty()) {
    _this->_impl_.packageversion_.Set(from._internal_packageversion(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Version)
}

inline void Version::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.camelversion_){}
    , decltype(_impl_.dbversion_){}
    , decltype(_impl_.defenderversion_){}
    , decltype(_impl_.packageversion_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.camelversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.camelversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dbversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dbversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.defenderversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.defenderversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.packageversion_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.packageversion_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Version::~Version() {
  // @@protoc_insertion_point(destructor:Version)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Version::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.camelversion_.Destroy();
  _impl_.dbversion_.Destroy();
  _impl_.defenderversion_.Destroy();
  _impl_.packageversion_.Destroy();
}

void Version::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Version::Clear() {
// @@protoc_insertion_point(message_clear_start:Version)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.camelversion_.ClearToEmpty();
  _impl_.dbversion_.ClearToEmpty();
  _impl_.defenderversion_.ClearToEmpty();
  _impl_.packageversion_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Version::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string CamelVersion = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_camelversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Version.CamelVersion"));
        } else
          goto handle_unusual;
        continue;
      // bytes DBVersion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_dbversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string DefenderVersion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_defenderversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Version.DefenderVersion"));
        } else
          goto handle_unusual;
        continue;
      // string PackageVersion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_packageversion();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Version.PackageVersion"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Version::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Version)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string CamelVersion = 1;
  if (!this->_internal_camelversion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_camelversion().data(), static_cast<int>(this->_internal_camelversion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Version.CamelVersion");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_camelversion(), target);
  }

  // bytes DBVersion = 2;
  if (!this->_internal_dbversion().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_dbversion(), target);
  }

  // string DefenderVersion = 3;
  if (!this->_internal_defenderversion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_defenderversion().data(), static_cast<int>(this->_internal_defenderversion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Version.DefenderVersion");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_defenderversion(), target);
  }

  // string PackageVersion = 4;
  if (!this->_internal_packageversion().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_packageversion().data(), static_cast<int>(this->_internal_packageversion().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Version.PackageVersion");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_packageversion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Version)
  return target;
}

size_t Version::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Version)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string CamelVersion = 1;
  if (!this->_internal_camelversion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_camelversion());
  }

  // bytes DBVersion = 2;
  if (!this->_internal_dbversion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_dbversion());
  }

  // string DefenderVersion = 3;
  if (!this->_internal_defenderversion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_defenderversion());
  }

  // string PackageVersion = 4;
  if (!this->_internal_packageversion().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_packageversion());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Version::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Version::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Version::GetClassData() const { return &_class_data_; }


void Version::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Version*>(&to_msg);
  auto& from = static_cast<const Version&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Version)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_camelversion().empty()) {
    _this->_internal_set_camelversion(from._internal_camelversion());
  }
  if (!from._internal_dbversion().empty()) {
    _this->_internal_set_dbversion(from._internal_dbversion());
  }
  if (!from._internal_defenderversion().empty()) {
    _this->_internal_set_defenderversion(from._internal_defenderversion());
  }
  if (!from._internal_packageversion().empty()) {
    _this->_internal_set_packageversion(from._internal_packageversion());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Version::CopyFrom(const Version& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Version)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Version::IsInitialized() const {
  return true;
}

void Version::InternalSwap(Version* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.camelversion_, lhs_arena,
      &other->_impl_.camelversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dbversion_, lhs_arena,
      &other->_impl_.dbversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.defenderversion_, lhs_arena,
      &other->_impl_.defenderversion_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.packageversion_, lhs_arena,
      &other->_impl_.packageversion_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Version::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[6]);
}

// ===================================================================

class Operation::_Internal {
 public:
};

Operation::Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Operation)
}
Operation::Operation(const Operation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Operation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.iscontinue_){}
    , decltype(_impl_.clearpath_){}
    , decltype(_impl_.clearaction_){}
    , decltype(_impl_.disablecargo_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.iscontinue_, &from._impl_.iscontinue_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disablecargo_) -
    reinterpret_cast<char*>(&_impl_.iscontinue_)) + sizeof(_impl_.disablecargo_));
  // @@protoc_insertion_point(copy_constructor:Operation)
}

inline void Operation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.iscontinue_){false}
    , decltype(_impl_.clearpath_){false}
    , decltype(_impl_.clearaction_){false}
    , decltype(_impl_.disablecargo_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Operation::~Operation() {
  // @@protoc_insertion_point(destructor:Operation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Operation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Operation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:Operation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.iscontinue_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.disablecargo_) -
      reinterpret_cast<char*>(&_impl_.iscontinue_)) + sizeof(_impl_.disablecargo_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Operation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool isContinue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.iscontinue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool clearPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.clearpath_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool clearAction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.clearaction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool disableCargo = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.disablecargo_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Operation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Operation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool isContinue = 1;
  if (this->_internal_iscontinue() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_iscontinue(), target);
  }

  // bool clearPath = 2;
  if (this->_internal_clearpath() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_clearpath(), target);
  }

  // bool clearAction = 3;
  if (this->_internal_clearaction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_clearaction(), target);
  }

  // bool disableCargo = 4;
  if (this->_internal_disablecargo() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_disablecargo(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Operation)
  return target;
}

size_t Operation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Operation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool isContinue = 1;
  if (this->_internal_iscontinue() != 0) {
    total_size += 1 + 1;
  }

  // bool clearPath = 2;
  if (this->_internal_clearpath() != 0) {
    total_size += 1 + 1;
  }

  // bool clearAction = 3;
  if (this->_internal_clearaction() != 0) {
    total_size += 1 + 1;
  }

  // bool disableCargo = 4;
  if (this->_internal_disablecargo() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Operation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Operation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Operation::GetClassData() const { return &_class_data_; }


void Operation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Operation*>(&to_msg);
  auto& from = static_cast<const Operation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Operation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_iscontinue() != 0) {
    _this->_internal_set_iscontinue(from._internal_iscontinue());
  }
  if (from._internal_clearpath() != 0) {
    _this->_internal_set_clearpath(from._internal_clearpath());
  }
  if (from._internal_clearaction() != 0) {
    _this->_internal_set_clearaction(from._internal_clearaction());
  }
  if (from._internal_disablecargo() != 0) {
    _this->_internal_set_disablecargo(from._internal_disablecargo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Operation::CopyFrom(const Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Operation::IsInitialized() const {
  return true;
}

void Operation::InternalSwap(Operation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Operation, _impl_.disablecargo_)
      + sizeof(Operation::_impl_.disablecargo_)
      - PROTOBUF_FIELD_OFFSET(Operation, _impl_.iscontinue_)>(
          reinterpret_cast<char*>(&_impl_.iscontinue_),
          reinterpret_cast<char*>(&other->_impl_.iscontinue_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Operation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[7]);
}

// ===================================================================

class CamelCfg::_Internal {
 public:
};

CamelCfg::CamelCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CamelCfg)
}
CamelCfg::CamelCfg(const CamelCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CamelCfg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.jsonstring_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.jsonstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jsonstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_jsonstring().empty()) {
    _this->_impl_.jsonstring_.Set(from._internal_jsonstring(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CamelCfg)
}

inline void CamelCfg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.jsonstring_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.jsonstring_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.jsonstring_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CamelCfg::~CamelCfg() {
  // @@protoc_insertion_point(destructor:CamelCfg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CamelCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.jsonstring_.Destroy();
}

void CamelCfg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CamelCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:CamelCfg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.jsonstring_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CamelCfg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string JsonString = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_jsonstring();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CamelCfg.JsonString"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CamelCfg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CamelCfg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string JsonString = 1;
  if (!this->_internal_jsonstring().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_jsonstring().data(), static_cast<int>(this->_internal_jsonstring().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CamelCfg.JsonString");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_jsonstring(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CamelCfg)
  return target;
}

size_t CamelCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CamelCfg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string JsonString = 1;
  if (!this->_internal_jsonstring().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_jsonstring());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CamelCfg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CamelCfg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CamelCfg::GetClassData() const { return &_class_data_; }


void CamelCfg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CamelCfg*>(&to_msg);
  auto& from = static_cast<const CamelCfg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CamelCfg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_jsonstring().empty()) {
    _this->_internal_set_jsonstring(from._internal_jsonstring());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CamelCfg::CopyFrom(const CamelCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CamelCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CamelCfg::IsInitialized() const {
  return true;
}

void CamelCfg::InternalSwap(CamelCfg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.jsonstring_, lhs_arena,
      &other->_impl_.jsonstring_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CamelCfg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[8]);
}

// ===================================================================

class CamelSysInfo::_Internal {
 public:
  static const ::CamelMessage_AllowFromAgvs& agvsinfo(const CamelSysInfo* msg);
  static const ::CamelMessage_MissonFromAgvs& taskinfo(const CamelSysInfo* msg);
};

const ::CamelMessage_AllowFromAgvs&
CamelSysInfo::_Internal::agvsinfo(const CamelSysInfo* msg) {
  return *msg->_impl_.agvsinfo_;
}
const ::CamelMessage_MissonFromAgvs&
CamelSysInfo::_Internal::taskinfo(const CamelSysInfo* msg) {
  return *msg->_impl_.taskinfo_;
}
void CamelSysInfo::clear_agvsinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.agvsinfo_ != nullptr) {
    delete _impl_.agvsinfo_;
  }
  _impl_.agvsinfo_ = nullptr;
}
void CamelSysInfo::clear_taskinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.taskinfo_ != nullptr) {
    delete _impl_.taskinfo_;
  }
  _impl_.taskinfo_ = nullptr;
}
CamelSysInfo::CamelSysInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CamelSysInfo)
}
CamelSysInfo::CamelSysInfo(const CamelSysInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CamelSysInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.agvsinfo_){nullptr}
    , decltype(_impl_.taskinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_agvsinfo()) {
    _this->_impl_.agvsinfo_ = new ::CamelMessage_AllowFromAgvs(*from._impl_.agvsinfo_);
  }
  if (from._internal_has_taskinfo()) {
    _this->_impl_.taskinfo_ = new ::CamelMessage_MissonFromAgvs(*from._impl_.taskinfo_);
  }
  // @@protoc_insertion_point(copy_constructor:CamelSysInfo)
}

inline void CamelSysInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.agvsinfo_){nullptr}
    , decltype(_impl_.taskinfo_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CamelSysInfo::~CamelSysInfo() {
  // @@protoc_insertion_point(destructor:CamelSysInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CamelSysInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.agvsinfo_;
  if (this != internal_default_instance()) delete _impl_.taskinfo_;
}

void CamelSysInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CamelSysInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CamelSysInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.agvsinfo_ != nullptr) {
    delete _impl_.agvsinfo_;
  }
  _impl_.agvsinfo_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.taskinfo_ != nullptr) {
    delete _impl_.taskinfo_;
  }
  _impl_.taskinfo_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CamelSysInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .CamelMessage.AllowFromAgvs agvsInfo = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_agvsinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CamelMessage.MissonFromAgvs taskInfo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_taskinfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CamelSysInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CamelSysInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .CamelMessage.AllowFromAgvs agvsInfo = 1;
  if (this->_internal_has_agvsinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::agvsinfo(this),
        _Internal::agvsinfo(this).GetCachedSize(), target, stream);
  }

  // .CamelMessage.MissonFromAgvs taskInfo = 2;
  if (this->_internal_has_taskinfo()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::taskinfo(this),
        _Internal::taskinfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CamelSysInfo)
  return target;
}

size_t CamelSysInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CamelSysInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .CamelMessage.AllowFromAgvs agvsInfo = 1;
  if (this->_internal_has_agvsinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.agvsinfo_);
  }

  // .CamelMessage.MissonFromAgvs taskInfo = 2;
  if (this->_internal_has_taskinfo()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.taskinfo_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CamelSysInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CamelSysInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CamelSysInfo::GetClassData() const { return &_class_data_; }


void CamelSysInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CamelSysInfo*>(&to_msg);
  auto& from = static_cast<const CamelSysInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CamelSysInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_agvsinfo()) {
    _this->_internal_mutable_agvsinfo()->::CamelMessage_AllowFromAgvs::MergeFrom(
        from._internal_agvsinfo());
  }
  if (from._internal_has_taskinfo()) {
    _this->_internal_mutable_taskinfo()->::CamelMessage_MissonFromAgvs::MergeFrom(
        from._internal_taskinfo());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CamelSysInfo::CopyFrom(const CamelSysInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CamelSysInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CamelSysInfo::IsInitialized() const {
  return true;
}

void CamelSysInfo::InternalSwap(CamelSysInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CamelSysInfo, _impl_.taskinfo_)
      + sizeof(CamelSysInfo::_impl_.taskinfo_)
      - PROTOBUF_FIELD_OFFSET(CamelSysInfo, _impl_.agvsinfo_)>(
          reinterpret_cast<char*>(&_impl_.agvsinfo_),
          reinterpret_cast<char*>(&other->_impl_.agvsinfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CamelSysInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[9]);
}

// ===================================================================

class LogRequest::_Internal {
 public:
};

LogRequest::LogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LogRequest)
}
LogRequest::LogRequest(const LogRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.modules_){from._impl_.modules_}
    , decltype(_impl_.time_){from._impl_.time_}
    , decltype(_impl_.car_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.car_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.car_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_car().empty()) {
    _this->_impl_.car_.Set(from._internal_car(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:LogRequest)
}

inline void LogRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.modules_){arena}
    , decltype(_impl_.time_){arena}
    , decltype(_impl_.car_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.car_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.car_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogRequest::~LogRequest() {
  // @@protoc_insertion_point(destructor:LogRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.modules_.~RepeatedPtrField();
  _impl_.time_.~RepeatedPtrField();
  _impl_.car_.Destroy();
}

void LogRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:LogRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.modules_.Clear();
  _impl_.time_.Clear();
  _impl_.car_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string car = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_car();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LogRequest.car"));
        } else
          goto handle_unusual;
        continue;
      // repeated string modules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_modules();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "LogRequest.modules"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_time();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "LogRequest.time"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LogRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string car = 1;
  if (!this->_internal_car().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_car().data(), static_cast<int>(this->_internal_car().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LogRequest.car");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_car(), target);
  }

  // repeated string modules = 2;
  for (int i = 0, n = this->_internal_modules_size(); i < n; i++) {
    const auto& s = this->_internal_modules(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LogRequest.modules");
    target = stream->WriteString(2, s, target);
  }

  // repeated string time = 3;
  for (int i = 0, n = this->_internal_time_size(); i < n; i++) {
    const auto& s = this->_internal_time(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LogRequest.time");
    target = stream->WriteString(3, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LogRequest)
  return target;
}

size_t LogRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LogRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string modules = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.modules_.size());
  for (int i = 0, n = _impl_.modules_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.modules_.Get(i));
  }

  // repeated string time = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.time_.size());
  for (int i = 0, n = _impl_.time_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.time_.Get(i));
  }

  // string car = 1;
  if (!this->_internal_car().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_car());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogRequest::GetClassData() const { return &_class_data_; }


void LogRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogRequest*>(&to_msg);
  auto& from = static_cast<const LogRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LogRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.modules_.MergeFrom(from._impl_.modules_);
  _this->_impl_.time_.MergeFrom(from._impl_.time_);
  if (!from._internal_car().empty()) {
    _this->_internal_set_car(from._internal_car());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogRequest::CopyFrom(const LogRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LogRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogRequest::IsInitialized() const {
  return true;
}

void LogRequest::InternalSwap(LogRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.modules_.InternalSwap(&other->_impl_.modules_);
  _impl_.time_.InternalSwap(&other->_impl_.time_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.car_, lhs_arena,
      &other->_impl_.car_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LogRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[10]);
}

// ===================================================================

class LogResponse::_Internal {
 public:
};

LogResponse::LogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:LogResponse)
}
LogResponse::LogResponse(const LogResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  LogResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_path().empty()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:LogResponse)
}

inline void LogResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.path_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogResponse::~LogResponse() {
  // @@protoc_insertion_point(destructor:LogResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void LogResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
}

void LogResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void LogResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:LogResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.path_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "LogResponse.path"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* LogResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LogResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "LogResponse.path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LogResponse)
  return target;
}

size_t LogResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LogResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string path = 1;
  if (!this->_internal_path().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_path());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData LogResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    LogResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*LogResponse::GetClassData() const { return &_class_data_; }


void LogResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<LogResponse*>(&to_msg);
  auto& from = static_cast<const LogResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:LogResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_path().empty()) {
    _this->_internal_set_path(from._internal_path());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void LogResponse::CopyFrom(const LogResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LogResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogResponse::IsInitialized() const {
  return true;
}

void LogResponse::InternalSwap(LogResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata LogResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[11]);
}

// ===================================================================

class RosNode::_Internal {
 public:
};

RosNode::RosNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RosNode)
}
RosNode::RosNode(const RosNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RosNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.configuration_){}
    , decltype(_impl_.module_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.modify_enable_){}
    , decltype(_impl_.set_master_){}
    , decltype(_impl_.is_running_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_configuration().empty()) {
    _this->_impl_.configuration_.Set(from._internal_configuration(), 
      _this->GetArenaForAllocation());
  }
  _impl_.module_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_module().empty()) {
    _this->_impl_.module_.Set(from._internal_module(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filename().empty()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.modify_enable_, &from._impl_.modify_enable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_running_) -
    reinterpret_cast<char*>(&_impl_.modify_enable_)) + sizeof(_impl_.is_running_));
  // @@protoc_insertion_point(copy_constructor:RosNode)
}

inline void RosNode::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.configuration_){}
    , decltype(_impl_.module_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.modify_enable_){false}
    , decltype(_impl_.set_master_){false}
    , decltype(_impl_.is_running_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.configuration_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.configuration_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.module_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.module_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RosNode::~RosNode() {
  // @@protoc_insertion_point(destructor:RosNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RosNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.configuration_.Destroy();
  _impl_.module_.Destroy();
  _impl_.filename_.Destroy();
}

void RosNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RosNode::Clear() {
// @@protoc_insertion_point(message_clear_start:RosNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.configuration_.ClearToEmpty();
  _impl_.module_.ClearToEmpty();
  _impl_.filename_.ClearToEmpty();
  ::memset(&_impl_.modify_enable_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.is_running_) -
      reinterpret_cast<char*>(&_impl_.modify_enable_)) + sizeof(_impl_.is_running_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RosNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string configuration = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_configuration();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosNode.configuration"));
        } else
          goto handle_unusual;
        continue;
      // bool modify_enable = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.modify_enable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool set_master = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.set_master_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string module = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_module();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosNode.module"));
        } else
          goto handle_unusual;
        continue;
      // string filename = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosNode.filename"));
        } else
          goto handle_unusual;
        continue;
      // bool is_running = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.is_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RosNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RosNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string configuration = 1;
  if (!this->_internal_configuration().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_configuration().data(), static_cast<int>(this->_internal_configuration().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosNode.configuration");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_configuration(), target);
  }

  // bool modify_enable = 2;
  if (this->_internal_modify_enable() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_modify_enable(), target);
  }

  // bool set_master = 3;
  if (this->_internal_set_master() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_set_master(), target);
  }

  // string module = 4;
  if (!this->_internal_module().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_module().data(), static_cast<int>(this->_internal_module().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosNode.module");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_module(), target);
  }

  // string filename = 5;
  if (!this->_internal_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosNode.filename");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_filename(), target);
  }

  // bool is_running = 6;
  if (this->_internal_is_running() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_running(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RosNode)
  return target;
}

size_t RosNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RosNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string configuration = 1;
  if (!this->_internal_configuration().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_configuration());
  }

  // string module = 4;
  if (!this->_internal_module().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_module());
  }

  // string filename = 5;
  if (!this->_internal_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  // bool modify_enable = 2;
  if (this->_internal_modify_enable() != 0) {
    total_size += 1 + 1;
  }

  // bool set_master = 3;
  if (this->_internal_set_master() != 0) {
    total_size += 1 + 1;
  }

  // bool is_running = 6;
  if (this->_internal_is_running() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RosNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RosNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RosNode::GetClassData() const { return &_class_data_; }


void RosNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RosNode*>(&to_msg);
  auto& from = static_cast<const RosNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RosNode)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_configuration().empty()) {
    _this->_internal_set_configuration(from._internal_configuration());
  }
  if (!from._internal_module().empty()) {
    _this->_internal_set_module(from._internal_module());
  }
  if (!from._internal_filename().empty()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  if (from._internal_modify_enable() != 0) {
    _this->_internal_set_modify_enable(from._internal_modify_enable());
  }
  if (from._internal_set_master() != 0) {
    _this->_internal_set_set_master(from._internal_set_master());
  }
  if (from._internal_is_running() != 0) {
    _this->_internal_set_is_running(from._internal_is_running());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RosNode::CopyFrom(const RosNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RosNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosNode::IsInitialized() const {
  return true;
}

void RosNode::InternalSwap(RosNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.configuration_, lhs_arena,
      &other->_impl_.configuration_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.module_, lhs_arena,
      &other->_impl_.module_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RosNode, _impl_.is_running_)
      + sizeof(RosNode::_impl_.is_running_)
      - PROTOBUF_FIELD_OFFSET(RosNode, _impl_.modify_enable_)>(
          reinterpret_cast<char*>(&_impl_.modify_enable_),
          reinterpret_cast<char*>(&other->_impl_.modify_enable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RosNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[12]);
}

// ===================================================================

class RosNodesCfg::_Internal {
 public:
};

RosNodesCfg::RosNodesCfg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RosNodesCfg)
}
RosNodesCfg::RosNodesCfg(const RosNodesCfg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RosNodesCfg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){from._impl_.nodes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:RosNodesCfg)
}

inline void RosNodesCfg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.nodes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RosNodesCfg::~RosNodesCfg() {
  // @@protoc_insertion_point(destructor:RosNodesCfg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RosNodesCfg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.nodes_.~RepeatedPtrField();
}

void RosNodesCfg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RosNodesCfg::Clear() {
// @@protoc_insertion_point(message_clear_start:RosNodesCfg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.nodes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RosNodesCfg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .RosNode nodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RosNodesCfg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RosNodesCfg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .RosNode nodes = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nodes_size()); i < n; i++) {
    const auto& repfield = this->_internal_nodes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RosNodesCfg)
  return target;
}

size_t RosNodesCfg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RosNodesCfg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RosNode nodes = 1;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->_impl_.nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RosNodesCfg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RosNodesCfg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RosNodesCfg::GetClassData() const { return &_class_data_; }


void RosNodesCfg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RosNodesCfg*>(&to_msg);
  auto& from = static_cast<const RosNodesCfg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RosNodesCfg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.nodes_.MergeFrom(from._impl_.nodes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RosNodesCfg::CopyFrom(const RosNodesCfg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RosNodesCfg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosNodesCfg::IsInitialized() const {
  return true;
}

void RosNodesCfg::InternalSwap(RosNodesCfg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.nodes_.InternalSwap(&other->_impl_.nodes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RosNodesCfg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[13]);
}

// ===================================================================

class RosoutMsg_RosoutInfo::_Internal {
 public:
};

RosoutMsg_RosoutInfo::RosoutMsg_RosoutInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RosoutMsg.RosoutInfo)
}
RosoutMsg_RosoutInfo::RosoutMsg_RosoutInfo(const RosoutMsg_RosoutInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RosoutMsg_RosoutInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.topic_){}
    , decltype(_impl_.level_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_msg().empty()) {
    _this->_impl_.msg_.Set(from._internal_msg(), 
      _this->GetArenaForAllocation());
  }
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_topic().empty()) {
    _this->_impl_.topic_.Set(from._internal_topic(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.level_ = from._impl_.level_;
  // @@protoc_insertion_point(copy_constructor:RosoutMsg.RosoutInfo)
}

inline void RosoutMsg_RosoutInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.msg_){}
    , decltype(_impl_.topic_){}
    , decltype(_impl_.level_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.msg_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.topic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.topic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RosoutMsg_RosoutInfo::~RosoutMsg_RosoutInfo() {
  // @@protoc_insertion_point(destructor:RosoutMsg.RosoutInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RosoutMsg_RosoutInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.msg_.Destroy();
  _impl_.topic_.Destroy();
}

void RosoutMsg_RosoutInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RosoutMsg_RosoutInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:RosoutMsg.RosoutInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.msg_.ClearToEmpty();
  _impl_.topic_.ClearToEmpty();
  _impl_.level_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RosoutMsg_RosoutInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosoutMsg.RosoutInfo.name"));
        } else
          goto handle_unusual;
        continue;
      // string msg = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_msg();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosoutMsg.RosoutInfo.msg"));
        } else
          goto handle_unusual;
        continue;
      // string topic = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_topic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "RosoutMsg.RosoutInfo.topic"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RosoutMsg_RosoutInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RosoutMsg.RosoutInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_level(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosoutMsg.RosoutInfo.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string msg = 3;
  if (!this->_internal_msg().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_msg().data(), static_cast<int>(this->_internal_msg().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosoutMsg.RosoutInfo.msg");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_msg(), target);
  }

  // string topic = 4;
  if (!this->_internal_topic().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_topic().data(), static_cast<int>(this->_internal_topic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "RosoutMsg.RosoutInfo.topic");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_topic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RosoutMsg.RosoutInfo)
  return target;
}

size_t RosoutMsg_RosoutInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RosoutMsg.RosoutInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string msg = 3;
  if (!this->_internal_msg().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_msg());
  }

  // string topic = 4;
  if (!this->_internal_topic().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_topic());
  }

  // int32 level = 1;
  if (this->_internal_level() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_level());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RosoutMsg_RosoutInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RosoutMsg_RosoutInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RosoutMsg_RosoutInfo::GetClassData() const { return &_class_data_; }


void RosoutMsg_RosoutInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RosoutMsg_RosoutInfo*>(&to_msg);
  auto& from = static_cast<const RosoutMsg_RosoutInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RosoutMsg.RosoutInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_msg().empty()) {
    _this->_internal_set_msg(from._internal_msg());
  }
  if (!from._internal_topic().empty()) {
    _this->_internal_set_topic(from._internal_topic());
  }
  if (from._internal_level() != 0) {
    _this->_internal_set_level(from._internal_level());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RosoutMsg_RosoutInfo::CopyFrom(const RosoutMsg_RosoutInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RosoutMsg.RosoutInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosoutMsg_RosoutInfo::IsInitialized() const {
  return true;
}

void RosoutMsg_RosoutInfo::InternalSwap(RosoutMsg_RosoutInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_, lhs_arena,
      &other->_impl_.msg_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.topic_, lhs_arena,
      &other->_impl_.topic_, rhs_arena
  );
  swap(_impl_.level_, other->_impl_.level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RosoutMsg_RosoutInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[14]);
}

// ===================================================================

class RosoutMsg::_Internal {
 public:
};

RosoutMsg::RosoutMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:RosoutMsg)
}
RosoutMsg::RosoutMsg(const RosoutMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RosoutMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){from._impl_.messages_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:RosoutMsg)
}

inline void RosoutMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.messages_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RosoutMsg::~RosoutMsg() {
  // @@protoc_insertion_point(destructor:RosoutMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RosoutMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.messages_.~RepeatedPtrField();
}

void RosoutMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RosoutMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:RosoutMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.messages_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RosoutMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .RosoutMsg.RosoutInfo messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_messages(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RosoutMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:RosoutMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .RosoutMsg.RosoutInfo messages = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_messages_size()); i < n; i++) {
    const auto& repfield = this->_internal_messages(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:RosoutMsg)
  return target;
}

size_t RosoutMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:RosoutMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .RosoutMsg.RosoutInfo messages = 1;
  total_size += 1UL * this->_internal_messages_size();
  for (const auto& msg : this->_impl_.messages_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RosoutMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RosoutMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RosoutMsg::GetClassData() const { return &_class_data_; }


void RosoutMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RosoutMsg*>(&to_msg);
  auto& from = static_cast<const RosoutMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:RosoutMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.messages_.MergeFrom(from._impl_.messages_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RosoutMsg::CopyFrom(const RosoutMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:RosoutMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RosoutMsg::IsInitialized() const {
  return true;
}

void RosoutMsg::InternalSwap(RosoutMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.messages_.InternalSwap(&other->_impl_.messages_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RosoutMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[15]);
}

// ===================================================================

class AlarmMsg::_Internal {
 public:
};

AlarmMsg::AlarmMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:AlarmMsg)
}
AlarmMsg::AlarmMsg(const AlarmMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  AlarmMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){}
    , decltype(_impl_.cleared_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.code_, &from._impl_.code_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.cleared_) -
    reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.cleared_));
  // @@protoc_insertion_point(copy_constructor:AlarmMsg)
}

inline void AlarmMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.code_){0}
    , decltype(_impl_.cleared_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

AlarmMsg::~AlarmMsg() {
  // @@protoc_insertion_point(destructor:AlarmMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AlarmMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AlarmMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void AlarmMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:AlarmMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.cleared_) -
      reinterpret_cast<char*>(&_impl_.code_)) + sizeof(_impl_.cleared_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AlarmMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool cleared = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.cleared_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AlarmMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AlarmMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code(), target);
  }

  // bool cleared = 2;
  if (this->_internal_cleared() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_cleared(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AlarmMsg)
  return target;
}

size_t AlarmMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AlarmMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 code = 1;
  if (this->_internal_code() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code());
  }

  // bool cleared = 2;
  if (this->_internal_cleared() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AlarmMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    AlarmMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AlarmMsg::GetClassData() const { return &_class_data_; }


void AlarmMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<AlarmMsg*>(&to_msg);
  auto& from = static_cast<const AlarmMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:AlarmMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_code() != 0) {
    _this->_internal_set_code(from._internal_code());
  }
  if (from._internal_cleared() != 0) {
    _this->_internal_set_cleared(from._internal_cleared());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AlarmMsg::CopyFrom(const AlarmMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AlarmMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AlarmMsg::IsInitialized() const {
  return true;
}

void AlarmMsg::InternalSwap(AlarmMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AlarmMsg, _impl_.cleared_)
      + sizeof(AlarmMsg::_impl_.cleared_)
      - PROTOBUF_FIELD_OFFSET(AlarmMsg, _impl_.code_)>(
          reinterpret_cast<char*>(&_impl_.code_),
          reinterpret_cast<char*>(&other->_impl_.code_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AlarmMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[16]);
}

// ===================================================================

class NetworkConfig::_Internal {
 public:
};

NetworkConfig::NetworkConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:NetworkConfig)
}
NetworkConfig::NetworkConfig(const NetworkConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetworkConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.netmask_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.dns_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_address().empty()) {
    _this->_impl_.address_.Set(from._internal_address(), 
      _this->GetArenaForAllocation());
  }
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_mac().empty()) {
    _this->_impl_.mac_.Set(from._internal_mac(), 
      _this->GetArenaForAllocation());
  }
  _impl_.netmask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netmask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_netmask().empty()) {
    _this->_impl_.netmask_.Set(from._internal_netmask(), 
      _this->GetArenaForAllocation());
  }
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_gateway().empty()) {
    _this->_impl_.gateway_.Set(from._internal_gateway(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dns_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dns_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_dns().empty()) {
    _this->_impl_.dns_.Set(from._internal_dns(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:NetworkConfig)
}

inline void NetworkConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.name_){}
    , decltype(_impl_.address_){}
    , decltype(_impl_.mac_){}
    , decltype(_impl_.netmask_){}
    , decltype(_impl_.gateway_){}
    , decltype(_impl_.dns_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.address_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mac_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mac_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.netmask_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.netmask_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gateway_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gateway_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dns_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dns_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NetworkConfig::~NetworkConfig() {
  // @@protoc_insertion_point(destructor:NetworkConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.address_.Destroy();
  _impl_.mac_.Destroy();
  _impl_.netmask_.Destroy();
  _impl_.gateway_.Destroy();
  _impl_.dns_.Destroy();
}

void NetworkConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.name_.ClearToEmpty();
  _impl_.address_.ClearToEmpty();
  _impl_.mac_.ClearToEmpty();
  _impl_.netmask_.ClearToEmpty();
  _impl_.gateway_.ClearToEmpty();
  _impl_.dns_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetworkConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.name"));
        } else
          goto handle_unusual;
        continue;
      // string address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_address();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.address"));
        } else
          goto handle_unusual;
        continue;
      // string mac = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_mac();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.mac"));
        } else
          goto handle_unusual;
        continue;
      // string netmask = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_netmask();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.netmask"));
        } else
          goto handle_unusual;
        continue;
      // string gateway = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_gateway();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.gateway"));
        } else
          goto handle_unusual;
        continue;
      // string dns = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_dns();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "NetworkConfig.dns"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NetworkConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // string address = 2;
  if (!this->_internal_address().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.address");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_address(), target);
  }

  // string mac = 3;
  if (!this->_internal_mac().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.mac");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_mac(), target);
  }

  // string netmask = 4;
  if (!this->_internal_netmask().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_netmask().data(), static_cast<int>(this->_internal_netmask().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.netmask");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_netmask(), target);
  }

  // string gateway = 5;
  if (!this->_internal_gateway().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_gateway().data(), static_cast<int>(this->_internal_gateway().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.gateway");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_gateway(), target);
  }

  // string dns = 6;
  if (!this->_internal_dns().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_dns().data(), static_cast<int>(this->_internal_dns().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "NetworkConfig.dns");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_dns(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NetworkConfig)
  return target;
}

size_t NetworkConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string address = 2;
  if (!this->_internal_address().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_address());
  }

  // string mac = 3;
  if (!this->_internal_mac().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_mac());
  }

  // string netmask = 4;
  if (!this->_internal_netmask().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_netmask());
  }

  // string gateway = 5;
  if (!this->_internal_gateway().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_gateway());
  }

  // string dns = 6;
  if (!this->_internal_dns().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dns());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetworkConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetworkConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetworkConfig::GetClassData() const { return &_class_data_; }


void NetworkConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetworkConfig*>(&to_msg);
  auto& from = static_cast<const NetworkConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NetworkConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _this->_internal_set_name(from._internal_name());
  }
  if (!from._internal_address().empty()) {
    _this->_internal_set_address(from._internal_address());
  }
  if (!from._internal_mac().empty()) {
    _this->_internal_set_mac(from._internal_mac());
  }
  if (!from._internal_netmask().empty()) {
    _this->_internal_set_netmask(from._internal_netmask());
  }
  if (!from._internal_gateway().empty()) {
    _this->_internal_set_gateway(from._internal_gateway());
  }
  if (!from._internal_dns().empty()) {
    _this->_internal_set_dns(from._internal_dns());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetworkConfig::CopyFrom(const NetworkConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkConfig::IsInitialized() const {
  return true;
}

void NetworkConfig::InternalSwap(NetworkConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.address_, lhs_arena,
      &other->_impl_.address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mac_, lhs_arena,
      &other->_impl_.mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.netmask_, lhs_arena,
      &other->_impl_.netmask_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.gateway_, lhs_arena,
      &other->_impl_.gateway_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dns_, lhs_arena,
      &other->_impl_.dns_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata NetworkConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[17]);
}

// ===================================================================

class WirlessConfig::_Internal {
 public:
  static const ::NetworkConfig& config(const WirlessConfig* msg);
};

const ::NetworkConfig&
WirlessConfig::_Internal::config(const WirlessConfig* msg) {
  return *msg->_impl_.config_;
}
WirlessConfig::WirlessConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:WirlessConfig)
}
WirlessConfig::WirlessConfig(const WirlessConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WirlessConfig* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ssid_){}
    , decltype(_impl_.passwd_){}
    , decltype(_impl_.config_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ssid().empty()) {
    _this->_impl_.ssid_.Set(from._internal_ssid(), 
      _this->GetArenaForAllocation());
  }
  _impl_.passwd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.passwd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_passwd().empty()) {
    _this->_impl_.passwd_.Set(from._internal_passwd(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_config()) {
    _this->_impl_.config_ = new ::NetworkConfig(*from._impl_.config_);
  }
  // @@protoc_insertion_point(copy_constructor:WirlessConfig)
}

inline void WirlessConfig::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ssid_){}
    , decltype(_impl_.passwd_){}
    , decltype(_impl_.config_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.passwd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.passwd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WirlessConfig::~WirlessConfig() {
  // @@protoc_insertion_point(destructor:WirlessConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WirlessConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ssid_.Destroy();
  _impl_.passwd_.Destroy();
  if (this != internal_default_instance()) delete _impl_.config_;
}

void WirlessConfig::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WirlessConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:WirlessConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ssid_.ClearToEmpty();
  _impl_.passwd_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.config_ != nullptr) {
    delete _impl_.config_;
  }
  _impl_.config_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WirlessConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "WirlessConfig.ssid"));
        } else
          goto handle_unusual;
        continue;
      // string passwd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_passwd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "WirlessConfig.passwd"));
        } else
          goto handle_unusual;
        continue;
      // .NetworkConfig config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WirlessConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:WirlessConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ssid = 1;
  if (!this->_internal_ssid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ssid().data(), static_cast<int>(this->_internal_ssid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "WirlessConfig.ssid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // string passwd = 2;
  if (!this->_internal_passwd().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_passwd().data(), static_cast<int>(this->_internal_passwd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "WirlessConfig.passwd");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_passwd(), target);
  }

  // .NetworkConfig config = 3;
  if (this->_internal_has_config()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::config(this),
        _Internal::config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WirlessConfig)
  return target;
}

size_t WirlessConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WirlessConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ssid = 1;
  if (!this->_internal_ssid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ssid());
  }

  // string passwd = 2;
  if (!this->_internal_passwd().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_passwd());
  }

  // .NetworkConfig config = 3;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.config_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WirlessConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WirlessConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WirlessConfig::GetClassData() const { return &_class_data_; }


void WirlessConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WirlessConfig*>(&to_msg);
  auto& from = static_cast<const WirlessConfig&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:WirlessConfig)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ssid().empty()) {
    _this->_internal_set_ssid(from._internal_ssid());
  }
  if (!from._internal_passwd().empty()) {
    _this->_internal_set_passwd(from._internal_passwd());
  }
  if (from._internal_has_config()) {
    _this->_internal_mutable_config()->::NetworkConfig::MergeFrom(
        from._internal_config());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WirlessConfig::CopyFrom(const WirlessConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WirlessConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WirlessConfig::IsInitialized() const {
  return true;
}

void WirlessConfig::InternalSwap(WirlessConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ssid_, lhs_arena,
      &other->_impl_.ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.passwd_, lhs_arena,
      &other->_impl_.passwd_, rhs_arena
  );
  swap(_impl_.config_, other->_impl_.config_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WirlessConfig::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[18]);
}

// ===================================================================

class WirlessInfo::_Internal {
 public:
};

WirlessInfo::WirlessInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:WirlessInfo)
}
WirlessInfo::WirlessInfo(const WirlessInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WirlessInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ssid_){}
    , decltype(_impl_.signallevel_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_ssid().empty()) {
    _this->_impl_.ssid_.Set(from._internal_ssid(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.signallevel_ = from._impl_.signallevel_;
  // @@protoc_insertion_point(copy_constructor:WirlessInfo)
}

inline void WirlessInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ssid_){}
    , decltype(_impl_.signallevel_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.ssid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ssid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WirlessInfo::~WirlessInfo() {
  // @@protoc_insertion_point(destructor:WirlessInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WirlessInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ssid_.Destroy();
}

void WirlessInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WirlessInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:WirlessInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ssid_.ClearToEmpty();
  _impl_.signallevel_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WirlessInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "WirlessInfo.ssid"));
        } else
          goto handle_unusual;
        continue;
      // int32 signalLevel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.signallevel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WirlessInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:WirlessInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string ssid = 1;
  if (!this->_internal_ssid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_ssid().data(), static_cast<int>(this->_internal_ssid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "WirlessInfo.ssid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // int32 signalLevel = 2;
  if (this->_internal_signallevel() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_signallevel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WirlessInfo)
  return target;
}

size_t WirlessInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WirlessInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string ssid = 1;
  if (!this->_internal_ssid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ssid());
  }

  // int32 signalLevel = 2;
  if (this->_internal_signallevel() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signallevel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WirlessInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WirlessInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WirlessInfo::GetClassData() const { return &_class_data_; }


void WirlessInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WirlessInfo*>(&to_msg);
  auto& from = static_cast<const WirlessInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:WirlessInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_ssid().empty()) {
    _this->_internal_set_ssid(from._internal_ssid());
  }
  if (from._internal_signallevel() != 0) {
    _this->_internal_set_signallevel(from._internal_signallevel());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WirlessInfo::CopyFrom(const WirlessInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WirlessInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WirlessInfo::IsInitialized() const {
  return true;
}

void WirlessInfo::InternalSwap(WirlessInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.ssid_, lhs_arena,
      &other->_impl_.ssid_, rhs_arena
  );
  swap(_impl_.signallevel_, other->_impl_.signallevel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WirlessInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[19]);
}

// ===================================================================

class WLANList::_Internal {
 public:
};

WLANList::WLANList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:WLANList)
}
WLANList::WLANList(const WLANList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  WLANList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.wirlesslist_){from._impl_.wirlesslist_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:WLANList)
}

inline void WLANList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.wirlesslist_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

WLANList::~WLANList() {
  // @@protoc_insertion_point(destructor:WLANList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WLANList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.wirlesslist_.~RepeatedPtrField();
}

void WLANList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void WLANList::Clear() {
// @@protoc_insertion_point(message_clear_start:WLANList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.wirlesslist_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WLANList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .WirlessInfo wirlessList = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_wirlesslist(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WLANList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:WLANList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .WirlessInfo wirlessList = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_wirlesslist_size()); i < n; i++) {
    const auto& repfield = this->_internal_wirlesslist(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:WLANList)
  return target;
}

size_t WLANList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:WLANList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .WirlessInfo wirlessList = 1;
  total_size += 1UL * this->_internal_wirlesslist_size();
  for (const auto& msg : this->_impl_.wirlesslist_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData WLANList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    WLANList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*WLANList::GetClassData() const { return &_class_data_; }


void WLANList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<WLANList*>(&to_msg);
  auto& from = static_cast<const WLANList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:WLANList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.wirlesslist_.MergeFrom(from._impl_.wirlesslist_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void WLANList::CopyFrom(const WLANList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:WLANList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WLANList::IsInitialized() const {
  return true;
}

void WLANList::InternalSwap(WLANList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.wirlesslist_.InternalSwap(&other->_impl_.wirlesslist_);
}

::PROTOBUF_NAMESPACE_ID::Metadata WLANList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[20]);
}

// ===================================================================

class NetworkConfigCollection::_Internal {
 public:
};

NetworkConfigCollection::NetworkConfigCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:NetworkConfigCollection)
}
NetworkConfigCollection::NetworkConfigCollection(const NetworkConfigCollection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  NetworkConfigCollection* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.config_collection_){from._impl_.config_collection_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:NetworkConfigCollection)
}

inline void NetworkConfigCollection::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.config_collection_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

NetworkConfigCollection::~NetworkConfigCollection() {
  // @@protoc_insertion_point(destructor:NetworkConfigCollection)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NetworkConfigCollection::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.config_collection_.~RepeatedPtrField();
}

void NetworkConfigCollection::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void NetworkConfigCollection::Clear() {
// @@protoc_insertion_point(message_clear_start:NetworkConfigCollection)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.config_collection_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NetworkConfigCollection::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .NetworkConfig config_collection = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_config_collection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NetworkConfigCollection::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:NetworkConfigCollection)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .NetworkConfig config_collection = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_config_collection_size()); i < n; i++) {
    const auto& repfield = this->_internal_config_collection(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:NetworkConfigCollection)
  return target;
}

size_t NetworkConfigCollection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:NetworkConfigCollection)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .NetworkConfig config_collection = 1;
  total_size += 1UL * this->_internal_config_collection_size();
  for (const auto& msg : this->_impl_.config_collection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData NetworkConfigCollection::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    NetworkConfigCollection::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*NetworkConfigCollection::GetClassData() const { return &_class_data_; }


void NetworkConfigCollection::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<NetworkConfigCollection*>(&to_msg);
  auto& from = static_cast<const NetworkConfigCollection&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:NetworkConfigCollection)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.config_collection_.MergeFrom(from._impl_.config_collection_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void NetworkConfigCollection::CopyFrom(const NetworkConfigCollection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:NetworkConfigCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkConfigCollection::IsInitialized() const {
  return true;
}

void NetworkConfigCollection::InternalSwap(NetworkConfigCollection* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.config_collection_.InternalSwap(&other->_impl_.config_collection_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NetworkConfigCollection::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[21]);
}

// ===================================================================

class InstallPack::_Internal {
 public:
};

InstallPack::InstallPack(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:InstallPack)
}
InstallPack::InstallPack(const InstallPack& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  InstallPack* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.filename_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_filename().empty()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:InstallPack)
}

inline void InstallPack::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.filename_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

InstallPack::~InstallPack() {
  // @@protoc_insertion_point(destructor:InstallPack)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InstallPack::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.filename_.Destroy();
}

void InstallPack::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InstallPack::Clear() {
// @@protoc_insertion_point(message_clear_start:InstallPack)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.filename_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InstallPack::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "InstallPack.filename"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* InstallPack::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:InstallPack)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string filename = 1;
  if (!this->_internal_filename().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "InstallPack.filename");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:InstallPack)
  return target;
}

size_t InstallPack::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:InstallPack)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string filename = 1;
  if (!this->_internal_filename().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InstallPack::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InstallPack::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InstallPack::GetClassData() const { return &_class_data_; }


void InstallPack::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InstallPack*>(&to_msg);
  auto& from = static_cast<const InstallPack&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:InstallPack)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_filename().empty()) {
    _this->_internal_set_filename(from._internal_filename());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InstallPack::CopyFrom(const InstallPack& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:InstallPack)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InstallPack::IsInitialized() const {
  return true;
}

void InstallPack::InternalSwap(InstallPack* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata InstallPack::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[22]);
}

// ===================================================================

class SystemStatus::_Internal {
 public:
};

SystemStatus::SystemStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:SystemStatus)
}
SystemStatus::SystemStatus(const SystemStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SystemStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.cpu_usage_){}
    , decltype(_impl_.mem_total_){}
    , decltype(_impl_.mem_used_){}
    , decltype(_impl_.disk_total_){}
    , decltype(_impl_.disk_used_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cpu_usage_, &from._impl_.cpu_usage_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.disk_used_) -
    reinterpret_cast<char*>(&_impl_.cpu_usage_)) + sizeof(_impl_.disk_used_));
  // @@protoc_insertion_point(copy_constructor:SystemStatus)
}

inline void SystemStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.version_){}
    , decltype(_impl_.cpu_usage_){0}
    , decltype(_impl_.mem_total_){0}
    , decltype(_impl_.mem_used_){0}
    , decltype(_impl_.disk_total_){0}
    , decltype(_impl_.disk_used_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SystemStatus::~SystemStatus() {
  // @@protoc_insertion_point(destructor:SystemStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SystemStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.version_.Destroy();
}

void SystemStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SystemStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:SystemStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.version_.ClearToEmpty();
  ::memset(&_impl_.cpu_usage_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.disk_used_) -
      reinterpret_cast<char*>(&_impl_.cpu_usage_)) + sizeof(_impl_.disk_used_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SystemStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "SystemStatus.version"));
        } else
          goto handle_unusual;
        continue;
      // float cpu_usage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.cpu_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 mem_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.mem_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 mem_used = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.mem_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 disk_total = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _impl_.disk_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 disk_used = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.disk_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SystemStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SystemStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string version = 1;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "SystemStatus.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // float cpu_usage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cpu_usage = this->_internal_cpu_usage();
  uint32_t raw_cpu_usage;
  memcpy(&raw_cpu_usage, &tmp_cpu_usage, sizeof(tmp_cpu_usage));
  if (raw_cpu_usage != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_cpu_usage(), target);
  }

  // int32 mem_total = 3;
  if (this->_internal_mem_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_mem_total(), target);
  }

  // int32 mem_used = 4;
  if (this->_internal_mem_used() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_mem_used(), target);
  }

  // int32 disk_total = 5;
  if (this->_internal_disk_total() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_disk_total(), target);
  }

  // int32 disk_used = 6;
  if (this->_internal_disk_used() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_disk_used(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SystemStatus)
  return target;
}

size_t SystemStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SystemStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string version = 1;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // float cpu_usage = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cpu_usage = this->_internal_cpu_usage();
  uint32_t raw_cpu_usage;
  memcpy(&raw_cpu_usage, &tmp_cpu_usage, sizeof(tmp_cpu_usage));
  if (raw_cpu_usage != 0) {
    total_size += 1 + 4;
  }

  // int32 mem_total = 3;
  if (this->_internal_mem_total() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mem_total());
  }

  // int32 mem_used = 4;
  if (this->_internal_mem_used() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mem_used());
  }

  // int32 disk_total = 5;
  if (this->_internal_disk_total() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disk_total());
  }

  // int32 disk_used = 6;
  if (this->_internal_disk_used() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_disk_used());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SystemStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SystemStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SystemStatus::GetClassData() const { return &_class_data_; }


void SystemStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SystemStatus*>(&to_msg);
  auto& from = static_cast<const SystemStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:SystemStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_cpu_usage = from._internal_cpu_usage();
  uint32_t raw_cpu_usage;
  memcpy(&raw_cpu_usage, &tmp_cpu_usage, sizeof(tmp_cpu_usage));
  if (raw_cpu_usage != 0) {
    _this->_internal_set_cpu_usage(from._internal_cpu_usage());
  }
  if (from._internal_mem_total() != 0) {
    _this->_internal_set_mem_total(from._internal_mem_total());
  }
  if (from._internal_mem_used() != 0) {
    _this->_internal_set_mem_used(from._internal_mem_used());
  }
  if (from._internal_disk_total() != 0) {
    _this->_internal_set_disk_total(from._internal_disk_total());
  }
  if (from._internal_disk_used() != 0) {
    _this->_internal_set_disk_used(from._internal_disk_used());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SystemStatus::CopyFrom(const SystemStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SystemStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SystemStatus::IsInitialized() const {
  return true;
}

void SystemStatus::InternalSwap(SystemStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SystemStatus, _impl_.disk_used_)
      + sizeof(SystemStatus::_impl_.disk_used_)
      - PROTOBUF_FIELD_OFFSET(SystemStatus, _impl_.cpu_usage_)>(
          reinterpret_cast<char*>(&_impl_.cpu_usage_),
          reinterpret_cast<char*>(&other->_impl_.cpu_usage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SystemStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[23]);
}

// ===================================================================

class UpdateStation::_Internal {
 public:
};

UpdateStation::UpdateStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UpdateStation)
}
UpdateStation::UpdateStation(const UpdateStation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateStation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.marker_type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.marker_type_ = from._impl_.marker_type_;
  // @@protoc_insertion_point(copy_constructor:UpdateStation)
}

inline void UpdateStation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.marker_type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdateStation::~UpdateStation() {
  // @@protoc_insertion_point(destructor:UpdateStation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateStation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateStation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateStation::Clear() {
// @@protoc_insertion_point(message_clear_start:UpdateStation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.marker_type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateStation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 marker_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.marker_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdateStation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UpdateStation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 marker_type = 1;
  if (this->_internal_marker_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_marker_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UpdateStation)
  return target;
}

size_t UpdateStation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UpdateStation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 marker_type = 1;
  if (this->_internal_marker_type() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_marker_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateStation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateStation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateStation::GetClassData() const { return &_class_data_; }


void UpdateStation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateStation*>(&to_msg);
  auto& from = static_cast<const UpdateStation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UpdateStation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_marker_type() != 0) {
    _this->_internal_set_marker_type(from._internal_marker_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateStation::CopyFrom(const UpdateStation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UpdateStation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateStation::IsInitialized() const {
  return true;
}

void UpdateStation::InternalSwap(UpdateStation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.marker_type_, other->_impl_.marker_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateStation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[24]);
}

// ===================================================================

class UpdatePose::_Internal {
 public:
  static const ::Result& error_info(const UpdatePose* msg);
  static const ::Position& pose(const UpdatePose* msg);
};

const ::Result&
UpdatePose::_Internal::error_info(const UpdatePose* msg) {
  return *msg->_impl_.error_info_;
}
const ::Position&
UpdatePose::_Internal::pose(const UpdatePose* msg) {
  return *msg->_impl_.pose_;
}
void UpdatePose::clear_error_info() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_info_ != nullptr) {
    delete _impl_.error_info_;
  }
  _impl_.error_info_ = nullptr;
}
void UpdatePose::clear_pose() {
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
}
UpdatePose::UpdatePose(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UpdatePose)
}
UpdatePose::UpdatePose(const UpdatePose& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdatePose* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.error_info_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_error_info()) {
    _this->_impl_.error_info_ = new ::Result(*from._impl_.error_info_);
  }
  if (from._internal_has_pose()) {
    _this->_impl_.pose_ = new ::Position(*from._impl_.pose_);
  }
  // @@protoc_insertion_point(copy_constructor:UpdatePose)
}

inline void UpdatePose::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.error_info_){nullptr}
    , decltype(_impl_.pose_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

UpdatePose::~UpdatePose() {
  // @@protoc_insertion_point(destructor:UpdatePose)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdatePose::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.error_info_;
  if (this != internal_default_instance()) delete _impl_.pose_;
}

void UpdatePose::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdatePose::Clear() {
// @@protoc_insertion_point(message_clear_start:UpdatePose)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.error_info_ != nullptr) {
    delete _impl_.error_info_;
  }
  _impl_.error_info_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.pose_ != nullptr) {
    delete _impl_.pose_;
  }
  _impl_.pose_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdatePose::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Result error_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_error_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Position pose = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_pose(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UpdatePose::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UpdatePose)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Result error_info = 1;
  if (this->_internal_has_error_info()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::error_info(this),
        _Internal::error_info(this).GetCachedSize(), target, stream);
  }

  // .Position pose = 2;
  if (this->_internal_has_pose()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::pose(this),
        _Internal::pose(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UpdatePose)
  return target;
}

size_t UpdatePose::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UpdatePose)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Result error_info = 1;
  if (this->_internal_has_error_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.error_info_);
  }

  // .Position pose = 2;
  if (this->_internal_has_pose()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.pose_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdatePose::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdatePose::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdatePose::GetClassData() const { return &_class_data_; }


void UpdatePose::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdatePose*>(&to_msg);
  auto& from = static_cast<const UpdatePose&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UpdatePose)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_error_info()) {
    _this->_internal_mutable_error_info()->::Result::MergeFrom(
        from._internal_error_info());
  }
  if (from._internal_has_pose()) {
    _this->_internal_mutable_pose()->::Position::MergeFrom(
        from._internal_pose());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdatePose::CopyFrom(const UpdatePose& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UpdatePose)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdatePose::IsInitialized() const {
  return true;
}

void UpdatePose::InternalSwap(UpdatePose* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdatePose, _impl_.pose_)
      + sizeof(UpdatePose::_impl_.pose_)
      - PROTOBUF_FIELD_OFFSET(UpdatePose, _impl_.error_info_)>(
          reinterpret_cast<char*>(&_impl_.error_info_),
          reinterpret_cast<char*>(&other->_impl_.error_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdatePose::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_camel_2dgrpc_2eproto_getter, &descriptor_table_camel_2dgrpc_2eproto_once,
      file_level_metadata_camel_2dgrpc_2eproto[25]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AgvInfo_UIStation*
Arena::CreateMaybeMessage< ::AgvInfo_UIStation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AgvInfo_UIStation >(arena);
}
template<> PROTOBUF_NOINLINE ::AgvInfo_Motion*
Arena::CreateMaybeMessage< ::AgvInfo_Motion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AgvInfo_Motion >(arena);
}
template<> PROTOBUF_NOINLINE ::AgvInfo_Alarm*
Arena::CreateMaybeMessage< ::AgvInfo_Alarm >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AgvInfo_Alarm >(arena);
}
template<> PROTOBUF_NOINLINE ::AgvInfo_DebugInfo*
Arena::CreateMaybeMessage< ::AgvInfo_DebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AgvInfo_DebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::AgvInfo*
Arena::CreateMaybeMessage< ::AgvInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AgvInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::UIConfig*
Arena::CreateMaybeMessage< ::UIConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UIConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::Version*
Arena::CreateMaybeMessage< ::Version >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Version >(arena);
}
template<> PROTOBUF_NOINLINE ::Operation*
Arena::CreateMaybeMessage< ::Operation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Operation >(arena);
}
template<> PROTOBUF_NOINLINE ::CamelCfg*
Arena::CreateMaybeMessage< ::CamelCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CamelCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::CamelSysInfo*
Arena::CreateMaybeMessage< ::CamelSysInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CamelSysInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::LogRequest*
Arena::CreateMaybeMessage< ::LogRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LogRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::LogResponse*
Arena::CreateMaybeMessage< ::LogResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LogResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::RosNode*
Arena::CreateMaybeMessage< ::RosNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RosNode >(arena);
}
template<> PROTOBUF_NOINLINE ::RosNodesCfg*
Arena::CreateMaybeMessage< ::RosNodesCfg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RosNodesCfg >(arena);
}
template<> PROTOBUF_NOINLINE ::RosoutMsg_RosoutInfo*
Arena::CreateMaybeMessage< ::RosoutMsg_RosoutInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RosoutMsg_RosoutInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::RosoutMsg*
Arena::CreateMaybeMessage< ::RosoutMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::RosoutMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::AlarmMsg*
Arena::CreateMaybeMessage< ::AlarmMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::AlarmMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::NetworkConfig*
Arena::CreateMaybeMessage< ::NetworkConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::NetworkConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::WirlessConfig*
Arena::CreateMaybeMessage< ::WirlessConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::WirlessConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::WirlessInfo*
Arena::CreateMaybeMessage< ::WirlessInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::WirlessInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::WLANList*
Arena::CreateMaybeMessage< ::WLANList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::WLANList >(arena);
}
template<> PROTOBUF_NOINLINE ::NetworkConfigCollection*
Arena::CreateMaybeMessage< ::NetworkConfigCollection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::NetworkConfigCollection >(arena);
}
template<> PROTOBUF_NOINLINE ::InstallPack*
Arena::CreateMaybeMessage< ::InstallPack >(Arena* arena) {
  return Arena::CreateMessageInternal< ::InstallPack >(arena);
}
template<> PROTOBUF_NOINLINE ::SystemStatus*
Arena::CreateMaybeMessage< ::SystemStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SystemStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::UpdateStation*
Arena::CreateMaybeMessage< ::UpdateStation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UpdateStation >(arena);
}
template<> PROTOBUF_NOINLINE ::UpdatePose*
Arena::CreateMaybeMessage< ::UpdatePose >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UpdatePose >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
