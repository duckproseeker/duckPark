// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: camel-common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_camel_2dcommon_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_camel_2dcommon_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_camel_2dcommon_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_camel_2dcommon_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_camel_2dcommon_2eproto;
namespace camel {
namespace api {
class Alarm;
struct AlarmDefaultTypeInternal;
extern AlarmDefaultTypeInternal _Alarm_default_instance_;
class AvoidanceAreaCollection;
struct AvoidanceAreaCollectionDefaultTypeInternal;
extern AvoidanceAreaCollectionDefaultTypeInternal _AvoidanceAreaCollection_default_instance_;
class AvoidanceAreaCollection_AvoidanceArea;
struct AvoidanceAreaCollection_AvoidanceAreaDefaultTypeInternal;
extern AvoidanceAreaCollection_AvoidanceAreaDefaultTypeInternal _AvoidanceAreaCollection_AvoidanceArea_default_instance_;
class Battery;
struct BatteryDefaultTypeInternal;
extern BatteryDefaultTypeInternal _Battery_default_instance_;
class CarHWInfo;
struct CarHWInfoDefaultTypeInternal;
extern CarHWInfoDefaultTypeInternal _CarHWInfo_default_instance_;
class ChargeCmd;
struct ChargeCmdDefaultTypeInternal;
extern ChargeCmdDefaultTypeInternal _ChargeCmd_default_instance_;
class Collaborative;
struct CollaborativeDefaultTypeInternal;
extern CollaborativeDefaultTypeInternal _Collaborative_default_instance_;
class CollaborativeResult;
struct CollaborativeResultDefaultTypeInternal;
extern CollaborativeResultDefaultTypeInternal _CollaborativeResult_default_instance_;
class ContextTask;
struct ContextTaskDefaultTypeInternal;
extern ContextTaskDefaultTypeInternal _ContextTask_default_instance_;
class Coord;
struct CoordDefaultTypeInternal;
extern CoordDefaultTypeInternal _Coord_default_instance_;
class GPath;
struct GPathDefaultTypeInternal;
extern GPathDefaultTypeInternal _GPath_default_instance_;
class GStation;
struct GStationDefaultTypeInternal;
extern GStationDefaultTypeInternal _GStation_default_instance_;
class Gamepad;
struct GamepadDefaultTypeInternal;
extern GamepadDefaultTypeInternal _Gamepad_default_instance_;
class GamepadControl;
struct GamepadControlDefaultTypeInternal;
extern GamepadControlDefaultTypeInternal _GamepadControl_default_instance_;
class GrpcTaskAllocation;
struct GrpcTaskAllocationDefaultTypeInternal;
extern GrpcTaskAllocationDefaultTypeInternal _GrpcTaskAllocation_default_instance_;
class GrpcTaskAllocations;
struct GrpcTaskAllocationsDefaultTypeInternal;
extern GrpcTaskAllocationsDefaultTypeInternal _GrpcTaskAllocations_default_instance_;
class GrpcTaskInfomation;
struct GrpcTaskInfomationDefaultTypeInternal;
extern GrpcTaskInfomationDefaultTypeInternal _GrpcTaskInfomation_default_instance_;
class GrpcTaskOperation;
struct GrpcTaskOperationDefaultTypeInternal;
extern GrpcTaskOperationDefaultTypeInternal _GrpcTaskOperation_default_instance_;
class GrpcTaskStation;
struct GrpcTaskStationDefaultTypeInternal;
extern GrpcTaskStationDefaultTypeInternal _GrpcTaskStation_default_instance_;
class MatchPointCommand;
struct MatchPointCommandDefaultTypeInternal;
extern MatchPointCommandDefaultTypeInternal _MatchPointCommand_default_instance_;
class MatchPoints;
struct MatchPointsDefaultTypeInternal;
extern MatchPointsDefaultTypeInternal _MatchPoints_default_instance_;
class MatchPoints_MatchPoint;
struct MatchPoints_MatchPointDefaultTypeInternal;
extern MatchPoints_MatchPointDefaultTypeInternal _MatchPoints_MatchPoint_default_instance_;
class PathCollection;
struct PathCollectionDefaultTypeInternal;
extern PathCollectionDefaultTypeInternal _PathCollection_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Token;
struct TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
}  // namespace api
}  // namespace camel
PROTOBUF_NAMESPACE_OPEN
template<> ::camel::api::Alarm* Arena::CreateMaybeMessage<::camel::api::Alarm>(Arena*);
template<> ::camel::api::AvoidanceAreaCollection* Arena::CreateMaybeMessage<::camel::api::AvoidanceAreaCollection>(Arena*);
template<> ::camel::api::AvoidanceAreaCollection_AvoidanceArea* Arena::CreateMaybeMessage<::camel::api::AvoidanceAreaCollection_AvoidanceArea>(Arena*);
template<> ::camel::api::Battery* Arena::CreateMaybeMessage<::camel::api::Battery>(Arena*);
template<> ::camel::api::CarHWInfo* Arena::CreateMaybeMessage<::camel::api::CarHWInfo>(Arena*);
template<> ::camel::api::ChargeCmd* Arena::CreateMaybeMessage<::camel::api::ChargeCmd>(Arena*);
template<> ::camel::api::Collaborative* Arena::CreateMaybeMessage<::camel::api::Collaborative>(Arena*);
template<> ::camel::api::CollaborativeResult* Arena::CreateMaybeMessage<::camel::api::CollaborativeResult>(Arena*);
template<> ::camel::api::ContextTask* Arena::CreateMaybeMessage<::camel::api::ContextTask>(Arena*);
template<> ::camel::api::Coord* Arena::CreateMaybeMessage<::camel::api::Coord>(Arena*);
template<> ::camel::api::GPath* Arena::CreateMaybeMessage<::camel::api::GPath>(Arena*);
template<> ::camel::api::GStation* Arena::CreateMaybeMessage<::camel::api::GStation>(Arena*);
template<> ::camel::api::Gamepad* Arena::CreateMaybeMessage<::camel::api::Gamepad>(Arena*);
template<> ::camel::api::GamepadControl* Arena::CreateMaybeMessage<::camel::api::GamepadControl>(Arena*);
template<> ::camel::api::GrpcTaskAllocation* Arena::CreateMaybeMessage<::camel::api::GrpcTaskAllocation>(Arena*);
template<> ::camel::api::GrpcTaskAllocations* Arena::CreateMaybeMessage<::camel::api::GrpcTaskAllocations>(Arena*);
template<> ::camel::api::GrpcTaskInfomation* Arena::CreateMaybeMessage<::camel::api::GrpcTaskInfomation>(Arena*);
template<> ::camel::api::GrpcTaskOperation* Arena::CreateMaybeMessage<::camel::api::GrpcTaskOperation>(Arena*);
template<> ::camel::api::GrpcTaskStation* Arena::CreateMaybeMessage<::camel::api::GrpcTaskStation>(Arena*);
template<> ::camel::api::MatchPointCommand* Arena::CreateMaybeMessage<::camel::api::MatchPointCommand>(Arena*);
template<> ::camel::api::MatchPoints* Arena::CreateMaybeMessage<::camel::api::MatchPoints>(Arena*);
template<> ::camel::api::MatchPoints_MatchPoint* Arena::CreateMaybeMessage<::camel::api::MatchPoints_MatchPoint>(Arena*);
template<> ::camel::api::PathCollection* Arena::CreateMaybeMessage<::camel::api::PathCollection>(Arena*);
template<> ::camel::api::Position* Arena::CreateMaybeMessage<::camel::api::Position>(Arena*);
template<> ::camel::api::Result* Arena::CreateMaybeMessage<::camel::api::Result>(Arena*);
template<> ::camel::api::Token* Arena::CreateMaybeMessage<::camel::api::Token>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace camel {
namespace api {

enum Battery_ChargingState : int {
  Battery_ChargingState_kIDLE = 0,
  Battery_ChargingState_kCHARGING = 1,
  Battery_ChargingState_kERROR = 2,
  Battery_ChargingState_kReady = 3,
  Battery_ChargingState_Battery_ChargingState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Battery_ChargingState_Battery_ChargingState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Battery_ChargingState_IsValid(int value);
constexpr Battery_ChargingState Battery_ChargingState_ChargingState_MIN = Battery_ChargingState_kIDLE;
constexpr Battery_ChargingState Battery_ChargingState_ChargingState_MAX = Battery_ChargingState_kReady;
constexpr int Battery_ChargingState_ChargingState_ARRAYSIZE = Battery_ChargingState_ChargingState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Battery_ChargingState_descriptor();
template<typename T>
inline const std::string& Battery_ChargingState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Battery_ChargingState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Battery_ChargingState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Battery_ChargingState_descriptor(), enum_t_value);
}
inline bool Battery_ChargingState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Battery_ChargingState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Battery_ChargingState>(
    Battery_ChargingState_descriptor(), name, value);
}
enum GrpcTaskStation_TaskAction : int {
  GrpcTaskStation_TaskAction_kGet = 0,
  GrpcTaskStation_TaskAction_kPut = 1,
  GrpcTaskStation_TaskAction_kWait = 2,
  GrpcTaskStation_TaskAction_GrpcTaskStation_TaskAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GrpcTaskStation_TaskAction_GrpcTaskStation_TaskAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GrpcTaskStation_TaskAction_IsValid(int value);
constexpr GrpcTaskStation_TaskAction GrpcTaskStation_TaskAction_TaskAction_MIN = GrpcTaskStation_TaskAction_kGet;
constexpr GrpcTaskStation_TaskAction GrpcTaskStation_TaskAction_TaskAction_MAX = GrpcTaskStation_TaskAction_kWait;
constexpr int GrpcTaskStation_TaskAction_TaskAction_ARRAYSIZE = GrpcTaskStation_TaskAction_TaskAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GrpcTaskStation_TaskAction_descriptor();
template<typename T>
inline const std::string& GrpcTaskStation_TaskAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GrpcTaskStation_TaskAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GrpcTaskStation_TaskAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GrpcTaskStation_TaskAction_descriptor(), enum_t_value);
}
inline bool GrpcTaskStation_TaskAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GrpcTaskStation_TaskAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GrpcTaskStation_TaskAction>(
    GrpcTaskStation_TaskAction_descriptor(), name, value);
}
enum GrpcTaskOperation_Operation : int {
  GrpcTaskOperation_Operation_kNew = 0,
  GrpcTaskOperation_Operation_kDelete = 1,
  GrpcTaskOperation_Operation_kQuery = 2,
  GrpcTaskOperation_Operation_kCall = 3,
  GrpcTaskOperation_Operation_kGoto = 4,
  GrpcTaskOperation_Operation_kCancel = 5,
  GrpcTaskOperation_Operation_kGotoCharging = 6,
  GrpcTaskOperation_Operation_kSingleCar = 7,
  GrpcTaskOperation_Operation_kMuiltCar = 8,
  GrpcTaskOperation_Operation_GrpcTaskOperation_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GrpcTaskOperation_Operation_GrpcTaskOperation_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GrpcTaskOperation_Operation_IsValid(int value);
constexpr GrpcTaskOperation_Operation GrpcTaskOperation_Operation_Operation_MIN = GrpcTaskOperation_Operation_kNew;
constexpr GrpcTaskOperation_Operation GrpcTaskOperation_Operation_Operation_MAX = GrpcTaskOperation_Operation_kMuiltCar;
constexpr int GrpcTaskOperation_Operation_Operation_ARRAYSIZE = GrpcTaskOperation_Operation_Operation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GrpcTaskOperation_Operation_descriptor();
template<typename T>
inline const std::string& GrpcTaskOperation_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GrpcTaskOperation_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GrpcTaskOperation_Operation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GrpcTaskOperation_Operation_descriptor(), enum_t_value);
}
inline bool GrpcTaskOperation_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GrpcTaskOperation_Operation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GrpcTaskOperation_Operation>(
    GrpcTaskOperation_Operation_descriptor(), name, value);
}
enum Collaborative_CooperationEnum : int {
  Collaborative_CooperationEnum_kStartCooperation = 0,
  Collaborative_CooperationEnum_kEndCooperation = 1,
  Collaborative_CooperationEnum_Collaborative_CooperationEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Collaborative_CooperationEnum_Collaborative_CooperationEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Collaborative_CooperationEnum_IsValid(int value);
constexpr Collaborative_CooperationEnum Collaborative_CooperationEnum_CooperationEnum_MIN = Collaborative_CooperationEnum_kStartCooperation;
constexpr Collaborative_CooperationEnum Collaborative_CooperationEnum_CooperationEnum_MAX = Collaborative_CooperationEnum_kEndCooperation;
constexpr int Collaborative_CooperationEnum_CooperationEnum_ARRAYSIZE = Collaborative_CooperationEnum_CooperationEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Collaborative_CooperationEnum_descriptor();
template<typename T>
inline const std::string& Collaborative_CooperationEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Collaborative_CooperationEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Collaborative_CooperationEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Collaborative_CooperationEnum_descriptor(), enum_t_value);
}
inline bool Collaborative_CooperationEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Collaborative_CooperationEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Collaborative_CooperationEnum>(
    Collaborative_CooperationEnum_descriptor(), name, value);
}
enum CollaborativeResult_Status : int {
  CollaborativeResult_Status_kSuccess = 0,
  CollaborativeResult_Status_kFailed = 1,
  CollaborativeResult_Status_CollaborativeResult_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollaborativeResult_Status_CollaborativeResult_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CollaborativeResult_Status_IsValid(int value);
constexpr CollaborativeResult_Status CollaborativeResult_Status_Status_MIN = CollaborativeResult_Status_kSuccess;
constexpr CollaborativeResult_Status CollaborativeResult_Status_Status_MAX = CollaborativeResult_Status_kFailed;
constexpr int CollaborativeResult_Status_Status_ARRAYSIZE = CollaborativeResult_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollaborativeResult_Status_descriptor();
template<typename T>
inline const std::string& CollaborativeResult_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollaborativeResult_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollaborativeResult_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollaborativeResult_Status_descriptor(), enum_t_value);
}
inline bool CollaborativeResult_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollaborativeResult_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollaborativeResult_Status>(
    CollaborativeResult_Status_descriptor(), name, value);
}
enum DoAction : int {
  kNoAction = 0,
  kDoAction1 = 1,
  kDoAction2 = 2,
  DoAction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DoAction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DoAction_IsValid(int value);
constexpr DoAction DoAction_MIN = kNoAction;
constexpr DoAction DoAction_MAX = kDoAction2;
constexpr int DoAction_ARRAYSIZE = DoAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DoAction_descriptor();
template<typename T>
inline const std::string& DoAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DoAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DoAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DoAction_descriptor(), enum_t_value);
}
inline bool DoAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DoAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DoAction>(
    DoAction_descriptor(), name, value);
}
enum AgvsTaskStatus : int {
  kNone = 0,
  kToTaskStart = 1,
  kToTaskEnd = 2,
  kToCharging = 3,
  kToParking = 4,
  AgvsTaskStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AgvsTaskStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AgvsTaskStatus_IsValid(int value);
constexpr AgvsTaskStatus AgvsTaskStatus_MIN = kNone;
constexpr AgvsTaskStatus AgvsTaskStatus_MAX = kToParking;
constexpr int AgvsTaskStatus_ARRAYSIZE = AgvsTaskStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AgvsTaskStatus_descriptor();
template<typename T>
inline const std::string& AgvsTaskStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AgvsTaskStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AgvsTaskStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AgvsTaskStatus_descriptor(), enum_t_value);
}
inline bool AgvsTaskStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AgvsTaskStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AgvsTaskStatus>(
    AgvsTaskStatus_descriptor(), name, value);
}
// ===================================================================

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit PROTOBUF_CONSTEXPR Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // bytes message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 errorCode = 1;
  void clear_errorcode();
  int32_t errorcode() const;
  void set_errorcode(int32_t value);
  private:
  int32_t _internal_errorcode() const;
  void _internal_set_errorcode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int32_t errorcode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Battery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Battery) */ {
 public:
  inline Battery() : Battery(nullptr) {}
  ~Battery() override;
  explicit PROTOBUF_CONSTEXPR Battery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Battery(const Battery& from);
  Battery(Battery&& from) noexcept
    : Battery() {
    *this = ::std::move(from);
  }

  inline Battery& operator=(const Battery& from) {
    CopyFrom(from);
    return *this;
  }
  inline Battery& operator=(Battery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Battery& default_instance() {
    return *internal_default_instance();
  }
  static inline const Battery* internal_default_instance() {
    return reinterpret_cast<const Battery*>(
               &_Battery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Battery& a, Battery& b) {
    a.Swap(&b);
  }
  inline void Swap(Battery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Battery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Battery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Battery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Battery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Battery& from) {
    Battery::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Battery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Battery";
  }
  protected:
  explicit Battery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Battery_ChargingState ChargingState;
  static constexpr ChargingState kIDLE =
    Battery_ChargingState_kIDLE;
  static constexpr ChargingState kCHARGING =
    Battery_ChargingState_kCHARGING;
  static constexpr ChargingState kERROR =
    Battery_ChargingState_kERROR;
  static constexpr ChargingState kReady =
    Battery_ChargingState_kReady;
  static inline bool ChargingState_IsValid(int value) {
    return Battery_ChargingState_IsValid(value);
  }
  static constexpr ChargingState ChargingState_MIN =
    Battery_ChargingState_ChargingState_MIN;
  static constexpr ChargingState ChargingState_MAX =
    Battery_ChargingState_ChargingState_MAX;
  static constexpr int ChargingState_ARRAYSIZE =
    Battery_ChargingState_ChargingState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChargingState_descriptor() {
    return Battery_ChargingState_descriptor();
  }
  template<typename T>
  static inline const std::string& ChargingState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChargingState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChargingState_Name.");
    return Battery_ChargingState_Name(enum_t_value);
  }
  static inline bool ChargingState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChargingState* value) {
    return Battery_ChargingState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPercentFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // float percent = 1;
  void clear_percent();
  float percent() const;
  void set_percent(float value);
  private:
  float _internal_percent() const;
  void _internal_set_percent(float value);
  public:

  // .camel.api.Battery.ChargingState state = 2;
  void clear_state();
  ::camel::api::Battery_ChargingState state() const;
  void set_state(::camel::api::Battery_ChargingState value);
  private:
  ::camel::api::Battery_ChargingState _internal_state() const;
  void _internal_set_state(::camel::api::Battery_ChargingState value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Battery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float percent_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class CarHWInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.CarHWInfo) */ {
 public:
  inline CarHWInfo() : CarHWInfo(nullptr) {}
  ~CarHWInfo() override;
  explicit PROTOBUF_CONSTEXPR CarHWInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CarHWInfo(const CarHWInfo& from);
  CarHWInfo(CarHWInfo&& from) noexcept
    : CarHWInfo() {
    *this = ::std::move(from);
  }

  inline CarHWInfo& operator=(const CarHWInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarHWInfo& operator=(CarHWInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CarHWInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CarHWInfo* internal_default_instance() {
    return reinterpret_cast<const CarHWInfo*>(
               &_CarHWInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarHWInfo& a, CarHWInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CarHWInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarHWInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CarHWInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CarHWInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CarHWInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CarHWInfo& from) {
    CarHWInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarHWInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.CarHWInfo";
  }
  protected:
  explicit CarHWInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCargoStateFieldNumber = 1,
    kFrontDetectFieldNumber = 2,
    kBackDetectFieldNumber = 3,
    kInDetectFieldNumber = 4,
    kLeftForkFieldNumber = 5,
    kRightForkFieldNumber = 6,
    kMapNotMatchFieldNumber = 7,
    kRedLightFieldNumber = 8,
    kCtrlModeFieldNumber = 9,
  };
  // bool cargoState = 1;
  void clear_cargostate();
  bool cargostate() const;
  void set_cargostate(bool value);
  private:
  bool _internal_cargostate() const;
  void _internal_set_cargostate(bool value);
  public:

  // bool frontDetect = 2;
  void clear_frontdetect();
  bool frontdetect() const;
  void set_frontdetect(bool value);
  private:
  bool _internal_frontdetect() const;
  void _internal_set_frontdetect(bool value);
  public:

  // bool backDetect = 3;
  void clear_backdetect();
  bool backdetect() const;
  void set_backdetect(bool value);
  private:
  bool _internal_backdetect() const;
  void _internal_set_backdetect(bool value);
  public:

  // bool inDetect = 4;
  void clear_indetect();
  bool indetect() const;
  void set_indetect(bool value);
  private:
  bool _internal_indetect() const;
  void _internal_set_indetect(bool value);
  public:

  // bool leftFork = 5;
  void clear_leftfork();
  bool leftfork() const;
  void set_leftfork(bool value);
  private:
  bool _internal_leftfork() const;
  void _internal_set_leftfork(bool value);
  public:

  // bool rightFork = 6;
  void clear_rightfork();
  bool rightfork() const;
  void set_rightfork(bool value);
  private:
  bool _internal_rightfork() const;
  void _internal_set_rightfork(bool value);
  public:

  // bool mapNotMatch = 7;
  void clear_mapnotmatch();
  bool mapnotmatch() const;
  void set_mapnotmatch(bool value);
  private:
  bool _internal_mapnotmatch() const;
  void _internal_set_mapnotmatch(bool value);
  public:

  // bool redLight = 8;
  void clear_redlight();
  bool redlight() const;
  void set_redlight(bool value);
  private:
  bool _internal_redlight() const;
  void _internal_set_redlight(bool value);
  public:

  // bool ctrlMode = 9;
  void clear_ctrlmode();
  bool ctrlmode() const;
  void set_ctrlmode(bool value);
  private:
  bool _internal_ctrlmode() const;
  void _internal_set_ctrlmode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.CarHWInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool cargostate_;
    bool frontdetect_;
    bool backdetect_;
    bool indetect_;
    bool leftfork_;
    bool rightfork_;
    bool mapnotmatch_;
    bool redlight_;
    bool ctrlmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Alarm final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Alarm) */ {
 public:
  inline Alarm() : Alarm(nullptr) {}
  ~Alarm() override;
  explicit PROTOBUF_CONSTEXPR Alarm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alarm(const Alarm& from);
  Alarm(Alarm&& from) noexcept
    : Alarm() {
    *this = ::std::move(from);
  }

  inline Alarm& operator=(const Alarm& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alarm& operator=(Alarm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alarm& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alarm* internal_default_instance() {
    return reinterpret_cast<const Alarm*>(
               &_Alarm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Alarm& a, Alarm& b) {
    a.Swap(&b);
  }
  inline void Swap(Alarm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alarm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alarm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alarm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alarm& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Alarm& from) {
    Alarm::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alarm* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Alarm";
  }
  protected:
  explicit Alarm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // repeated bytes params = 2;
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  const std::string& params(int index) const;
  std::string* mutable_params(int index);
  void set_params(int index, const std::string& value);
  void set_params(int index, std::string&& value);
  void set_params(int index, const char* value);
  void set_params(int index, const void* value, size_t size);
  std::string* add_params();
  void add_params(const std::string& value);
  void add_params(std::string&& value);
  void add_params(const char* value);
  void add_params(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& params() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_params();
  private:
  const std::string& _internal_params(int index) const;
  std::string* _internal_add_params();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Alarm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> params_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class ChargeCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.ChargeCmd) */ {
 public:
  inline ChargeCmd() : ChargeCmd(nullptr) {}
  ~ChargeCmd() override;
  explicit PROTOBUF_CONSTEXPR ChargeCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChargeCmd(const ChargeCmd& from);
  ChargeCmd(ChargeCmd&& from) noexcept
    : ChargeCmd() {
    *this = ::std::move(from);
  }

  inline ChargeCmd& operator=(const ChargeCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChargeCmd& operator=(ChargeCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChargeCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChargeCmd* internal_default_instance() {
    return reinterpret_cast<const ChargeCmd*>(
               &_ChargeCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ChargeCmd& a, ChargeCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(ChargeCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChargeCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChargeCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChargeCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChargeCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChargeCmd& from) {
    ChargeCmd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChargeCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.ChargeCmd";
  }
  protected:
  explicit ChargeCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowChargingFieldNumber = 1,
    kChannelFieldNumber = 2,
  };
  // .camel.api.DoAction allowCharging = 1;
  void clear_allowcharging();
  ::camel::api::DoAction allowcharging() const;
  void set_allowcharging(::camel::api::DoAction value);
  private:
  ::camel::api::DoAction _internal_allowcharging() const;
  void _internal_set_allowcharging(::camel::api::DoAction value);
  public:

  // int32 channel = 2;
  void clear_channel();
  int32_t channel() const;
  void set_channel(int32_t value);
  private:
  int32_t _internal_channel() const;
  void _internal_set_channel(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.ChargeCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int allowcharging_;
    int32_t channel_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Position& from) {
    Position::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kThetaFieldNumber = 3,
    kConfidenceFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float theta = 3;
  void clear_theta();
  float theta() const;
  void set_theta(float value);
  private:
  float _internal_theta() const;
  void _internal_set_theta(float value);
  public:

  // float confidence = 4;
  void clear_confidence();
  float confidence() const;
  void set_confidence(float value);
  private:
  float _internal_confidence() const;
  void _internal_set_confidence(float value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float theta_;
    float confidence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class ContextTask final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.ContextTask) */ {
 public:
  inline ContextTask() : ContextTask(nullptr) {}
  ~ContextTask() override;
  explicit PROTOBUF_CONSTEXPR ContextTask(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContextTask(const ContextTask& from);
  ContextTask(ContextTask&& from) noexcept
    : ContextTask() {
    *this = ::std::move(from);
  }

  inline ContextTask& operator=(const ContextTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContextTask& operator=(ContextTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContextTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContextTask* internal_default_instance() {
    return reinterpret_cast<const ContextTask*>(
               &_ContextTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ContextTask& a, ContextTask& b) {
    a.Swap(&b);
  }
  inline void Swap(ContextTask* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContextTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContextTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContextTask>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContextTask& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ContextTask& from) {
    ContextTask::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextTask* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.ContextTask";
  }
  protected:
  explicit ContextTask(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromStationFieldNumber = 1,
    kToStationFieldNumber = 2,
    kTypeFieldNumber = 3,
    kFromActionFieldNumber = 4,
    kToActionFieldNumber = 5,
    kTaskInfoFieldNumber = 6,
    kRouteStartFieldNumber = 7,
    kRouteEndFieldNumber = 8,
  };
  // bytes FromStation = 1;
  void clear_fromstation();
  const std::string& fromstation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromstation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromstation();
  PROTOBUF_NODISCARD std::string* release_fromstation();
  void set_allocated_fromstation(std::string* fromstation);
  private:
  const std::string& _internal_fromstation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromstation(const std::string& value);
  std::string* _internal_mutable_fromstation();
  public:

  // bytes ToStation = 2;
  void clear_tostation();
  const std::string& tostation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tostation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tostation();
  PROTOBUF_NODISCARD std::string* release_tostation();
  void set_allocated_tostation(std::string* tostation);
  private:
  const std::string& _internal_tostation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tostation(const std::string& value);
  std::string* _internal_mutable_tostation();
  public:

  // bytes Type = 3;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string FromAction = 4;
  void clear_fromaction();
  const std::string& fromaction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fromaction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fromaction();
  PROTOBUF_NODISCARD std::string* release_fromaction();
  void set_allocated_fromaction(std::string* fromaction);
  private:
  const std::string& _internal_fromaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fromaction(const std::string& value);
  std::string* _internal_mutable_fromaction();
  public:

  // string ToAction = 5;
  void clear_toaction();
  const std::string& toaction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_toaction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_toaction();
  PROTOBUF_NODISCARD std::string* release_toaction();
  void set_allocated_toaction(std::string* toaction);
  private:
  const std::string& _internal_toaction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_toaction(const std::string& value);
  std::string* _internal_mutable_toaction();
  public:

  // bytes TaskInfo = 6;
  void clear_taskinfo();
  const std::string& taskinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_taskinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_taskinfo();
  PROTOBUF_NODISCARD std::string* release_taskinfo();
  void set_allocated_taskinfo(std::string* taskinfo);
  private:
  const std::string& _internal_taskinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskinfo(const std::string& value);
  std::string* _internal_mutable_taskinfo();
  public:

  // bytes routeStart = 7;
  void clear_routestart();
  const std::string& routestart() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routestart(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routestart();
  PROTOBUF_NODISCARD std::string* release_routestart();
  void set_allocated_routestart(std::string* routestart);
  private:
  const std::string& _internal_routestart() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routestart(const std::string& value);
  std::string* _internal_mutable_routestart();
  public:

  // bytes routeEnd = 8;
  void clear_routeend();
  const std::string& routeend() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_routeend(ArgT0&& arg0, ArgT... args);
  std::string* mutable_routeend();
  PROTOBUF_NODISCARD std::string* release_routeend();
  void set_allocated_routeend(std::string* routeend);
  private:
  const std::string& _internal_routeend() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_routeend(const std::string& value);
  std::string* _internal_mutable_routeend();
  public:

  // @@protoc_insertion_point(class_scope:camel.api.ContextTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromstation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tostation_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fromaction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr toaction_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr taskinfo_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routestart_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr routeend_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Coord final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Coord) */ {
 public:
  inline Coord() : Coord(nullptr) {}
  ~Coord() override;
  explicit PROTOBUF_CONSTEXPR Coord(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Coord(const Coord& from);
  Coord(Coord&& from) noexcept
    : Coord() {
    *this = ::std::move(from);
  }

  inline Coord& operator=(const Coord& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coord& operator=(Coord&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Coord& default_instance() {
    return *internal_default_instance();
  }
  static inline const Coord* internal_default_instance() {
    return reinterpret_cast<const Coord*>(
               &_Coord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Coord& a, Coord& b) {
    a.Swap(&b);
  }
  inline void Swap(Coord* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Coord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Coord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Coord>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Coord& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Coord& from) {
    Coord::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coord* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Coord";
  }
  protected:
  explicit Coord(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Coord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GStation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GStation) */ {
 public:
  inline GStation() : GStation(nullptr) {}
  ~GStation() override;
  explicit PROTOBUF_CONSTEXPR GStation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GStation(const GStation& from);
  GStation(GStation&& from) noexcept
    : GStation() {
    *this = ::std::move(from);
  }

  inline GStation& operator=(const GStation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GStation& operator=(GStation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GStation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GStation* internal_default_instance() {
    return reinterpret_cast<const GStation*>(
               &_GStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GStation& a, GStation& b) {
    a.Swap(&b);
  }
  inline void Swap(GStation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GStation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GStation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GStation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GStation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GStation& from) {
    GStation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GStation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GStation";
  }
  protected:
  explicit GStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRfidFieldNumber = 3,
    kTypeFieldNumber = 4,
    kNameFieldNumber = 5,
    kAreaFieldNumber = 6,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // string rfid = 3;
  void clear_rfid();
  const std::string& rfid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rfid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rfid();
  PROTOBUF_NODISCARD std::string* release_rfid();
  void set_allocated_rfid(std::string* rfid);
  private:
  const std::string& _internal_rfid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rfid(const std::string& value);
  std::string* _internal_mutable_rfid();
  public:

  // string type = 4;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string name = 5;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string area = 6;
  void clear_area();
  const std::string& area() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_area(ArgT0&& arg0, ArgT... args);
  std::string* mutable_area();
  PROTOBUF_NODISCARD std::string* release_area();
  void set_allocated_area(std::string* area);
  private:
  const std::string& _internal_area() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_area(const std::string& value);
  std::string* _internal_mutable_area();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GStation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rfid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr area_;
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GPath) */ {
 public:
  inline GPath() : GPath(nullptr) {}
  ~GPath() override;
  explicit PROTOBUF_CONSTEXPR GPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPath(const GPath& from);
  GPath(GPath&& from) noexcept
    : GPath() {
    *this = ::std::move(from);
  }

  inline GPath& operator=(const GPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPath& operator=(GPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPath* internal_default_instance() {
    return reinterpret_cast<const GPath*>(
               &_GPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GPath& a, GPath& b) {
    a.Swap(&b);
  }
  inline void Swap(GPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GPath& from) {
    GPath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GPath";
  }
  protected:
  explicit GPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // .camel.api.GStation from = 1;
  bool has_from() const;
  private:
  bool _internal_has_from() const;
  public:
  void clear_from();
  const ::camel::api::GStation& from() const;
  PROTOBUF_NODISCARD ::camel::api::GStation* release_from();
  ::camel::api::GStation* mutable_from();
  void set_allocated_from(::camel::api::GStation* from);
  private:
  const ::camel::api::GStation& _internal_from() const;
  ::camel::api::GStation* _internal_mutable_from();
  public:
  void unsafe_arena_set_allocated_from(
      ::camel::api::GStation* from);
  ::camel::api::GStation* unsafe_arena_release_from();

  // .camel.api.GStation to = 2;
  bool has_to() const;
  private:
  bool _internal_has_to() const;
  public:
  void clear_to();
  const ::camel::api::GStation& to() const;
  PROTOBUF_NODISCARD ::camel::api::GStation* release_to();
  ::camel::api::GStation* mutable_to();
  void set_allocated_to(::camel::api::GStation* to);
  private:
  const ::camel::api::GStation& _internal_to() const;
  ::camel::api::GStation* _internal_mutable_to();
  public:
  void unsafe_arena_set_allocated_to(
      ::camel::api::GStation* to);
  ::camel::api::GStation* unsafe_arena_release_to();

  // float radius = 3;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::camel::api::GStation* from_;
    ::camel::api::GStation* to_;
    float radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class PathCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.PathCollection) */ {
 public:
  inline PathCollection() : PathCollection(nullptr) {}
  ~PathCollection() override;
  explicit PROTOBUF_CONSTEXPR PathCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathCollection(const PathCollection& from);
  PathCollection(PathCollection&& from) noexcept
    : PathCollection() {
    *this = ::std::move(from);
  }

  inline PathCollection& operator=(const PathCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathCollection& operator=(PathCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathCollection* internal_default_instance() {
    return reinterpret_cast<const PathCollection*>(
               &_PathCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PathCollection& a, PathCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(PathCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathCollection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathCollection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathCollection& from) {
    PathCollection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.PathCollection";
  }
  protected:
  explicit PathCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathsFieldNumber = 1,
  };
  // repeated .camel.api.GPath paths = 1;
  int paths_size() const;
  private:
  int _internal_paths_size() const;
  public:
  void clear_paths();
  ::camel::api::GPath* mutable_paths(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GPath >*
      mutable_paths();
  private:
  const ::camel::api::GPath& _internal_paths(int index) const;
  ::camel::api::GPath* _internal_add_paths();
  public:
  const ::camel::api::GPath& paths(int index) const;
  ::camel::api::GPath* add_paths();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GPath >&
      paths() const;

  // @@protoc_insertion_point(class_scope:camel.api.PathCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GPath > paths_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class AvoidanceAreaCollection_AvoidanceArea final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.AvoidanceAreaCollection.AvoidanceArea) */ {
 public:
  inline AvoidanceAreaCollection_AvoidanceArea() : AvoidanceAreaCollection_AvoidanceArea(nullptr) {}
  ~AvoidanceAreaCollection_AvoidanceArea() override;
  explicit PROTOBUF_CONSTEXPR AvoidanceAreaCollection_AvoidanceArea(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvoidanceAreaCollection_AvoidanceArea(const AvoidanceAreaCollection_AvoidanceArea& from);
  AvoidanceAreaCollection_AvoidanceArea(AvoidanceAreaCollection_AvoidanceArea&& from) noexcept
    : AvoidanceAreaCollection_AvoidanceArea() {
    *this = ::std::move(from);
  }

  inline AvoidanceAreaCollection_AvoidanceArea& operator=(const AvoidanceAreaCollection_AvoidanceArea& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvoidanceAreaCollection_AvoidanceArea& operator=(AvoidanceAreaCollection_AvoidanceArea&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvoidanceAreaCollection_AvoidanceArea& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvoidanceAreaCollection_AvoidanceArea* internal_default_instance() {
    return reinterpret_cast<const AvoidanceAreaCollection_AvoidanceArea*>(
               &_AvoidanceAreaCollection_AvoidanceArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AvoidanceAreaCollection_AvoidanceArea& a, AvoidanceAreaCollection_AvoidanceArea& b) {
    a.Swap(&b);
  }
  inline void Swap(AvoidanceAreaCollection_AvoidanceArea* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvoidanceAreaCollection_AvoidanceArea* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvoidanceAreaCollection_AvoidanceArea* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvoidanceAreaCollection_AvoidanceArea>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvoidanceAreaCollection_AvoidanceArea& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvoidanceAreaCollection_AvoidanceArea& from) {
    AvoidanceAreaCollection_AvoidanceArea::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvoidanceAreaCollection_AvoidanceArea* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.AvoidanceAreaCollection.AvoidanceArea";
  }
  protected:
  explicit AvoidanceAreaCollection_AvoidanceArea(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .camel.api.Coord points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::camel::api::Coord* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::Coord >*
      mutable_points();
  private:
  const ::camel::api::Coord& _internal_points(int index) const;
  ::camel::api::Coord* _internal_add_points();
  public:
  const ::camel::api::Coord& points(int index) const;
  ::camel::api::Coord* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::Coord >&
      points() const;

  // @@protoc_insertion_point(class_scope:camel.api.AvoidanceAreaCollection.AvoidanceArea)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::Coord > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class AvoidanceAreaCollection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.AvoidanceAreaCollection) */ {
 public:
  inline AvoidanceAreaCollection() : AvoidanceAreaCollection(nullptr) {}
  ~AvoidanceAreaCollection() override;
  explicit PROTOBUF_CONSTEXPR AvoidanceAreaCollection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AvoidanceAreaCollection(const AvoidanceAreaCollection& from);
  AvoidanceAreaCollection(AvoidanceAreaCollection&& from) noexcept
    : AvoidanceAreaCollection() {
    *this = ::std::move(from);
  }

  inline AvoidanceAreaCollection& operator=(const AvoidanceAreaCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline AvoidanceAreaCollection& operator=(AvoidanceAreaCollection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AvoidanceAreaCollection& default_instance() {
    return *internal_default_instance();
  }
  static inline const AvoidanceAreaCollection* internal_default_instance() {
    return reinterpret_cast<const AvoidanceAreaCollection*>(
               &_AvoidanceAreaCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AvoidanceAreaCollection& a, AvoidanceAreaCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(AvoidanceAreaCollection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AvoidanceAreaCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AvoidanceAreaCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AvoidanceAreaCollection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AvoidanceAreaCollection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AvoidanceAreaCollection& from) {
    AvoidanceAreaCollection::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AvoidanceAreaCollection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.AvoidanceAreaCollection";
  }
  protected:
  explicit AvoidanceAreaCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AvoidanceAreaCollection_AvoidanceArea AvoidanceArea;

  // accessors -------------------------------------------------------

  enum : int {
    kAccessibleAreaFieldNumber = 1,
    kProhibitedAreaFieldNumber = 2,
  };
  // repeated .camel.api.AvoidanceAreaCollection.AvoidanceArea accessibleArea = 1;
  int accessiblearea_size() const;
  private:
  int _internal_accessiblearea_size() const;
  public:
  void clear_accessiblearea();
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* mutable_accessiblearea(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >*
      mutable_accessiblearea();
  private:
  const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& _internal_accessiblearea(int index) const;
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* _internal_add_accessiblearea();
  public:
  const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& accessiblearea(int index) const;
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* add_accessiblearea();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >&
      accessiblearea() const;

  // repeated .camel.api.AvoidanceAreaCollection.AvoidanceArea prohibitedArea = 2;
  int prohibitedarea_size() const;
  private:
  int _internal_prohibitedarea_size() const;
  public:
  void clear_prohibitedarea();
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* mutable_prohibitedarea(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >*
      mutable_prohibitedarea();
  private:
  const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& _internal_prohibitedarea(int index) const;
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* _internal_add_prohibitedarea();
  public:
  const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& prohibitedarea(int index) const;
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* add_prohibitedarea();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >&
      prohibitedarea() const;

  // @@protoc_insertion_point(class_scope:camel.api.AvoidanceAreaCollection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea > accessiblearea_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea > prohibitedarea_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Gamepad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Gamepad) */ {
 public:
  inline Gamepad() : Gamepad(nullptr) {}
  ~Gamepad() override;
  explicit PROTOBUF_CONSTEXPR Gamepad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Gamepad(const Gamepad& from);
  Gamepad(Gamepad&& from) noexcept
    : Gamepad() {
    *this = ::std::move(from);
  }

  inline Gamepad& operator=(const Gamepad& from) {
    CopyFrom(from);
    return *this;
  }
  inline Gamepad& operator=(Gamepad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Gamepad& default_instance() {
    return *internal_default_instance();
  }
  static inline const Gamepad* internal_default_instance() {
    return reinterpret_cast<const Gamepad*>(
               &_Gamepad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Gamepad& a, Gamepad& b) {
    a.Swap(&b);
  }
  inline void Swap(Gamepad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Gamepad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Gamepad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Gamepad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Gamepad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Gamepad& from) {
    Gamepad::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Gamepad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Gamepad";
  }
  protected:
  explicit Gamepad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 4,
    kVxFieldNumber = 1,
    kVyFieldNumber = 2,
    kWFieldNumber = 3,
  };
  // .camel.api.Token token = 4;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const ::camel::api::Token& token() const;
  PROTOBUF_NODISCARD ::camel::api::Token* release_token();
  ::camel::api::Token* mutable_token();
  void set_allocated_token(::camel::api::Token* token);
  private:
  const ::camel::api::Token& _internal_token() const;
  ::camel::api::Token* _internal_mutable_token();
  public:
  void unsafe_arena_set_allocated_token(
      ::camel::api::Token* token);
  ::camel::api::Token* unsafe_arena_release_token();

  // float vx = 1;
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 2;
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float w = 3;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Gamepad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::camel::api::Token* token_;
    float vx_;
    float vy_;
    float w_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GamepadControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GamepadControl) */ {
 public:
  inline GamepadControl() : GamepadControl(nullptr) {}
  ~GamepadControl() override;
  explicit PROTOBUF_CONSTEXPR GamepadControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GamepadControl(const GamepadControl& from);
  GamepadControl(GamepadControl&& from) noexcept
    : GamepadControl() {
    *this = ::std::move(from);
  }

  inline GamepadControl& operator=(const GamepadControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline GamepadControl& operator=(GamepadControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GamepadControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const GamepadControl* internal_default_instance() {
    return reinterpret_cast<const GamepadControl*>(
               &_GamepadControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GamepadControl& a, GamepadControl& b) {
    a.Swap(&b);
  }
  inline void Swap(GamepadControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GamepadControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GamepadControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GamepadControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GamepadControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GamepadControl& from) {
    GamepadControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GamepadControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GamepadControl";
  }
  protected:
  explicit GamepadControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kForceFieldNumber = 1,
  };
  // bool force = 1;
  void clear_force();
  bool force() const;
  void set_force(bool value);
  private:
  bool _internal_force() const;
  void _internal_set_force(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GamepadControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool force_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Token final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Token) */ {
 public:
  inline Token() : Token(nullptr) {}
  ~Token() override;
  explicit PROTOBUF_CONSTEXPR Token(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Token& default_instance() {
    return *internal_default_instance();
  }
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Token* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Token& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Token& from) {
    Token::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Token";
  }
  protected:
  explicit Token(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .camel.api.Result result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::camel::api::Result& result() const;
  PROTOBUF_NODISCARD ::camel::api::Result* release_result();
  ::camel::api::Result* mutable_result();
  void set_allocated_result(::camel::api::Result* result);
  private:
  const ::camel::api::Result& _internal_result() const;
  ::camel::api::Result* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::camel::api::Result* result);
  ::camel::api::Result* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:camel.api.Token)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::camel::api::Result* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchPoints_MatchPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.MatchPoints.MatchPoint) */ {
 public:
  inline MatchPoints_MatchPoint() : MatchPoints_MatchPoint(nullptr) {}
  ~MatchPoints_MatchPoint() override;
  explicit PROTOBUF_CONSTEXPR MatchPoints_MatchPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchPoints_MatchPoint(const MatchPoints_MatchPoint& from);
  MatchPoints_MatchPoint(MatchPoints_MatchPoint&& from) noexcept
    : MatchPoints_MatchPoint() {
    *this = ::std::move(from);
  }

  inline MatchPoints_MatchPoint& operator=(const MatchPoints_MatchPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchPoints_MatchPoint& operator=(MatchPoints_MatchPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchPoints_MatchPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchPoints_MatchPoint* internal_default_instance() {
    return reinterpret_cast<const MatchPoints_MatchPoint*>(
               &_MatchPoints_MatchPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MatchPoints_MatchPoint& a, MatchPoints_MatchPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchPoints_MatchPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchPoints_MatchPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchPoints_MatchPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchPoints_MatchPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchPoints_MatchPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchPoints_MatchPoint& from) {
    MatchPoints_MatchPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchPoints_MatchPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.MatchPoints.MatchPoint";
  }
  protected:
  explicit MatchPoints_MatchPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kPosFieldNumber = 1,
  };
  // bytes description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .camel.api.Position pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::camel::api::Position& pos() const;
  PROTOBUF_NODISCARD ::camel::api::Position* release_pos();
  ::camel::api::Position* mutable_pos();
  void set_allocated_pos(::camel::api::Position* pos);
  private:
  const ::camel::api::Position& _internal_pos() const;
  ::camel::api::Position* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::camel::api::Position* pos);
  ::camel::api::Position* unsafe_arena_release_pos();

  // @@protoc_insertion_point(class_scope:camel.api.MatchPoints.MatchPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::camel::api::Position* pos_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchPoints final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.MatchPoints) */ {
 public:
  inline MatchPoints() : MatchPoints(nullptr) {}
  ~MatchPoints() override;
  explicit PROTOBUF_CONSTEXPR MatchPoints(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchPoints(const MatchPoints& from);
  MatchPoints(MatchPoints&& from) noexcept
    : MatchPoints() {
    *this = ::std::move(from);
  }

  inline MatchPoints& operator=(const MatchPoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchPoints& operator=(MatchPoints&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchPoints& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchPoints* internal_default_instance() {
    return reinterpret_cast<const MatchPoints*>(
               &_MatchPoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MatchPoints& a, MatchPoints& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchPoints* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchPoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchPoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchPoints>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchPoints& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchPoints& from) {
    MatchPoints::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchPoints* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.MatchPoints";
  }
  protected:
  explicit MatchPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatchPoints_MatchPoint MatchPoint;

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
  };
  // repeated .camel.api.MatchPoints.MatchPoint points = 1;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::camel::api::MatchPoints_MatchPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::MatchPoints_MatchPoint >*
      mutable_points();
  private:
  const ::camel::api::MatchPoints_MatchPoint& _internal_points(int index) const;
  ::camel::api::MatchPoints_MatchPoint* _internal_add_points();
  public:
  const ::camel::api::MatchPoints_MatchPoint& points(int index) const;
  ::camel::api::MatchPoints_MatchPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::MatchPoints_MatchPoint >&
      points() const;

  // @@protoc_insertion_point(class_scope:camel.api.MatchPoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::MatchPoints_MatchPoint > points_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class MatchPointCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.MatchPointCommand) */ {
 public:
  inline MatchPointCommand() : MatchPointCommand(nullptr) {}
  ~MatchPointCommand() override;
  explicit PROTOBUF_CONSTEXPR MatchPointCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchPointCommand(const MatchPointCommand& from);
  MatchPointCommand(MatchPointCommand&& from) noexcept
    : MatchPointCommand() {
    *this = ::std::move(from);
  }

  inline MatchPointCommand& operator=(const MatchPointCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchPointCommand& operator=(MatchPointCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchPointCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchPointCommand* internal_default_instance() {
    return reinterpret_cast<const MatchPointCommand*>(
               &_MatchPointCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(MatchPointCommand& a, MatchPointCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchPointCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchPointCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchPointCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchPointCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchPointCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MatchPointCommand& from) {
    MatchPointCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchPointCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.MatchPointCommand";
  }
  protected:
  explicit MatchPointCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 1,
    kRemoveFieldNumber = 2,
  };
  // .camel.api.MatchPoints points = 1;
  bool has_points() const;
  private:
  bool _internal_has_points() const;
  public:
  void clear_points();
  const ::camel::api::MatchPoints& points() const;
  PROTOBUF_NODISCARD ::camel::api::MatchPoints* release_points();
  ::camel::api::MatchPoints* mutable_points();
  void set_allocated_points(::camel::api::MatchPoints* points);
  private:
  const ::camel::api::MatchPoints& _internal_points() const;
  ::camel::api::MatchPoints* _internal_mutable_points();
  public:
  void unsafe_arena_set_allocated_points(
      ::camel::api::MatchPoints* points);
  ::camel::api::MatchPoints* unsafe_arena_release_points();

  // bool remove = 2;
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);
  private:
  bool _internal_remove() const;
  void _internal_set_remove(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.MatchPointCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::camel::api::MatchPoints* points_;
    bool remove_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GrpcTaskStation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GrpcTaskStation) */ {
 public:
  inline GrpcTaskStation() : GrpcTaskStation(nullptr) {}
  ~GrpcTaskStation() override;
  explicit PROTOBUF_CONSTEXPR GrpcTaskStation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcTaskStation(const GrpcTaskStation& from);
  GrpcTaskStation(GrpcTaskStation&& from) noexcept
    : GrpcTaskStation() {
    *this = ::std::move(from);
  }

  inline GrpcTaskStation& operator=(const GrpcTaskStation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcTaskStation& operator=(GrpcTaskStation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcTaskStation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcTaskStation* internal_default_instance() {
    return reinterpret_cast<const GrpcTaskStation*>(
               &_GrpcTaskStation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GrpcTaskStation& a, GrpcTaskStation& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcTaskStation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcTaskStation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcTaskStation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcTaskStation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcTaskStation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcTaskStation& from) {
    GrpcTaskStation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcTaskStation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GrpcTaskStation";
  }
  protected:
  explicit GrpcTaskStation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GrpcTaskStation_TaskAction TaskAction;
  static constexpr TaskAction kGet =
    GrpcTaskStation_TaskAction_kGet;
  static constexpr TaskAction kPut =
    GrpcTaskStation_TaskAction_kPut;
  static constexpr TaskAction kWait =
    GrpcTaskStation_TaskAction_kWait;
  static inline bool TaskAction_IsValid(int value) {
    return GrpcTaskStation_TaskAction_IsValid(value);
  }
  static constexpr TaskAction TaskAction_MIN =
    GrpcTaskStation_TaskAction_TaskAction_MIN;
  static constexpr TaskAction TaskAction_MAX =
    GrpcTaskStation_TaskAction_TaskAction_MAX;
  static constexpr int TaskAction_ARRAYSIZE =
    GrpcTaskStation_TaskAction_TaskAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TaskAction_descriptor() {
    return GrpcTaskStation_TaskAction_descriptor();
  }
  template<typename T>
  static inline const std::string& TaskAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TaskAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TaskAction_Name.");
    return GrpcTaskStation_TaskAction_Name(enum_t_value);
  }
  static inline bool TaskAction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TaskAction* value) {
    return GrpcTaskStation_TaskAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRfidFieldNumber = 1,
    kActionFieldNumber = 2,
  };
  // string rfid = 1;
  void clear_rfid();
  const std::string& rfid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rfid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rfid();
  PROTOBUF_NODISCARD std::string* release_rfid();
  void set_allocated_rfid(std::string* rfid);
  private:
  const std::string& _internal_rfid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rfid(const std::string& value);
  std::string* _internal_mutable_rfid();
  public:

  // .camel.api.GrpcTaskStation.TaskAction action = 2;
  void clear_action();
  ::camel::api::GrpcTaskStation_TaskAction action() const;
  void set_action(::camel::api::GrpcTaskStation_TaskAction value);
  private:
  ::camel::api::GrpcTaskStation_TaskAction _internal_action() const;
  void _internal_set_action(::camel::api::GrpcTaskStation_TaskAction value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GrpcTaskStation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rfid_;
    int action_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GrpcTaskAllocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GrpcTaskAllocation) */ {
 public:
  inline GrpcTaskAllocation() : GrpcTaskAllocation(nullptr) {}
  ~GrpcTaskAllocation() override;
  explicit PROTOBUF_CONSTEXPR GrpcTaskAllocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcTaskAllocation(const GrpcTaskAllocation& from);
  GrpcTaskAllocation(GrpcTaskAllocation&& from) noexcept
    : GrpcTaskAllocation() {
    *this = ::std::move(from);
  }

  inline GrpcTaskAllocation& operator=(const GrpcTaskAllocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcTaskAllocation& operator=(GrpcTaskAllocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcTaskAllocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcTaskAllocation* internal_default_instance() {
    return reinterpret_cast<const GrpcTaskAllocation*>(
               &_GrpcTaskAllocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GrpcTaskAllocation& a, GrpcTaskAllocation& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcTaskAllocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcTaskAllocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcTaskAllocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcTaskAllocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcTaskAllocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcTaskAllocation& from) {
    GrpcTaskAllocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcTaskAllocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GrpcTaskAllocation";
  }
  protected:
  explicit GrpcTaskAllocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStationsFieldNumber = 3,
    kIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kCircleFieldNumber = 4,
  };
  // repeated .camel.api.GrpcTaskStation stations = 3;
  int stations_size() const;
  private:
  int _internal_stations_size() const;
  public:
  void clear_stations();
  ::camel::api::GrpcTaskStation* mutable_stations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskStation >*
      mutable_stations();
  private:
  const ::camel::api::GrpcTaskStation& _internal_stations(int index) const;
  ::camel::api::GrpcTaskStation* _internal_add_stations();
  public:
  const ::camel::api::GrpcTaskStation& stations(int index) const;
  ::camel::api::GrpcTaskStation* add_stations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskStation >&
      stations() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // bool circle = 4;
  void clear_circle();
  bool circle() const;
  void set_circle(bool value);
  private:
  bool _internal_circle() const;
  void _internal_set_circle(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GrpcTaskAllocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskStation > stations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    bool circle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GrpcTaskOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GrpcTaskOperation) */ {
 public:
  inline GrpcTaskOperation() : GrpcTaskOperation(nullptr) {}
  ~GrpcTaskOperation() override;
  explicit PROTOBUF_CONSTEXPR GrpcTaskOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcTaskOperation(const GrpcTaskOperation& from);
  GrpcTaskOperation(GrpcTaskOperation&& from) noexcept
    : GrpcTaskOperation() {
    *this = ::std::move(from);
  }

  inline GrpcTaskOperation& operator=(const GrpcTaskOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcTaskOperation& operator=(GrpcTaskOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcTaskOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcTaskOperation* internal_default_instance() {
    return reinterpret_cast<const GrpcTaskOperation*>(
               &_GrpcTaskOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GrpcTaskOperation& a, GrpcTaskOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcTaskOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcTaskOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcTaskOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcTaskOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcTaskOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcTaskOperation& from) {
    GrpcTaskOperation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcTaskOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GrpcTaskOperation";
  }
  protected:
  explicit GrpcTaskOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GrpcTaskOperation_Operation Operation;
  static constexpr Operation kNew =
    GrpcTaskOperation_Operation_kNew;
  static constexpr Operation kDelete =
    GrpcTaskOperation_Operation_kDelete;
  static constexpr Operation kQuery =
    GrpcTaskOperation_Operation_kQuery;
  static constexpr Operation kCall =
    GrpcTaskOperation_Operation_kCall;
  static constexpr Operation kGoto =
    GrpcTaskOperation_Operation_kGoto;
  static constexpr Operation kCancel =
    GrpcTaskOperation_Operation_kCancel;
  static constexpr Operation kGotoCharging =
    GrpcTaskOperation_Operation_kGotoCharging;
  static constexpr Operation kSingleCar =
    GrpcTaskOperation_Operation_kSingleCar;
  static constexpr Operation kMuiltCar =
    GrpcTaskOperation_Operation_kMuiltCar;
  static inline bool Operation_IsValid(int value) {
    return GrpcTaskOperation_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    GrpcTaskOperation_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    GrpcTaskOperation_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    GrpcTaskOperation_Operation_Operation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operation_descriptor() {
    return GrpcTaskOperation_Operation_descriptor();
  }
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return GrpcTaskOperation_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return GrpcTaskOperation_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTaskFieldNumber = 1,
    kOptFieldNumber = 2,
  };
  // .camel.api.GrpcTaskAllocation task = 1;
  bool has_task() const;
  private:
  bool _internal_has_task() const;
  public:
  void clear_task();
  const ::camel::api::GrpcTaskAllocation& task() const;
  PROTOBUF_NODISCARD ::camel::api::GrpcTaskAllocation* release_task();
  ::camel::api::GrpcTaskAllocation* mutable_task();
  void set_allocated_task(::camel::api::GrpcTaskAllocation* task);
  private:
  const ::camel::api::GrpcTaskAllocation& _internal_task() const;
  ::camel::api::GrpcTaskAllocation* _internal_mutable_task();
  public:
  void unsafe_arena_set_allocated_task(
      ::camel::api::GrpcTaskAllocation* task);
  ::camel::api::GrpcTaskAllocation* unsafe_arena_release_task();

  // .camel.api.GrpcTaskOperation.Operation opt = 2;
  void clear_opt();
  ::camel::api::GrpcTaskOperation_Operation opt() const;
  void set_opt(::camel::api::GrpcTaskOperation_Operation value);
  private:
  ::camel::api::GrpcTaskOperation_Operation _internal_opt() const;
  void _internal_set_opt(::camel::api::GrpcTaskOperation_Operation value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GrpcTaskOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::camel::api::GrpcTaskAllocation* task_;
    int opt_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GrpcTaskAllocations final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GrpcTaskAllocations) */ {
 public:
  inline GrpcTaskAllocations() : GrpcTaskAllocations(nullptr) {}
  ~GrpcTaskAllocations() override;
  explicit PROTOBUF_CONSTEXPR GrpcTaskAllocations(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcTaskAllocations(const GrpcTaskAllocations& from);
  GrpcTaskAllocations(GrpcTaskAllocations&& from) noexcept
    : GrpcTaskAllocations() {
    *this = ::std::move(from);
  }

  inline GrpcTaskAllocations& operator=(const GrpcTaskAllocations& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcTaskAllocations& operator=(GrpcTaskAllocations&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcTaskAllocations& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcTaskAllocations* internal_default_instance() {
    return reinterpret_cast<const GrpcTaskAllocations*>(
               &_GrpcTaskAllocations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GrpcTaskAllocations& a, GrpcTaskAllocations& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcTaskAllocations* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcTaskAllocations* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcTaskAllocations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcTaskAllocations>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcTaskAllocations& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcTaskAllocations& from) {
    GrpcTaskAllocations::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcTaskAllocations* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GrpcTaskAllocations";
  }
  protected:
  explicit GrpcTaskAllocations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTasksFieldNumber = 1,
  };
  // repeated .camel.api.GrpcTaskAllocation tasks = 1;
  int tasks_size() const;
  private:
  int _internal_tasks_size() const;
  public:
  void clear_tasks();
  ::camel::api::GrpcTaskAllocation* mutable_tasks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskAllocation >*
      mutable_tasks();
  private:
  const ::camel::api::GrpcTaskAllocation& _internal_tasks(int index) const;
  ::camel::api::GrpcTaskAllocation* _internal_add_tasks();
  public:
  const ::camel::api::GrpcTaskAllocation& tasks(int index) const;
  ::camel::api::GrpcTaskAllocation* add_tasks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskAllocation >&
      tasks() const;

  // @@protoc_insertion_point(class_scope:camel.api.GrpcTaskAllocations)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskAllocation > tasks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class GrpcTaskInfomation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.GrpcTaskInfomation) */ {
 public:
  inline GrpcTaskInfomation() : GrpcTaskInfomation(nullptr) {}
  ~GrpcTaskInfomation() override;
  explicit PROTOBUF_CONSTEXPR GrpcTaskInfomation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GrpcTaskInfomation(const GrpcTaskInfomation& from);
  GrpcTaskInfomation(GrpcTaskInfomation&& from) noexcept
    : GrpcTaskInfomation() {
    *this = ::std::move(from);
  }

  inline GrpcTaskInfomation& operator=(const GrpcTaskInfomation& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrpcTaskInfomation& operator=(GrpcTaskInfomation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GrpcTaskInfomation& default_instance() {
    return *internal_default_instance();
  }
  static inline const GrpcTaskInfomation* internal_default_instance() {
    return reinterpret_cast<const GrpcTaskInfomation*>(
               &_GrpcTaskInfomation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GrpcTaskInfomation& a, GrpcTaskInfomation& b) {
    a.Swap(&b);
  }
  inline void Swap(GrpcTaskInfomation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GrpcTaskInfomation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GrpcTaskInfomation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GrpcTaskInfomation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GrpcTaskInfomation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GrpcTaskInfomation& from) {
    GrpcTaskInfomation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrpcTaskInfomation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.GrpcTaskInfomation";
  }
  protected:
  explicit GrpcTaskInfomation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptionFieldNumber = 2,
    kTargetFieldNumber = 3,
    kHasTaskFieldNumber = 1,
    kCircleFieldNumber = 4,
    kMulticarFieldNumber = 5,
  };
  // string description = 2;
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .camel.api.GrpcTaskStation target = 3;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::camel::api::GrpcTaskStation& target() const;
  PROTOBUF_NODISCARD ::camel::api::GrpcTaskStation* release_target();
  ::camel::api::GrpcTaskStation* mutable_target();
  void set_allocated_target(::camel::api::GrpcTaskStation* target);
  private:
  const ::camel::api::GrpcTaskStation& _internal_target() const;
  ::camel::api::GrpcTaskStation* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::camel::api::GrpcTaskStation* target);
  ::camel::api::GrpcTaskStation* unsafe_arena_release_target();

  // bool hasTask = 1;
  void clear_hastask();
  bool hastask() const;
  void set_hastask(bool value);
  private:
  bool _internal_hastask() const;
  void _internal_set_hastask(bool value);
  public:

  // bool circle = 4;
  void clear_circle();
  bool circle() const;
  void set_circle(bool value);
  private:
  bool _internal_circle() const;
  void _internal_set_circle(bool value);
  public:

  // bool multicar = 5;
  void clear_multicar();
  bool multicar() const;
  void set_multicar(bool value);
  private:
  bool _internal_multicar() const;
  void _internal_set_multicar(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.GrpcTaskInfomation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::camel::api::GrpcTaskStation* target_;
    bool hastask_;
    bool circle_;
    bool multicar_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class Collaborative final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.Collaborative) */ {
 public:
  inline Collaborative() : Collaborative(nullptr) {}
  ~Collaborative() override;
  explicit PROTOBUF_CONSTEXPR Collaborative(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collaborative(const Collaborative& from);
  Collaborative(Collaborative&& from) noexcept
    : Collaborative() {
    *this = ::std::move(from);
  }

  inline Collaborative& operator=(const Collaborative& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collaborative& operator=(Collaborative&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collaborative& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collaborative* internal_default_instance() {
    return reinterpret_cast<const Collaborative*>(
               &_Collaborative_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Collaborative& a, Collaborative& b) {
    a.Swap(&b);
  }
  inline void Swap(Collaborative* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collaborative* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collaborative* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collaborative>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collaborative& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Collaborative& from) {
    Collaborative::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collaborative* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.Collaborative";
  }
  protected:
  explicit Collaborative(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Collaborative_CooperationEnum CooperationEnum;
  static constexpr CooperationEnum kStartCooperation =
    Collaborative_CooperationEnum_kStartCooperation;
  static constexpr CooperationEnum kEndCooperation =
    Collaborative_CooperationEnum_kEndCooperation;
  static inline bool CooperationEnum_IsValid(int value) {
    return Collaborative_CooperationEnum_IsValid(value);
  }
  static constexpr CooperationEnum CooperationEnum_MIN =
    Collaborative_CooperationEnum_CooperationEnum_MIN;
  static constexpr CooperationEnum CooperationEnum_MAX =
    Collaborative_CooperationEnum_CooperationEnum_MAX;
  static constexpr int CooperationEnum_ARRAYSIZE =
    Collaborative_CooperationEnum_CooperationEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CooperationEnum_descriptor() {
    return Collaborative_CooperationEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& CooperationEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CooperationEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CooperationEnum_Name.");
    return Collaborative_CooperationEnum_Name(enum_t_value);
  }
  static inline bool CooperationEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CooperationEnum* value) {
    return Collaborative_CooperationEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadCarIpFieldNumber = 2,
    kRearCarIpFieldNumber = 3,
    kCooperationFieldNumber = 1,
    kIsMasterFieldNumber = 4,
  };
  // string headCarIp = 2;
  void clear_headcarip();
  const std::string& headcarip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headcarip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headcarip();
  PROTOBUF_NODISCARD std::string* release_headcarip();
  void set_allocated_headcarip(std::string* headcarip);
  private:
  const std::string& _internal_headcarip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headcarip(const std::string& value);
  std::string* _internal_mutable_headcarip();
  public:

  // string rearCarIp = 3;
  void clear_rearcarip();
  const std::string& rearcarip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rearcarip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rearcarip();
  PROTOBUF_NODISCARD std::string* release_rearcarip();
  void set_allocated_rearcarip(std::string* rearcarip);
  private:
  const std::string& _internal_rearcarip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rearcarip(const std::string& value);
  std::string* _internal_mutable_rearcarip();
  public:

  // .camel.api.Collaborative.CooperationEnum cooperation = 1;
  void clear_cooperation();
  ::camel::api::Collaborative_CooperationEnum cooperation() const;
  void set_cooperation(::camel::api::Collaborative_CooperationEnum value);
  private:
  ::camel::api::Collaborative_CooperationEnum _internal_cooperation() const;
  void _internal_set_cooperation(::camel::api::Collaborative_CooperationEnum value);
  public:

  // bool isMaster = 4;
  void clear_ismaster();
  bool ismaster() const;
  void set_ismaster(bool value);
  private:
  bool _internal_ismaster() const;
  void _internal_set_ismaster(bool value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.Collaborative)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headcarip_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rearcarip_;
    int cooperation_;
    bool ismaster_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// -------------------------------------------------------------------

class CollaborativeResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:camel.api.CollaborativeResult) */ {
 public:
  inline CollaborativeResult() : CollaborativeResult(nullptr) {}
  ~CollaborativeResult() override;
  explicit PROTOBUF_CONSTEXPR CollaborativeResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollaborativeResult(const CollaborativeResult& from);
  CollaborativeResult(CollaborativeResult&& from) noexcept
    : CollaborativeResult() {
    *this = ::std::move(from);
  }

  inline CollaborativeResult& operator=(const CollaborativeResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollaborativeResult& operator=(CollaborativeResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollaborativeResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollaborativeResult* internal_default_instance() {
    return reinterpret_cast<const CollaborativeResult*>(
               &_CollaborativeResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CollaborativeResult& a, CollaborativeResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CollaborativeResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollaborativeResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CollaborativeResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CollaborativeResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollaborativeResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CollaborativeResult& from) {
    CollaborativeResult::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollaborativeResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "camel.api.CollaborativeResult";
  }
  protected:
  explicit CollaborativeResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CollaborativeResult_Status Status;
  static constexpr Status kSuccess =
    CollaborativeResult_Status_kSuccess;
  static constexpr Status kFailed =
    CollaborativeResult_Status_kFailed;
  static inline bool Status_IsValid(int value) {
    return CollaborativeResult_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    CollaborativeResult_Status_Status_MIN;
  static constexpr Status Status_MAX =
    CollaborativeResult_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    CollaborativeResult_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return CollaborativeResult_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return CollaborativeResult_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return CollaborativeResult_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .camel.api.CollaborativeResult.Status result = 1;
  void clear_result();
  ::camel::api::CollaborativeResult_Status result() const;
  void set_result(::camel::api::CollaborativeResult_Status value);
  private:
  ::camel::api::CollaborativeResult_Status _internal_result() const;
  void _internal_set_result(::camel::api::CollaborativeResult_Status value);
  public:

  // @@protoc_insertion_point(class_scope:camel.api.CollaborativeResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_camel_2dcommon_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Result

// int32 errorCode = 1;
inline void Result::clear_errorcode() {
  _impl_.errorcode_ = 0;
}
inline int32_t Result::_internal_errorcode() const {
  return _impl_.errorcode_;
}
inline int32_t Result::errorcode() const {
  // @@protoc_insertion_point(field_get:camel.api.Result.errorCode)
  return _internal_errorcode();
}
inline void Result::_internal_set_errorcode(int32_t value) {
  
  _impl_.errorcode_ = value;
}
inline void Result::set_errorcode(int32_t value) {
  _internal_set_errorcode(value);
  // @@protoc_insertion_point(field_set:camel.api.Result.errorCode)
}

// bytes message = 2;
inline void Result::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Result::message() const {
  // @@protoc_insertion_point(field_get:camel.api.Result.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Result::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.Result.message)
}
inline std::string* Result::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:camel.api.Result.message)
  return _s;
}
inline const std::string& Result::_internal_message() const {
  return _impl_.message_.Get();
}
inline void Result::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* Result::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* Result::release_message() {
  // @@protoc_insertion_point(field_release:camel.api.Result.message)
  return _impl_.message_.Release();
}
inline void Result::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.Result.message)
}

// -------------------------------------------------------------------

// Battery

// float percent = 1;
inline void Battery::clear_percent() {
  _impl_.percent_ = 0;
}
inline float Battery::_internal_percent() const {
  return _impl_.percent_;
}
inline float Battery::percent() const {
  // @@protoc_insertion_point(field_get:camel.api.Battery.percent)
  return _internal_percent();
}
inline void Battery::_internal_set_percent(float value) {
  
  _impl_.percent_ = value;
}
inline void Battery::set_percent(float value) {
  _internal_set_percent(value);
  // @@protoc_insertion_point(field_set:camel.api.Battery.percent)
}

// .camel.api.Battery.ChargingState state = 2;
inline void Battery::clear_state() {
  _impl_.state_ = 0;
}
inline ::camel::api::Battery_ChargingState Battery::_internal_state() const {
  return static_cast< ::camel::api::Battery_ChargingState >(_impl_.state_);
}
inline ::camel::api::Battery_ChargingState Battery::state() const {
  // @@protoc_insertion_point(field_get:camel.api.Battery.state)
  return _internal_state();
}
inline void Battery::_internal_set_state(::camel::api::Battery_ChargingState value) {
  
  _impl_.state_ = value;
}
inline void Battery::set_state(::camel::api::Battery_ChargingState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:camel.api.Battery.state)
}

// -------------------------------------------------------------------

// CarHWInfo

// bool cargoState = 1;
inline void CarHWInfo::clear_cargostate() {
  _impl_.cargostate_ = false;
}
inline bool CarHWInfo::_internal_cargostate() const {
  return _impl_.cargostate_;
}
inline bool CarHWInfo::cargostate() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.cargoState)
  return _internal_cargostate();
}
inline void CarHWInfo::_internal_set_cargostate(bool value) {
  
  _impl_.cargostate_ = value;
}
inline void CarHWInfo::set_cargostate(bool value) {
  _internal_set_cargostate(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.cargoState)
}

// bool frontDetect = 2;
inline void CarHWInfo::clear_frontdetect() {
  _impl_.frontdetect_ = false;
}
inline bool CarHWInfo::_internal_frontdetect() const {
  return _impl_.frontdetect_;
}
inline bool CarHWInfo::frontdetect() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.frontDetect)
  return _internal_frontdetect();
}
inline void CarHWInfo::_internal_set_frontdetect(bool value) {
  
  _impl_.frontdetect_ = value;
}
inline void CarHWInfo::set_frontdetect(bool value) {
  _internal_set_frontdetect(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.frontDetect)
}

// bool backDetect = 3;
inline void CarHWInfo::clear_backdetect() {
  _impl_.backdetect_ = false;
}
inline bool CarHWInfo::_internal_backdetect() const {
  return _impl_.backdetect_;
}
inline bool CarHWInfo::backdetect() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.backDetect)
  return _internal_backdetect();
}
inline void CarHWInfo::_internal_set_backdetect(bool value) {
  
  _impl_.backdetect_ = value;
}
inline void CarHWInfo::set_backdetect(bool value) {
  _internal_set_backdetect(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.backDetect)
}

// bool inDetect = 4;
inline void CarHWInfo::clear_indetect() {
  _impl_.indetect_ = false;
}
inline bool CarHWInfo::_internal_indetect() const {
  return _impl_.indetect_;
}
inline bool CarHWInfo::indetect() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.inDetect)
  return _internal_indetect();
}
inline void CarHWInfo::_internal_set_indetect(bool value) {
  
  _impl_.indetect_ = value;
}
inline void CarHWInfo::set_indetect(bool value) {
  _internal_set_indetect(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.inDetect)
}

// bool leftFork = 5;
inline void CarHWInfo::clear_leftfork() {
  _impl_.leftfork_ = false;
}
inline bool CarHWInfo::_internal_leftfork() const {
  return _impl_.leftfork_;
}
inline bool CarHWInfo::leftfork() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.leftFork)
  return _internal_leftfork();
}
inline void CarHWInfo::_internal_set_leftfork(bool value) {
  
  _impl_.leftfork_ = value;
}
inline void CarHWInfo::set_leftfork(bool value) {
  _internal_set_leftfork(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.leftFork)
}

// bool rightFork = 6;
inline void CarHWInfo::clear_rightfork() {
  _impl_.rightfork_ = false;
}
inline bool CarHWInfo::_internal_rightfork() const {
  return _impl_.rightfork_;
}
inline bool CarHWInfo::rightfork() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.rightFork)
  return _internal_rightfork();
}
inline void CarHWInfo::_internal_set_rightfork(bool value) {
  
  _impl_.rightfork_ = value;
}
inline void CarHWInfo::set_rightfork(bool value) {
  _internal_set_rightfork(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.rightFork)
}

// bool mapNotMatch = 7;
inline void CarHWInfo::clear_mapnotmatch() {
  _impl_.mapnotmatch_ = false;
}
inline bool CarHWInfo::_internal_mapnotmatch() const {
  return _impl_.mapnotmatch_;
}
inline bool CarHWInfo::mapnotmatch() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.mapNotMatch)
  return _internal_mapnotmatch();
}
inline void CarHWInfo::_internal_set_mapnotmatch(bool value) {
  
  _impl_.mapnotmatch_ = value;
}
inline void CarHWInfo::set_mapnotmatch(bool value) {
  _internal_set_mapnotmatch(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.mapNotMatch)
}

// bool redLight = 8;
inline void CarHWInfo::clear_redlight() {
  _impl_.redlight_ = false;
}
inline bool CarHWInfo::_internal_redlight() const {
  return _impl_.redlight_;
}
inline bool CarHWInfo::redlight() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.redLight)
  return _internal_redlight();
}
inline void CarHWInfo::_internal_set_redlight(bool value) {
  
  _impl_.redlight_ = value;
}
inline void CarHWInfo::set_redlight(bool value) {
  _internal_set_redlight(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.redLight)
}

// bool ctrlMode = 9;
inline void CarHWInfo::clear_ctrlmode() {
  _impl_.ctrlmode_ = false;
}
inline bool CarHWInfo::_internal_ctrlmode() const {
  return _impl_.ctrlmode_;
}
inline bool CarHWInfo::ctrlmode() const {
  // @@protoc_insertion_point(field_get:camel.api.CarHWInfo.ctrlMode)
  return _internal_ctrlmode();
}
inline void CarHWInfo::_internal_set_ctrlmode(bool value) {
  
  _impl_.ctrlmode_ = value;
}
inline void CarHWInfo::set_ctrlmode(bool value) {
  _internal_set_ctrlmode(value);
  // @@protoc_insertion_point(field_set:camel.api.CarHWInfo.ctrlMode)
}

// -------------------------------------------------------------------

// Alarm

// int32 code = 1;
inline void Alarm::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t Alarm::_internal_code() const {
  return _impl_.code_;
}
inline int32_t Alarm::code() const {
  // @@protoc_insertion_point(field_get:camel.api.Alarm.code)
  return _internal_code();
}
inline void Alarm::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void Alarm::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:camel.api.Alarm.code)
}

// repeated bytes params = 2;
inline int Alarm::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int Alarm::params_size() const {
  return _internal_params_size();
}
inline void Alarm::clear_params() {
  _impl_.params_.Clear();
}
inline std::string* Alarm::add_params() {
  std::string* _s = _internal_add_params();
  // @@protoc_insertion_point(field_add_mutable:camel.api.Alarm.params)
  return _s;
}
inline const std::string& Alarm::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const std::string& Alarm::params(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.Alarm.params)
  return _internal_params(index);
}
inline std::string* Alarm::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.Alarm.params)
  return _impl_.params_.Mutable(index);
}
inline void Alarm::set_params(int index, const std::string& value) {
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:camel.api.Alarm.params)
}
inline void Alarm::set_params(int index, std::string&& value) {
  _impl_.params_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:camel.api.Alarm.params)
}
inline void Alarm::set_params(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:camel.api.Alarm.params)
}
inline void Alarm::set_params(int index, const void* value, size_t size) {
  _impl_.params_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:camel.api.Alarm.params)
}
inline std::string* Alarm::_internal_add_params() {
  return _impl_.params_.Add();
}
inline void Alarm::add_params(const std::string& value) {
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:camel.api.Alarm.params)
}
inline void Alarm::add_params(std::string&& value) {
  _impl_.params_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:camel.api.Alarm.params)
}
inline void Alarm::add_params(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.params_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:camel.api.Alarm.params)
}
inline void Alarm::add_params(const void* value, size_t size) {
  _impl_.params_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:camel.api.Alarm.params)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Alarm::params() const {
  // @@protoc_insertion_point(field_list:camel.api.Alarm.params)
  return _impl_.params_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Alarm::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.Alarm.params)
  return &_impl_.params_;
}

// -------------------------------------------------------------------

// ChargeCmd

// .camel.api.DoAction allowCharging = 1;
inline void ChargeCmd::clear_allowcharging() {
  _impl_.allowcharging_ = 0;
}
inline ::camel::api::DoAction ChargeCmd::_internal_allowcharging() const {
  return static_cast< ::camel::api::DoAction >(_impl_.allowcharging_);
}
inline ::camel::api::DoAction ChargeCmd::allowcharging() const {
  // @@protoc_insertion_point(field_get:camel.api.ChargeCmd.allowCharging)
  return _internal_allowcharging();
}
inline void ChargeCmd::_internal_set_allowcharging(::camel::api::DoAction value) {
  
  _impl_.allowcharging_ = value;
}
inline void ChargeCmd::set_allowcharging(::camel::api::DoAction value) {
  _internal_set_allowcharging(value);
  // @@protoc_insertion_point(field_set:camel.api.ChargeCmd.allowCharging)
}

// int32 channel = 2;
inline void ChargeCmd::clear_channel() {
  _impl_.channel_ = 0;
}
inline int32_t ChargeCmd::_internal_channel() const {
  return _impl_.channel_;
}
inline int32_t ChargeCmd::channel() const {
  // @@protoc_insertion_point(field_get:camel.api.ChargeCmd.channel)
  return _internal_channel();
}
inline void ChargeCmd::_internal_set_channel(int32_t value) {
  
  _impl_.channel_ = value;
}
inline void ChargeCmd::set_channel(int32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:camel.api.ChargeCmd.channel)
}

// -------------------------------------------------------------------

// Position

// float x = 1;
inline void Position::clear_x() {
  _impl_.x_ = 0;
}
inline float Position::_internal_x() const {
  return _impl_.x_;
}
inline float Position::x() const {
  // @@protoc_insertion_point(field_get:camel.api.Position.x)
  return _internal_x();
}
inline void Position::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Position::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:camel.api.Position.x)
}

// float y = 2;
inline void Position::clear_y() {
  _impl_.y_ = 0;
}
inline float Position::_internal_y() const {
  return _impl_.y_;
}
inline float Position::y() const {
  // @@protoc_insertion_point(field_get:camel.api.Position.y)
  return _internal_y();
}
inline void Position::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Position::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:camel.api.Position.y)
}

// float theta = 3;
inline void Position::clear_theta() {
  _impl_.theta_ = 0;
}
inline float Position::_internal_theta() const {
  return _impl_.theta_;
}
inline float Position::theta() const {
  // @@protoc_insertion_point(field_get:camel.api.Position.theta)
  return _internal_theta();
}
inline void Position::_internal_set_theta(float value) {
  
  _impl_.theta_ = value;
}
inline void Position::set_theta(float value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:camel.api.Position.theta)
}

// float confidence = 4;
inline void Position::clear_confidence() {
  _impl_.confidence_ = 0;
}
inline float Position::_internal_confidence() const {
  return _impl_.confidence_;
}
inline float Position::confidence() const {
  // @@protoc_insertion_point(field_get:camel.api.Position.confidence)
  return _internal_confidence();
}
inline void Position::_internal_set_confidence(float value) {
  
  _impl_.confidence_ = value;
}
inline void Position::set_confidence(float value) {
  _internal_set_confidence(value);
  // @@protoc_insertion_point(field_set:camel.api.Position.confidence)
}

// -------------------------------------------------------------------

// ContextTask

// bytes FromStation = 1;
inline void ContextTask::clear_fromstation() {
  _impl_.fromstation_.ClearToEmpty();
}
inline const std::string& ContextTask::fromstation() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.FromStation)
  return _internal_fromstation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_fromstation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromstation_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.FromStation)
}
inline std::string* ContextTask::mutable_fromstation() {
  std::string* _s = _internal_mutable_fromstation();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.FromStation)
  return _s;
}
inline const std::string& ContextTask::_internal_fromstation() const {
  return _impl_.fromstation_.Get();
}
inline void ContextTask::_internal_set_fromstation(const std::string& value) {
  
  _impl_.fromstation_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_fromstation() {
  
  return _impl_.fromstation_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_fromstation() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.FromStation)
  return _impl_.fromstation_.Release();
}
inline void ContextTask::set_allocated_fromstation(std::string* fromstation) {
  if (fromstation != nullptr) {
    
  } else {
    
  }
  _impl_.fromstation_.SetAllocated(fromstation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromstation_.IsDefault()) {
    _impl_.fromstation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.FromStation)
}

// bytes ToStation = 2;
inline void ContextTask::clear_tostation() {
  _impl_.tostation_.ClearToEmpty();
}
inline const std::string& ContextTask::tostation() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.ToStation)
  return _internal_tostation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_tostation(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tostation_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.ToStation)
}
inline std::string* ContextTask::mutable_tostation() {
  std::string* _s = _internal_mutable_tostation();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.ToStation)
  return _s;
}
inline const std::string& ContextTask::_internal_tostation() const {
  return _impl_.tostation_.Get();
}
inline void ContextTask::_internal_set_tostation(const std::string& value) {
  
  _impl_.tostation_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_tostation() {
  
  return _impl_.tostation_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_tostation() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.ToStation)
  return _impl_.tostation_.Release();
}
inline void ContextTask::set_allocated_tostation(std::string* tostation) {
  if (tostation != nullptr) {
    
  } else {
    
  }
  _impl_.tostation_.SetAllocated(tostation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tostation_.IsDefault()) {
    _impl_.tostation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.ToStation)
}

// bytes Type = 3;
inline void ContextTask::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& ContextTask::type() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.Type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.Type)
}
inline std::string* ContextTask::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.Type)
  return _s;
}
inline const std::string& ContextTask::_internal_type() const {
  return _impl_.type_.Get();
}
inline void ContextTask::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_type() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.Type)
  return _impl_.type_.Release();
}
inline void ContextTask::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.Type)
}

// string FromAction = 4;
inline void ContextTask::clear_fromaction() {
  _impl_.fromaction_.ClearToEmpty();
}
inline const std::string& ContextTask::fromaction() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.FromAction)
  return _internal_fromaction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_fromaction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.fromaction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.FromAction)
}
inline std::string* ContextTask::mutable_fromaction() {
  std::string* _s = _internal_mutable_fromaction();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.FromAction)
  return _s;
}
inline const std::string& ContextTask::_internal_fromaction() const {
  return _impl_.fromaction_.Get();
}
inline void ContextTask::_internal_set_fromaction(const std::string& value) {
  
  _impl_.fromaction_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_fromaction() {
  
  return _impl_.fromaction_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_fromaction() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.FromAction)
  return _impl_.fromaction_.Release();
}
inline void ContextTask::set_allocated_fromaction(std::string* fromaction) {
  if (fromaction != nullptr) {
    
  } else {
    
  }
  _impl_.fromaction_.SetAllocated(fromaction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.fromaction_.IsDefault()) {
    _impl_.fromaction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.FromAction)
}

// string ToAction = 5;
inline void ContextTask::clear_toaction() {
  _impl_.toaction_.ClearToEmpty();
}
inline const std::string& ContextTask::toaction() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.ToAction)
  return _internal_toaction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_toaction(ArgT0&& arg0, ArgT... args) {
 
 _impl_.toaction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.ToAction)
}
inline std::string* ContextTask::mutable_toaction() {
  std::string* _s = _internal_mutable_toaction();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.ToAction)
  return _s;
}
inline const std::string& ContextTask::_internal_toaction() const {
  return _impl_.toaction_.Get();
}
inline void ContextTask::_internal_set_toaction(const std::string& value) {
  
  _impl_.toaction_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_toaction() {
  
  return _impl_.toaction_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_toaction() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.ToAction)
  return _impl_.toaction_.Release();
}
inline void ContextTask::set_allocated_toaction(std::string* toaction) {
  if (toaction != nullptr) {
    
  } else {
    
  }
  _impl_.toaction_.SetAllocated(toaction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.toaction_.IsDefault()) {
    _impl_.toaction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.ToAction)
}

// bytes TaskInfo = 6;
inline void ContextTask::clear_taskinfo() {
  _impl_.taskinfo_.ClearToEmpty();
}
inline const std::string& ContextTask::taskinfo() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.TaskInfo)
  return _internal_taskinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_taskinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.taskinfo_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.TaskInfo)
}
inline std::string* ContextTask::mutable_taskinfo() {
  std::string* _s = _internal_mutable_taskinfo();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.TaskInfo)
  return _s;
}
inline const std::string& ContextTask::_internal_taskinfo() const {
  return _impl_.taskinfo_.Get();
}
inline void ContextTask::_internal_set_taskinfo(const std::string& value) {
  
  _impl_.taskinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_taskinfo() {
  
  return _impl_.taskinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_taskinfo() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.TaskInfo)
  return _impl_.taskinfo_.Release();
}
inline void ContextTask::set_allocated_taskinfo(std::string* taskinfo) {
  if (taskinfo != nullptr) {
    
  } else {
    
  }
  _impl_.taskinfo_.SetAllocated(taskinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.taskinfo_.IsDefault()) {
    _impl_.taskinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.TaskInfo)
}

// bytes routeStart = 7;
inline void ContextTask::clear_routestart() {
  _impl_.routestart_.ClearToEmpty();
}
inline const std::string& ContextTask::routestart() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.routeStart)
  return _internal_routestart();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_routestart(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routestart_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.routeStart)
}
inline std::string* ContextTask::mutable_routestart() {
  std::string* _s = _internal_mutable_routestart();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.routeStart)
  return _s;
}
inline const std::string& ContextTask::_internal_routestart() const {
  return _impl_.routestart_.Get();
}
inline void ContextTask::_internal_set_routestart(const std::string& value) {
  
  _impl_.routestart_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_routestart() {
  
  return _impl_.routestart_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_routestart() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.routeStart)
  return _impl_.routestart_.Release();
}
inline void ContextTask::set_allocated_routestart(std::string* routestart) {
  if (routestart != nullptr) {
    
  } else {
    
  }
  _impl_.routestart_.SetAllocated(routestart, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routestart_.IsDefault()) {
    _impl_.routestart_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.routeStart)
}

// bytes routeEnd = 8;
inline void ContextTask::clear_routeend() {
  _impl_.routeend_.ClearToEmpty();
}
inline const std::string& ContextTask::routeend() const {
  // @@protoc_insertion_point(field_get:camel.api.ContextTask.routeEnd)
  return _internal_routeend();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContextTask::set_routeend(ArgT0&& arg0, ArgT... args) {
 
 _impl_.routeend_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.ContextTask.routeEnd)
}
inline std::string* ContextTask::mutable_routeend() {
  std::string* _s = _internal_mutable_routeend();
  // @@protoc_insertion_point(field_mutable:camel.api.ContextTask.routeEnd)
  return _s;
}
inline const std::string& ContextTask::_internal_routeend() const {
  return _impl_.routeend_.Get();
}
inline void ContextTask::_internal_set_routeend(const std::string& value) {
  
  _impl_.routeend_.Set(value, GetArenaForAllocation());
}
inline std::string* ContextTask::_internal_mutable_routeend() {
  
  return _impl_.routeend_.Mutable(GetArenaForAllocation());
}
inline std::string* ContextTask::release_routeend() {
  // @@protoc_insertion_point(field_release:camel.api.ContextTask.routeEnd)
  return _impl_.routeend_.Release();
}
inline void ContextTask::set_allocated_routeend(std::string* routeend) {
  if (routeend != nullptr) {
    
  } else {
    
  }
  _impl_.routeend_.SetAllocated(routeend, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.routeend_.IsDefault()) {
    _impl_.routeend_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.ContextTask.routeEnd)
}

// -------------------------------------------------------------------

// Coord

// float x = 1;
inline void Coord::clear_x() {
  _impl_.x_ = 0;
}
inline float Coord::_internal_x() const {
  return _impl_.x_;
}
inline float Coord::x() const {
  // @@protoc_insertion_point(field_get:camel.api.Coord.x)
  return _internal_x();
}
inline void Coord::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Coord::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:camel.api.Coord.x)
}

// float y = 2;
inline void Coord::clear_y() {
  _impl_.y_ = 0;
}
inline float Coord::_internal_y() const {
  return _impl_.y_;
}
inline float Coord::y() const {
  // @@protoc_insertion_point(field_get:camel.api.Coord.y)
  return _internal_y();
}
inline void Coord::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Coord::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:camel.api.Coord.y)
}

// -------------------------------------------------------------------

// GStation

// float x = 1;
inline void GStation::clear_x() {
  _impl_.x_ = 0;
}
inline float GStation::_internal_x() const {
  return _impl_.x_;
}
inline float GStation::x() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.x)
  return _internal_x();
}
inline void GStation::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void GStation::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:camel.api.GStation.x)
}

// float y = 2;
inline void GStation::clear_y() {
  _impl_.y_ = 0;
}
inline float GStation::_internal_y() const {
  return _impl_.y_;
}
inline float GStation::y() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.y)
  return _internal_y();
}
inline void GStation::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void GStation::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:camel.api.GStation.y)
}

// string rfid = 3;
inline void GStation::clear_rfid() {
  _impl_.rfid_.ClearToEmpty();
}
inline const std::string& GStation::rfid() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.rfid)
  return _internal_rfid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GStation::set_rfid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rfid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GStation.rfid)
}
inline std::string* GStation::mutable_rfid() {
  std::string* _s = _internal_mutable_rfid();
  // @@protoc_insertion_point(field_mutable:camel.api.GStation.rfid)
  return _s;
}
inline const std::string& GStation::_internal_rfid() const {
  return _impl_.rfid_.Get();
}
inline void GStation::_internal_set_rfid(const std::string& value) {
  
  _impl_.rfid_.Set(value, GetArenaForAllocation());
}
inline std::string* GStation::_internal_mutable_rfid() {
  
  return _impl_.rfid_.Mutable(GetArenaForAllocation());
}
inline std::string* GStation::release_rfid() {
  // @@protoc_insertion_point(field_release:camel.api.GStation.rfid)
  return _impl_.rfid_.Release();
}
inline void GStation::set_allocated_rfid(std::string* rfid) {
  if (rfid != nullptr) {
    
  } else {
    
  }
  _impl_.rfid_.SetAllocated(rfid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rfid_.IsDefault()) {
    _impl_.rfid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GStation.rfid)
}

// string type = 4;
inline void GStation::clear_type() {
  _impl_.type_.ClearToEmpty();
}
inline const std::string& GStation::type() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GStation::set_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GStation.type)
}
inline std::string* GStation::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:camel.api.GStation.type)
  return _s;
}
inline const std::string& GStation::_internal_type() const {
  return _impl_.type_.Get();
}
inline void GStation::_internal_set_type(const std::string& value) {
  
  _impl_.type_.Set(value, GetArenaForAllocation());
}
inline std::string* GStation::_internal_mutable_type() {
  
  return _impl_.type_.Mutable(GetArenaForAllocation());
}
inline std::string* GStation::release_type() {
  // @@protoc_insertion_point(field_release:camel.api.GStation.type)
  return _impl_.type_.Release();
}
inline void GStation::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  _impl_.type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.type_.IsDefault()) {
    _impl_.type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GStation.type)
}

// string name = 5;
inline void GStation::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& GStation::name() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GStation::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GStation.name)
}
inline std::string* GStation::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:camel.api.GStation.name)
  return _s;
}
inline const std::string& GStation::_internal_name() const {
  return _impl_.name_.Get();
}
inline void GStation::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* GStation::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* GStation::release_name() {
  // @@protoc_insertion_point(field_release:camel.api.GStation.name)
  return _impl_.name_.Release();
}
inline void GStation::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GStation.name)
}

// string area = 6;
inline void GStation::clear_area() {
  _impl_.area_.ClearToEmpty();
}
inline const std::string& GStation::area() const {
  // @@protoc_insertion_point(field_get:camel.api.GStation.area)
  return _internal_area();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GStation::set_area(ArgT0&& arg0, ArgT... args) {
 
 _impl_.area_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GStation.area)
}
inline std::string* GStation::mutable_area() {
  std::string* _s = _internal_mutable_area();
  // @@protoc_insertion_point(field_mutable:camel.api.GStation.area)
  return _s;
}
inline const std::string& GStation::_internal_area() const {
  return _impl_.area_.Get();
}
inline void GStation::_internal_set_area(const std::string& value) {
  
  _impl_.area_.Set(value, GetArenaForAllocation());
}
inline std::string* GStation::_internal_mutable_area() {
  
  return _impl_.area_.Mutable(GetArenaForAllocation());
}
inline std::string* GStation::release_area() {
  // @@protoc_insertion_point(field_release:camel.api.GStation.area)
  return _impl_.area_.Release();
}
inline void GStation::set_allocated_area(std::string* area) {
  if (area != nullptr) {
    
  } else {
    
  }
  _impl_.area_.SetAllocated(area, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.area_.IsDefault()) {
    _impl_.area_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GStation.area)
}

// -------------------------------------------------------------------

// GPath

// .camel.api.GStation from = 1;
inline bool GPath::_internal_has_from() const {
  return this != internal_default_instance() && _impl_.from_ != nullptr;
}
inline bool GPath::has_from() const {
  return _internal_has_from();
}
inline void GPath::clear_from() {
  if (GetArenaForAllocation() == nullptr && _impl_.from_ != nullptr) {
    delete _impl_.from_;
  }
  _impl_.from_ = nullptr;
}
inline const ::camel::api::GStation& GPath::_internal_from() const {
  const ::camel::api::GStation* p = _impl_.from_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::GStation&>(
      ::camel::api::_GStation_default_instance_);
}
inline const ::camel::api::GStation& GPath::from() const {
  // @@protoc_insertion_point(field_get:camel.api.GPath.from)
  return _internal_from();
}
inline void GPath::unsafe_arena_set_allocated_from(
    ::camel::api::GStation* from) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.from_);
  }
  _impl_.from_ = from;
  if (from) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.GPath.from)
}
inline ::camel::api::GStation* GPath::release_from() {
  
  ::camel::api::GStation* temp = _impl_.from_;
  _impl_.from_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::GStation* GPath::unsafe_arena_release_from() {
  // @@protoc_insertion_point(field_release:camel.api.GPath.from)
  
  ::camel::api::GStation* temp = _impl_.from_;
  _impl_.from_ = nullptr;
  return temp;
}
inline ::camel::api::GStation* GPath::_internal_mutable_from() {
  
  if (_impl_.from_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::GStation>(GetArenaForAllocation());
    _impl_.from_ = p;
  }
  return _impl_.from_;
}
inline ::camel::api::GStation* GPath::mutable_from() {
  ::camel::api::GStation* _msg = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:camel.api.GPath.from)
  return _msg;
}
inline void GPath::set_allocated_from(::camel::api::GStation* from) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.from_;
  }
  if (from) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(from);
    if (message_arena != submessage_arena) {
      from = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, from, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.from_ = from;
  // @@protoc_insertion_point(field_set_allocated:camel.api.GPath.from)
}

// .camel.api.GStation to = 2;
inline bool GPath::_internal_has_to() const {
  return this != internal_default_instance() && _impl_.to_ != nullptr;
}
inline bool GPath::has_to() const {
  return _internal_has_to();
}
inline void GPath::clear_to() {
  if (GetArenaForAllocation() == nullptr && _impl_.to_ != nullptr) {
    delete _impl_.to_;
  }
  _impl_.to_ = nullptr;
}
inline const ::camel::api::GStation& GPath::_internal_to() const {
  const ::camel::api::GStation* p = _impl_.to_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::GStation&>(
      ::camel::api::_GStation_default_instance_);
}
inline const ::camel::api::GStation& GPath::to() const {
  // @@protoc_insertion_point(field_get:camel.api.GPath.to)
  return _internal_to();
}
inline void GPath::unsafe_arena_set_allocated_to(
    ::camel::api::GStation* to) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.to_);
  }
  _impl_.to_ = to;
  if (to) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.GPath.to)
}
inline ::camel::api::GStation* GPath::release_to() {
  
  ::camel::api::GStation* temp = _impl_.to_;
  _impl_.to_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::GStation* GPath::unsafe_arena_release_to() {
  // @@protoc_insertion_point(field_release:camel.api.GPath.to)
  
  ::camel::api::GStation* temp = _impl_.to_;
  _impl_.to_ = nullptr;
  return temp;
}
inline ::camel::api::GStation* GPath::_internal_mutable_to() {
  
  if (_impl_.to_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::GStation>(GetArenaForAllocation());
    _impl_.to_ = p;
  }
  return _impl_.to_;
}
inline ::camel::api::GStation* GPath::mutable_to() {
  ::camel::api::GStation* _msg = _internal_mutable_to();
  // @@protoc_insertion_point(field_mutable:camel.api.GPath.to)
  return _msg;
}
inline void GPath::set_allocated_to(::camel::api::GStation* to) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.to_;
  }
  if (to) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(to);
    if (message_arena != submessage_arena) {
      to = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, to, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.to_ = to;
  // @@protoc_insertion_point(field_set_allocated:camel.api.GPath.to)
}

// float radius = 3;
inline void GPath::clear_radius() {
  _impl_.radius_ = 0;
}
inline float GPath::_internal_radius() const {
  return _impl_.radius_;
}
inline float GPath::radius() const {
  // @@protoc_insertion_point(field_get:camel.api.GPath.radius)
  return _internal_radius();
}
inline void GPath::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void GPath::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:camel.api.GPath.radius)
}

// -------------------------------------------------------------------

// PathCollection

// repeated .camel.api.GPath paths = 1;
inline int PathCollection::_internal_paths_size() const {
  return _impl_.paths_.size();
}
inline int PathCollection::paths_size() const {
  return _internal_paths_size();
}
inline void PathCollection::clear_paths() {
  _impl_.paths_.Clear();
}
inline ::camel::api::GPath* PathCollection::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.PathCollection.paths)
  return _impl_.paths_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GPath >*
PathCollection::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.PathCollection.paths)
  return &_impl_.paths_;
}
inline const ::camel::api::GPath& PathCollection::_internal_paths(int index) const {
  return _impl_.paths_.Get(index);
}
inline const ::camel::api::GPath& PathCollection::paths(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.PathCollection.paths)
  return _internal_paths(index);
}
inline ::camel::api::GPath* PathCollection::_internal_add_paths() {
  return _impl_.paths_.Add();
}
inline ::camel::api::GPath* PathCollection::add_paths() {
  ::camel::api::GPath* _add = _internal_add_paths();
  // @@protoc_insertion_point(field_add:camel.api.PathCollection.paths)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GPath >&
PathCollection::paths() const {
  // @@protoc_insertion_point(field_list:camel.api.PathCollection.paths)
  return _impl_.paths_;
}

// -------------------------------------------------------------------

// AvoidanceAreaCollection_AvoidanceArea

// repeated .camel.api.Coord points = 1;
inline int AvoidanceAreaCollection_AvoidanceArea::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int AvoidanceAreaCollection_AvoidanceArea::points_size() const {
  return _internal_points_size();
}
inline void AvoidanceAreaCollection_AvoidanceArea::clear_points() {
  _impl_.points_.Clear();
}
inline ::camel::api::Coord* AvoidanceAreaCollection_AvoidanceArea::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.AvoidanceAreaCollection.AvoidanceArea.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::Coord >*
AvoidanceAreaCollection_AvoidanceArea::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.AvoidanceAreaCollection.AvoidanceArea.points)
  return &_impl_.points_;
}
inline const ::camel::api::Coord& AvoidanceAreaCollection_AvoidanceArea::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::camel::api::Coord& AvoidanceAreaCollection_AvoidanceArea::points(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.AvoidanceAreaCollection.AvoidanceArea.points)
  return _internal_points(index);
}
inline ::camel::api::Coord* AvoidanceAreaCollection_AvoidanceArea::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::camel::api::Coord* AvoidanceAreaCollection_AvoidanceArea::add_points() {
  ::camel::api::Coord* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:camel.api.AvoidanceAreaCollection.AvoidanceArea.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::Coord >&
AvoidanceAreaCollection_AvoidanceArea::points() const {
  // @@protoc_insertion_point(field_list:camel.api.AvoidanceAreaCollection.AvoidanceArea.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// AvoidanceAreaCollection

// repeated .camel.api.AvoidanceAreaCollection.AvoidanceArea accessibleArea = 1;
inline int AvoidanceAreaCollection::_internal_accessiblearea_size() const {
  return _impl_.accessiblearea_.size();
}
inline int AvoidanceAreaCollection::accessiblearea_size() const {
  return _internal_accessiblearea_size();
}
inline void AvoidanceAreaCollection::clear_accessiblearea() {
  _impl_.accessiblearea_.Clear();
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::mutable_accessiblearea(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.AvoidanceAreaCollection.accessibleArea)
  return _impl_.accessiblearea_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >*
AvoidanceAreaCollection::mutable_accessiblearea() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.AvoidanceAreaCollection.accessibleArea)
  return &_impl_.accessiblearea_;
}
inline const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& AvoidanceAreaCollection::_internal_accessiblearea(int index) const {
  return _impl_.accessiblearea_.Get(index);
}
inline const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& AvoidanceAreaCollection::accessiblearea(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.AvoidanceAreaCollection.accessibleArea)
  return _internal_accessiblearea(index);
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::_internal_add_accessiblearea() {
  return _impl_.accessiblearea_.Add();
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::add_accessiblearea() {
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* _add = _internal_add_accessiblearea();
  // @@protoc_insertion_point(field_add:camel.api.AvoidanceAreaCollection.accessibleArea)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >&
AvoidanceAreaCollection::accessiblearea() const {
  // @@protoc_insertion_point(field_list:camel.api.AvoidanceAreaCollection.accessibleArea)
  return _impl_.accessiblearea_;
}

// repeated .camel.api.AvoidanceAreaCollection.AvoidanceArea prohibitedArea = 2;
inline int AvoidanceAreaCollection::_internal_prohibitedarea_size() const {
  return _impl_.prohibitedarea_.size();
}
inline int AvoidanceAreaCollection::prohibitedarea_size() const {
  return _internal_prohibitedarea_size();
}
inline void AvoidanceAreaCollection::clear_prohibitedarea() {
  _impl_.prohibitedarea_.Clear();
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::mutable_prohibitedarea(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.AvoidanceAreaCollection.prohibitedArea)
  return _impl_.prohibitedarea_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >*
AvoidanceAreaCollection::mutable_prohibitedarea() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.AvoidanceAreaCollection.prohibitedArea)
  return &_impl_.prohibitedarea_;
}
inline const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& AvoidanceAreaCollection::_internal_prohibitedarea(int index) const {
  return _impl_.prohibitedarea_.Get(index);
}
inline const ::camel::api::AvoidanceAreaCollection_AvoidanceArea& AvoidanceAreaCollection::prohibitedarea(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.AvoidanceAreaCollection.prohibitedArea)
  return _internal_prohibitedarea(index);
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::_internal_add_prohibitedarea() {
  return _impl_.prohibitedarea_.Add();
}
inline ::camel::api::AvoidanceAreaCollection_AvoidanceArea* AvoidanceAreaCollection::add_prohibitedarea() {
  ::camel::api::AvoidanceAreaCollection_AvoidanceArea* _add = _internal_add_prohibitedarea();
  // @@protoc_insertion_point(field_add:camel.api.AvoidanceAreaCollection.prohibitedArea)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::AvoidanceAreaCollection_AvoidanceArea >&
AvoidanceAreaCollection::prohibitedarea() const {
  // @@protoc_insertion_point(field_list:camel.api.AvoidanceAreaCollection.prohibitedArea)
  return _impl_.prohibitedarea_;
}

// -------------------------------------------------------------------

// Gamepad

// float vx = 1;
inline void Gamepad::clear_vx() {
  _impl_.vx_ = 0;
}
inline float Gamepad::_internal_vx() const {
  return _impl_.vx_;
}
inline float Gamepad::vx() const {
  // @@protoc_insertion_point(field_get:camel.api.Gamepad.vx)
  return _internal_vx();
}
inline void Gamepad::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void Gamepad::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:camel.api.Gamepad.vx)
}

// float vy = 2;
inline void Gamepad::clear_vy() {
  _impl_.vy_ = 0;
}
inline float Gamepad::_internal_vy() const {
  return _impl_.vy_;
}
inline float Gamepad::vy() const {
  // @@protoc_insertion_point(field_get:camel.api.Gamepad.vy)
  return _internal_vy();
}
inline void Gamepad::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void Gamepad::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:camel.api.Gamepad.vy)
}

// float w = 3;
inline void Gamepad::clear_w() {
  _impl_.w_ = 0;
}
inline float Gamepad::_internal_w() const {
  return _impl_.w_;
}
inline float Gamepad::w() const {
  // @@protoc_insertion_point(field_get:camel.api.Gamepad.w)
  return _internal_w();
}
inline void Gamepad::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void Gamepad::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:camel.api.Gamepad.w)
}

// .camel.api.Token token = 4;
inline bool Gamepad::_internal_has_token() const {
  return this != internal_default_instance() && _impl_.token_ != nullptr;
}
inline bool Gamepad::has_token() const {
  return _internal_has_token();
}
inline void Gamepad::clear_token() {
  if (GetArenaForAllocation() == nullptr && _impl_.token_ != nullptr) {
    delete _impl_.token_;
  }
  _impl_.token_ = nullptr;
}
inline const ::camel::api::Token& Gamepad::_internal_token() const {
  const ::camel::api::Token* p = _impl_.token_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::Token&>(
      ::camel::api::_Token_default_instance_);
}
inline const ::camel::api::Token& Gamepad::token() const {
  // @@protoc_insertion_point(field_get:camel.api.Gamepad.token)
  return _internal_token();
}
inline void Gamepad::unsafe_arena_set_allocated_token(
    ::camel::api::Token* token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
  }
  _impl_.token_ = token;
  if (token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.Gamepad.token)
}
inline ::camel::api::Token* Gamepad::release_token() {
  
  ::camel::api::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::Token* Gamepad::unsafe_arena_release_token() {
  // @@protoc_insertion_point(field_release:camel.api.Gamepad.token)
  
  ::camel::api::Token* temp = _impl_.token_;
  _impl_.token_ = nullptr;
  return temp;
}
inline ::camel::api::Token* Gamepad::_internal_mutable_token() {
  
  if (_impl_.token_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::Token>(GetArenaForAllocation());
    _impl_.token_ = p;
  }
  return _impl_.token_;
}
inline ::camel::api::Token* Gamepad::mutable_token() {
  ::camel::api::Token* _msg = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:camel.api.Gamepad.token)
  return _msg;
}
inline void Gamepad::set_allocated_token(::camel::api::Token* token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.token_;
  }
  if (token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(token);
    if (message_arena != submessage_arena) {
      token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, token, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.token_ = token;
  // @@protoc_insertion_point(field_set_allocated:camel.api.Gamepad.token)
}

// -------------------------------------------------------------------

// GamepadControl

// bool force = 1;
inline void GamepadControl::clear_force() {
  _impl_.force_ = false;
}
inline bool GamepadControl::_internal_force() const {
  return _impl_.force_;
}
inline bool GamepadControl::force() const {
  // @@protoc_insertion_point(field_get:camel.api.GamepadControl.force)
  return _internal_force();
}
inline void GamepadControl::_internal_set_force(bool value) {
  
  _impl_.force_ = value;
}
inline void GamepadControl::set_force(bool value) {
  _internal_set_force(value);
  // @@protoc_insertion_point(field_set:camel.api.GamepadControl.force)
}

// -------------------------------------------------------------------

// Token

// string key = 1;
inline void Token::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& Token::key() const {
  // @@protoc_insertion_point(field_get:camel.api.Token.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Token::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.Token.key)
}
inline std::string* Token::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:camel.api.Token.key)
  return _s;
}
inline const std::string& Token::_internal_key() const {
  return _impl_.key_.Get();
}
inline void Token::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* Token::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* Token::release_key() {
  // @@protoc_insertion_point(field_release:camel.api.Token.key)
  return _impl_.key_.Release();
}
inline void Token::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.Token.key)
}

// .camel.api.Result result = 2;
inline bool Token::_internal_has_result() const {
  return this != internal_default_instance() && _impl_.result_ != nullptr;
}
inline bool Token::has_result() const {
  return _internal_has_result();
}
inline void Token::clear_result() {
  if (GetArenaForAllocation() == nullptr && _impl_.result_ != nullptr) {
    delete _impl_.result_;
  }
  _impl_.result_ = nullptr;
}
inline const ::camel::api::Result& Token::_internal_result() const {
  const ::camel::api::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::Result&>(
      ::camel::api::_Result_default_instance_);
}
inline const ::camel::api::Result& Token::result() const {
  // @@protoc_insertion_point(field_get:camel.api.Token.result)
  return _internal_result();
}
inline void Token::unsafe_arena_set_allocated_result(
    ::camel::api::Result* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = result;
  if (result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.Token.result)
}
inline ::camel::api::Result* Token::release_result() {
  
  ::camel::api::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::Result* Token::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:camel.api.Token.result)
  
  ::camel::api::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::camel::api::Result* Token::_internal_mutable_result() {
  
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::Result>(GetArenaForAllocation());
    _impl_.result_ = p;
  }
  return _impl_.result_;
}
inline ::camel::api::Result* Token::mutable_result() {
  ::camel::api::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:camel.api.Token.result)
  return _msg;
}
inline void Token::set_allocated_result(::camel::api::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.result_ = result;
  // @@protoc_insertion_point(field_set_allocated:camel.api.Token.result)
}

// -------------------------------------------------------------------

// MatchPoints_MatchPoint

// .camel.api.Position pos = 1;
inline bool MatchPoints_MatchPoint::_internal_has_pos() const {
  return this != internal_default_instance() && _impl_.pos_ != nullptr;
}
inline bool MatchPoints_MatchPoint::has_pos() const {
  return _internal_has_pos();
}
inline void MatchPoints_MatchPoint::clear_pos() {
  if (GetArenaForAllocation() == nullptr && _impl_.pos_ != nullptr) {
    delete _impl_.pos_;
  }
  _impl_.pos_ = nullptr;
}
inline const ::camel::api::Position& MatchPoints_MatchPoint::_internal_pos() const {
  const ::camel::api::Position* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::Position&>(
      ::camel::api::_Position_default_instance_);
}
inline const ::camel::api::Position& MatchPoints_MatchPoint::pos() const {
  // @@protoc_insertion_point(field_get:camel.api.MatchPoints.MatchPoint.pos)
  return _internal_pos();
}
inline void MatchPoints_MatchPoint::unsafe_arena_set_allocated_pos(
    ::camel::api::Position* pos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.MatchPoints.MatchPoint.pos)
}
inline ::camel::api::Position* MatchPoints_MatchPoint::release_pos() {
  
  ::camel::api::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::Position* MatchPoints_MatchPoint::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:camel.api.MatchPoints.MatchPoint.pos)
  
  ::camel::api::Position* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::camel::api::Position* MatchPoints_MatchPoint::_internal_mutable_pos() {
  
  if (_impl_.pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::Position>(GetArenaForAllocation());
    _impl_.pos_ = p;
  }
  return _impl_.pos_;
}
inline ::camel::api::Position* MatchPoints_MatchPoint::mutable_pos() {
  ::camel::api::Position* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:camel.api.MatchPoints.MatchPoint.pos)
  return _msg;
}
inline void MatchPoints_MatchPoint::set_allocated_pos(::camel::api::Position* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:camel.api.MatchPoints.MatchPoint.pos)
}

// bytes description = 2;
inline void MatchPoints_MatchPoint::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& MatchPoints_MatchPoint::description() const {
  // @@protoc_insertion_point(field_get:camel.api.MatchPoints.MatchPoint.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchPoints_MatchPoint::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.MatchPoints.MatchPoint.description)
}
inline std::string* MatchPoints_MatchPoint::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:camel.api.MatchPoints.MatchPoint.description)
  return _s;
}
inline const std::string& MatchPoints_MatchPoint::_internal_description() const {
  return _impl_.description_.Get();
}
inline void MatchPoints_MatchPoint::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchPoints_MatchPoint::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchPoints_MatchPoint::release_description() {
  // @@protoc_insertion_point(field_release:camel.api.MatchPoints.MatchPoint.description)
  return _impl_.description_.Release();
}
inline void MatchPoints_MatchPoint::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.MatchPoints.MatchPoint.description)
}

// -------------------------------------------------------------------

// MatchPoints

// repeated .camel.api.MatchPoints.MatchPoint points = 1;
inline int MatchPoints::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int MatchPoints::points_size() const {
  return _internal_points_size();
}
inline void MatchPoints::clear_points() {
  _impl_.points_.Clear();
}
inline ::camel::api::MatchPoints_MatchPoint* MatchPoints::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.MatchPoints.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::MatchPoints_MatchPoint >*
MatchPoints::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.MatchPoints.points)
  return &_impl_.points_;
}
inline const ::camel::api::MatchPoints_MatchPoint& MatchPoints::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::camel::api::MatchPoints_MatchPoint& MatchPoints::points(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.MatchPoints.points)
  return _internal_points(index);
}
inline ::camel::api::MatchPoints_MatchPoint* MatchPoints::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::camel::api::MatchPoints_MatchPoint* MatchPoints::add_points() {
  ::camel::api::MatchPoints_MatchPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:camel.api.MatchPoints.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::MatchPoints_MatchPoint >&
MatchPoints::points() const {
  // @@protoc_insertion_point(field_list:camel.api.MatchPoints.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// MatchPointCommand

// .camel.api.MatchPoints points = 1;
inline bool MatchPointCommand::_internal_has_points() const {
  return this != internal_default_instance() && _impl_.points_ != nullptr;
}
inline bool MatchPointCommand::has_points() const {
  return _internal_has_points();
}
inline void MatchPointCommand::clear_points() {
  if (GetArenaForAllocation() == nullptr && _impl_.points_ != nullptr) {
    delete _impl_.points_;
  }
  _impl_.points_ = nullptr;
}
inline const ::camel::api::MatchPoints& MatchPointCommand::_internal_points() const {
  const ::camel::api::MatchPoints* p = _impl_.points_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::MatchPoints&>(
      ::camel::api::_MatchPoints_default_instance_);
}
inline const ::camel::api::MatchPoints& MatchPointCommand::points() const {
  // @@protoc_insertion_point(field_get:camel.api.MatchPointCommand.points)
  return _internal_points();
}
inline void MatchPointCommand::unsafe_arena_set_allocated_points(
    ::camel::api::MatchPoints* points) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.points_);
  }
  _impl_.points_ = points;
  if (points) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.MatchPointCommand.points)
}
inline ::camel::api::MatchPoints* MatchPointCommand::release_points() {
  
  ::camel::api::MatchPoints* temp = _impl_.points_;
  _impl_.points_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::MatchPoints* MatchPointCommand::unsafe_arena_release_points() {
  // @@protoc_insertion_point(field_release:camel.api.MatchPointCommand.points)
  
  ::camel::api::MatchPoints* temp = _impl_.points_;
  _impl_.points_ = nullptr;
  return temp;
}
inline ::camel::api::MatchPoints* MatchPointCommand::_internal_mutable_points() {
  
  if (_impl_.points_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::MatchPoints>(GetArenaForAllocation());
    _impl_.points_ = p;
  }
  return _impl_.points_;
}
inline ::camel::api::MatchPoints* MatchPointCommand::mutable_points() {
  ::camel::api::MatchPoints* _msg = _internal_mutable_points();
  // @@protoc_insertion_point(field_mutable:camel.api.MatchPointCommand.points)
  return _msg;
}
inline void MatchPointCommand::set_allocated_points(::camel::api::MatchPoints* points) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.points_;
  }
  if (points) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(points);
    if (message_arena != submessage_arena) {
      points = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.points_ = points;
  // @@protoc_insertion_point(field_set_allocated:camel.api.MatchPointCommand.points)
}

// bool remove = 2;
inline void MatchPointCommand::clear_remove() {
  _impl_.remove_ = false;
}
inline bool MatchPointCommand::_internal_remove() const {
  return _impl_.remove_;
}
inline bool MatchPointCommand::remove() const {
  // @@protoc_insertion_point(field_get:camel.api.MatchPointCommand.remove)
  return _internal_remove();
}
inline void MatchPointCommand::_internal_set_remove(bool value) {
  
  _impl_.remove_ = value;
}
inline void MatchPointCommand::set_remove(bool value) {
  _internal_set_remove(value);
  // @@protoc_insertion_point(field_set:camel.api.MatchPointCommand.remove)
}

// -------------------------------------------------------------------

// GrpcTaskStation

// string rfid = 1;
inline void GrpcTaskStation::clear_rfid() {
  _impl_.rfid_.ClearToEmpty();
}
inline const std::string& GrpcTaskStation::rfid() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskStation.rfid)
  return _internal_rfid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrpcTaskStation::set_rfid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rfid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskStation.rfid)
}
inline std::string* GrpcTaskStation::mutable_rfid() {
  std::string* _s = _internal_mutable_rfid();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskStation.rfid)
  return _s;
}
inline const std::string& GrpcTaskStation::_internal_rfid() const {
  return _impl_.rfid_.Get();
}
inline void GrpcTaskStation::_internal_set_rfid(const std::string& value) {
  
  _impl_.rfid_.Set(value, GetArenaForAllocation());
}
inline std::string* GrpcTaskStation::_internal_mutable_rfid() {
  
  return _impl_.rfid_.Mutable(GetArenaForAllocation());
}
inline std::string* GrpcTaskStation::release_rfid() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskStation.rfid)
  return _impl_.rfid_.Release();
}
inline void GrpcTaskStation::set_allocated_rfid(std::string* rfid) {
  if (rfid != nullptr) {
    
  } else {
    
  }
  _impl_.rfid_.SetAllocated(rfid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rfid_.IsDefault()) {
    _impl_.rfid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskStation.rfid)
}

// .camel.api.GrpcTaskStation.TaskAction action = 2;
inline void GrpcTaskStation::clear_action() {
  _impl_.action_ = 0;
}
inline ::camel::api::GrpcTaskStation_TaskAction GrpcTaskStation::_internal_action() const {
  return static_cast< ::camel::api::GrpcTaskStation_TaskAction >(_impl_.action_);
}
inline ::camel::api::GrpcTaskStation_TaskAction GrpcTaskStation::action() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskStation.action)
  return _internal_action();
}
inline void GrpcTaskStation::_internal_set_action(::camel::api::GrpcTaskStation_TaskAction value) {
  
  _impl_.action_ = value;
}
inline void GrpcTaskStation::set_action(::camel::api::GrpcTaskStation_TaskAction value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskStation.action)
}

// -------------------------------------------------------------------

// GrpcTaskAllocation

// string id = 1;
inline void GrpcTaskAllocation::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GrpcTaskAllocation::id() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskAllocation.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrpcTaskAllocation::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskAllocation.id)
}
inline std::string* GrpcTaskAllocation::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskAllocation.id)
  return _s;
}
inline const std::string& GrpcTaskAllocation::_internal_id() const {
  return _impl_.id_.Get();
}
inline void GrpcTaskAllocation::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GrpcTaskAllocation::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* GrpcTaskAllocation::release_id() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskAllocation.id)
  return _impl_.id_.Release();
}
inline void GrpcTaskAllocation::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskAllocation.id)
}

// string description = 2;
inline void GrpcTaskAllocation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& GrpcTaskAllocation::description() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskAllocation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrpcTaskAllocation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskAllocation.description)
}
inline std::string* GrpcTaskAllocation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskAllocation.description)
  return _s;
}
inline const std::string& GrpcTaskAllocation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void GrpcTaskAllocation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* GrpcTaskAllocation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* GrpcTaskAllocation::release_description() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskAllocation.description)
  return _impl_.description_.Release();
}
inline void GrpcTaskAllocation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskAllocation.description)
}

// repeated .camel.api.GrpcTaskStation stations = 3;
inline int GrpcTaskAllocation::_internal_stations_size() const {
  return _impl_.stations_.size();
}
inline int GrpcTaskAllocation::stations_size() const {
  return _internal_stations_size();
}
inline void GrpcTaskAllocation::clear_stations() {
  _impl_.stations_.Clear();
}
inline ::camel::api::GrpcTaskStation* GrpcTaskAllocation::mutable_stations(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskAllocation.stations)
  return _impl_.stations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskStation >*
GrpcTaskAllocation::mutable_stations() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.GrpcTaskAllocation.stations)
  return &_impl_.stations_;
}
inline const ::camel::api::GrpcTaskStation& GrpcTaskAllocation::_internal_stations(int index) const {
  return _impl_.stations_.Get(index);
}
inline const ::camel::api::GrpcTaskStation& GrpcTaskAllocation::stations(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskAllocation.stations)
  return _internal_stations(index);
}
inline ::camel::api::GrpcTaskStation* GrpcTaskAllocation::_internal_add_stations() {
  return _impl_.stations_.Add();
}
inline ::camel::api::GrpcTaskStation* GrpcTaskAllocation::add_stations() {
  ::camel::api::GrpcTaskStation* _add = _internal_add_stations();
  // @@protoc_insertion_point(field_add:camel.api.GrpcTaskAllocation.stations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskStation >&
GrpcTaskAllocation::stations() const {
  // @@protoc_insertion_point(field_list:camel.api.GrpcTaskAllocation.stations)
  return _impl_.stations_;
}

// bool circle = 4;
inline void GrpcTaskAllocation::clear_circle() {
  _impl_.circle_ = false;
}
inline bool GrpcTaskAllocation::_internal_circle() const {
  return _impl_.circle_;
}
inline bool GrpcTaskAllocation::circle() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskAllocation.circle)
  return _internal_circle();
}
inline void GrpcTaskAllocation::_internal_set_circle(bool value) {
  
  _impl_.circle_ = value;
}
inline void GrpcTaskAllocation::set_circle(bool value) {
  _internal_set_circle(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskAllocation.circle)
}

// -------------------------------------------------------------------

// GrpcTaskOperation

// .camel.api.GrpcTaskAllocation task = 1;
inline bool GrpcTaskOperation::_internal_has_task() const {
  return this != internal_default_instance() && _impl_.task_ != nullptr;
}
inline bool GrpcTaskOperation::has_task() const {
  return _internal_has_task();
}
inline void GrpcTaskOperation::clear_task() {
  if (GetArenaForAllocation() == nullptr && _impl_.task_ != nullptr) {
    delete _impl_.task_;
  }
  _impl_.task_ = nullptr;
}
inline const ::camel::api::GrpcTaskAllocation& GrpcTaskOperation::_internal_task() const {
  const ::camel::api::GrpcTaskAllocation* p = _impl_.task_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::GrpcTaskAllocation&>(
      ::camel::api::_GrpcTaskAllocation_default_instance_);
}
inline const ::camel::api::GrpcTaskAllocation& GrpcTaskOperation::task() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskOperation.task)
  return _internal_task();
}
inline void GrpcTaskOperation::unsafe_arena_set_allocated_task(
    ::camel::api::GrpcTaskAllocation* task) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.task_);
  }
  _impl_.task_ = task;
  if (task) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.GrpcTaskOperation.task)
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskOperation::release_task() {
  
  ::camel::api::GrpcTaskAllocation* temp = _impl_.task_;
  _impl_.task_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskOperation::unsafe_arena_release_task() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskOperation.task)
  
  ::camel::api::GrpcTaskAllocation* temp = _impl_.task_;
  _impl_.task_ = nullptr;
  return temp;
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskOperation::_internal_mutable_task() {
  
  if (_impl_.task_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::GrpcTaskAllocation>(GetArenaForAllocation());
    _impl_.task_ = p;
  }
  return _impl_.task_;
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskOperation::mutable_task() {
  ::camel::api::GrpcTaskAllocation* _msg = _internal_mutable_task();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskOperation.task)
  return _msg;
}
inline void GrpcTaskOperation::set_allocated_task(::camel::api::GrpcTaskAllocation* task) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.task_;
  }
  if (task) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(task);
    if (message_arena != submessage_arena) {
      task = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, task, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.task_ = task;
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskOperation.task)
}

// .camel.api.GrpcTaskOperation.Operation opt = 2;
inline void GrpcTaskOperation::clear_opt() {
  _impl_.opt_ = 0;
}
inline ::camel::api::GrpcTaskOperation_Operation GrpcTaskOperation::_internal_opt() const {
  return static_cast< ::camel::api::GrpcTaskOperation_Operation >(_impl_.opt_);
}
inline ::camel::api::GrpcTaskOperation_Operation GrpcTaskOperation::opt() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskOperation.opt)
  return _internal_opt();
}
inline void GrpcTaskOperation::_internal_set_opt(::camel::api::GrpcTaskOperation_Operation value) {
  
  _impl_.opt_ = value;
}
inline void GrpcTaskOperation::set_opt(::camel::api::GrpcTaskOperation_Operation value) {
  _internal_set_opt(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskOperation.opt)
}

// -------------------------------------------------------------------

// GrpcTaskAllocations

// repeated .camel.api.GrpcTaskAllocation tasks = 1;
inline int GrpcTaskAllocations::_internal_tasks_size() const {
  return _impl_.tasks_.size();
}
inline int GrpcTaskAllocations::tasks_size() const {
  return _internal_tasks_size();
}
inline void GrpcTaskAllocations::clear_tasks() {
  _impl_.tasks_.Clear();
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskAllocations::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskAllocations.tasks)
  return _impl_.tasks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskAllocation >*
GrpcTaskAllocations::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:camel.api.GrpcTaskAllocations.tasks)
  return &_impl_.tasks_;
}
inline const ::camel::api::GrpcTaskAllocation& GrpcTaskAllocations::_internal_tasks(int index) const {
  return _impl_.tasks_.Get(index);
}
inline const ::camel::api::GrpcTaskAllocation& GrpcTaskAllocations::tasks(int index) const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskAllocations.tasks)
  return _internal_tasks(index);
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskAllocations::_internal_add_tasks() {
  return _impl_.tasks_.Add();
}
inline ::camel::api::GrpcTaskAllocation* GrpcTaskAllocations::add_tasks() {
  ::camel::api::GrpcTaskAllocation* _add = _internal_add_tasks();
  // @@protoc_insertion_point(field_add:camel.api.GrpcTaskAllocations.tasks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::camel::api::GrpcTaskAllocation >&
GrpcTaskAllocations::tasks() const {
  // @@protoc_insertion_point(field_list:camel.api.GrpcTaskAllocations.tasks)
  return _impl_.tasks_;
}

// -------------------------------------------------------------------

// GrpcTaskInfomation

// bool hasTask = 1;
inline void GrpcTaskInfomation::clear_hastask() {
  _impl_.hastask_ = false;
}
inline bool GrpcTaskInfomation::_internal_hastask() const {
  return _impl_.hastask_;
}
inline bool GrpcTaskInfomation::hastask() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskInfomation.hasTask)
  return _internal_hastask();
}
inline void GrpcTaskInfomation::_internal_set_hastask(bool value) {
  
  _impl_.hastask_ = value;
}
inline void GrpcTaskInfomation::set_hastask(bool value) {
  _internal_set_hastask(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskInfomation.hasTask)
}

// string description = 2;
inline void GrpcTaskInfomation::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& GrpcTaskInfomation::description() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskInfomation.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GrpcTaskInfomation::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskInfomation.description)
}
inline std::string* GrpcTaskInfomation::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskInfomation.description)
  return _s;
}
inline const std::string& GrpcTaskInfomation::_internal_description() const {
  return _impl_.description_.Get();
}
inline void GrpcTaskInfomation::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* GrpcTaskInfomation::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* GrpcTaskInfomation::release_description() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskInfomation.description)
  return _impl_.description_.Release();
}
inline void GrpcTaskInfomation::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskInfomation.description)
}

// .camel.api.GrpcTaskStation target = 3;
inline bool GrpcTaskInfomation::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool GrpcTaskInfomation::has_target() const {
  return _internal_has_target();
}
inline void GrpcTaskInfomation::clear_target() {
  if (GetArenaForAllocation() == nullptr && _impl_.target_ != nullptr) {
    delete _impl_.target_;
  }
  _impl_.target_ = nullptr;
}
inline const ::camel::api::GrpcTaskStation& GrpcTaskInfomation::_internal_target() const {
  const ::camel::api::GrpcTaskStation* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::camel::api::GrpcTaskStation&>(
      ::camel::api::_GrpcTaskStation_default_instance_);
}
inline const ::camel::api::GrpcTaskStation& GrpcTaskInfomation::target() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskInfomation.target)
  return _internal_target();
}
inline void GrpcTaskInfomation::unsafe_arena_set_allocated_target(
    ::camel::api::GrpcTaskStation* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:camel.api.GrpcTaskInfomation.target)
}
inline ::camel::api::GrpcTaskStation* GrpcTaskInfomation::release_target() {
  
  ::camel::api::GrpcTaskStation* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::camel::api::GrpcTaskStation* GrpcTaskInfomation::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:camel.api.GrpcTaskInfomation.target)
  
  ::camel::api::GrpcTaskStation* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::camel::api::GrpcTaskStation* GrpcTaskInfomation::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::camel::api::GrpcTaskStation>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::camel::api::GrpcTaskStation* GrpcTaskInfomation::mutable_target() {
  ::camel::api::GrpcTaskStation* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:camel.api.GrpcTaskInfomation.target)
  return _msg;
}
inline void GrpcTaskInfomation::set_allocated_target(::camel::api::GrpcTaskStation* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:camel.api.GrpcTaskInfomation.target)
}

// bool circle = 4;
inline void GrpcTaskInfomation::clear_circle() {
  _impl_.circle_ = false;
}
inline bool GrpcTaskInfomation::_internal_circle() const {
  return _impl_.circle_;
}
inline bool GrpcTaskInfomation::circle() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskInfomation.circle)
  return _internal_circle();
}
inline void GrpcTaskInfomation::_internal_set_circle(bool value) {
  
  _impl_.circle_ = value;
}
inline void GrpcTaskInfomation::set_circle(bool value) {
  _internal_set_circle(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskInfomation.circle)
}

// bool multicar = 5;
inline void GrpcTaskInfomation::clear_multicar() {
  _impl_.multicar_ = false;
}
inline bool GrpcTaskInfomation::_internal_multicar() const {
  return _impl_.multicar_;
}
inline bool GrpcTaskInfomation::multicar() const {
  // @@protoc_insertion_point(field_get:camel.api.GrpcTaskInfomation.multicar)
  return _internal_multicar();
}
inline void GrpcTaskInfomation::_internal_set_multicar(bool value) {
  
  _impl_.multicar_ = value;
}
inline void GrpcTaskInfomation::set_multicar(bool value) {
  _internal_set_multicar(value);
  // @@protoc_insertion_point(field_set:camel.api.GrpcTaskInfomation.multicar)
}

// -------------------------------------------------------------------

// Collaborative

// .camel.api.Collaborative.CooperationEnum cooperation = 1;
inline void Collaborative::clear_cooperation() {
  _impl_.cooperation_ = 0;
}
inline ::camel::api::Collaborative_CooperationEnum Collaborative::_internal_cooperation() const {
  return static_cast< ::camel::api::Collaborative_CooperationEnum >(_impl_.cooperation_);
}
inline ::camel::api::Collaborative_CooperationEnum Collaborative::cooperation() const {
  // @@protoc_insertion_point(field_get:camel.api.Collaborative.cooperation)
  return _internal_cooperation();
}
inline void Collaborative::_internal_set_cooperation(::camel::api::Collaborative_CooperationEnum value) {
  
  _impl_.cooperation_ = value;
}
inline void Collaborative::set_cooperation(::camel::api::Collaborative_CooperationEnum value) {
  _internal_set_cooperation(value);
  // @@protoc_insertion_point(field_set:camel.api.Collaborative.cooperation)
}

// string headCarIp = 2;
inline void Collaborative::clear_headcarip() {
  _impl_.headcarip_.ClearToEmpty();
}
inline const std::string& Collaborative::headcarip() const {
  // @@protoc_insertion_point(field_get:camel.api.Collaborative.headCarIp)
  return _internal_headcarip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collaborative::set_headcarip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.headcarip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.Collaborative.headCarIp)
}
inline std::string* Collaborative::mutable_headcarip() {
  std::string* _s = _internal_mutable_headcarip();
  // @@protoc_insertion_point(field_mutable:camel.api.Collaborative.headCarIp)
  return _s;
}
inline const std::string& Collaborative::_internal_headcarip() const {
  return _impl_.headcarip_.Get();
}
inline void Collaborative::_internal_set_headcarip(const std::string& value) {
  
  _impl_.headcarip_.Set(value, GetArenaForAllocation());
}
inline std::string* Collaborative::_internal_mutable_headcarip() {
  
  return _impl_.headcarip_.Mutable(GetArenaForAllocation());
}
inline std::string* Collaborative::release_headcarip() {
  // @@protoc_insertion_point(field_release:camel.api.Collaborative.headCarIp)
  return _impl_.headcarip_.Release();
}
inline void Collaborative::set_allocated_headcarip(std::string* headcarip) {
  if (headcarip != nullptr) {
    
  } else {
    
  }
  _impl_.headcarip_.SetAllocated(headcarip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.headcarip_.IsDefault()) {
    _impl_.headcarip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.Collaborative.headCarIp)
}

// string rearCarIp = 3;
inline void Collaborative::clear_rearcarip() {
  _impl_.rearcarip_.ClearToEmpty();
}
inline const std::string& Collaborative::rearcarip() const {
  // @@protoc_insertion_point(field_get:camel.api.Collaborative.rearCarIp)
  return _internal_rearcarip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collaborative::set_rearcarip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.rearcarip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:camel.api.Collaborative.rearCarIp)
}
inline std::string* Collaborative::mutable_rearcarip() {
  std::string* _s = _internal_mutable_rearcarip();
  // @@protoc_insertion_point(field_mutable:camel.api.Collaborative.rearCarIp)
  return _s;
}
inline const std::string& Collaborative::_internal_rearcarip() const {
  return _impl_.rearcarip_.Get();
}
inline void Collaborative::_internal_set_rearcarip(const std::string& value) {
  
  _impl_.rearcarip_.Set(value, GetArenaForAllocation());
}
inline std::string* Collaborative::_internal_mutable_rearcarip() {
  
  return _impl_.rearcarip_.Mutable(GetArenaForAllocation());
}
inline std::string* Collaborative::release_rearcarip() {
  // @@protoc_insertion_point(field_release:camel.api.Collaborative.rearCarIp)
  return _impl_.rearcarip_.Release();
}
inline void Collaborative::set_allocated_rearcarip(std::string* rearcarip) {
  if (rearcarip != nullptr) {
    
  } else {
    
  }
  _impl_.rearcarip_.SetAllocated(rearcarip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.rearcarip_.IsDefault()) {
    _impl_.rearcarip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:camel.api.Collaborative.rearCarIp)
}

// bool isMaster = 4;
inline void Collaborative::clear_ismaster() {
  _impl_.ismaster_ = false;
}
inline bool Collaborative::_internal_ismaster() const {
  return _impl_.ismaster_;
}
inline bool Collaborative::ismaster() const {
  // @@protoc_insertion_point(field_get:camel.api.Collaborative.isMaster)
  return _internal_ismaster();
}
inline void Collaborative::_internal_set_ismaster(bool value) {
  
  _impl_.ismaster_ = value;
}
inline void Collaborative::set_ismaster(bool value) {
  _internal_set_ismaster(value);
  // @@protoc_insertion_point(field_set:camel.api.Collaborative.isMaster)
}

// -------------------------------------------------------------------

// CollaborativeResult

// .camel.api.CollaborativeResult.Status result = 1;
inline void CollaborativeResult::clear_result() {
  _impl_.result_ = 0;
}
inline ::camel::api::CollaborativeResult_Status CollaborativeResult::_internal_result() const {
  return static_cast< ::camel::api::CollaborativeResult_Status >(_impl_.result_);
}
inline ::camel::api::CollaborativeResult_Status CollaborativeResult::result() const {
  // @@protoc_insertion_point(field_get:camel.api.CollaborativeResult.result)
  return _internal_result();
}
inline void CollaborativeResult::_internal_set_result(::camel::api::CollaborativeResult_Status value) {
  
  _impl_.result_ = value;
}
inline void CollaborativeResult::set_result(::camel::api::CollaborativeResult_Status value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:camel.api.CollaborativeResult.result)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api
}  // namespace camel

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::camel::api::Battery_ChargingState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::Battery_ChargingState>() {
  return ::camel::api::Battery_ChargingState_descriptor();
}
template <> struct is_proto_enum< ::camel::api::GrpcTaskStation_TaskAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::GrpcTaskStation_TaskAction>() {
  return ::camel::api::GrpcTaskStation_TaskAction_descriptor();
}
template <> struct is_proto_enum< ::camel::api::GrpcTaskOperation_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::GrpcTaskOperation_Operation>() {
  return ::camel::api::GrpcTaskOperation_Operation_descriptor();
}
template <> struct is_proto_enum< ::camel::api::Collaborative_CooperationEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::Collaborative_CooperationEnum>() {
  return ::camel::api::Collaborative_CooperationEnum_descriptor();
}
template <> struct is_proto_enum< ::camel::api::CollaborativeResult_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::CollaborativeResult_Status>() {
  return ::camel::api::CollaborativeResult_Status_descriptor();
}
template <> struct is_proto_enum< ::camel::api::DoAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::DoAction>() {
  return ::camel::api::DoAction_descriptor();
}
template <> struct is_proto_enum< ::camel::api::AgvsTaskStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::camel::api::AgvsTaskStatus>() {
  return ::camel::api::AgvsTaskStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_camel_2dcommon_2eproto
