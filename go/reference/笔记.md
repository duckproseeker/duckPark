### c++一些语法知识

1.final关键字表示该类不能再被继承。

2.将各种类型转换为string类型：std::to_string(T);

**3.new与make_shared的区别:**

首先都是在堆上申请内存
先new然后赋值的方式，会导致内存]碎片化
make_shared的方法分配内存，不会导致内存产生过多的碎片

```C++
   A* a = new A;                                       //①
   std::shared_ptr<A> pa(a);
 
   std::shared_ptr<A> pa1 = std::make_shared<A>(1);              //②
```

4.**智能指针对象本身内存在栈上，内部有一个指针指向堆上的对象，随着程序回收栈空间对堆空间的对象进行析构。**

**5.父类与子类的（智能）指针或引用相互转换**

子类--->父类：向上转换，可<u>隐式转换</u>。
父类--->子类：向下转换，需要<u>dynamic_cast</u>进行强制转换。

**6. c++11显示时间：std::chrono**

> https://blog.csdn.net/t46414704152abc/article/details/103531447

**7.std::regex的相关知识点**

> https://blog.csdn.net/weixin_43919932/article/details/123947174?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-123947174-blog-78235307.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-123947174-blog-78235307.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=7

8.std::tuple常用于函数的多返回值。

9.explicit关键字：指定构造函数或转换函数 (C++11起)为显式, 即它不能用于隐式转换和复制初始化。

10.std::string fmt::format(const S& format_str, Args&&... args)将字符串标准化。

11.std::enable_shared_from_this学习

> 因为**智能共享指针不能够直接从this对象进行构造**，enable_shared_from_this从本质上来说解决了不能直接冲this对象构造智能指针的问题、
>
> 用法：https://cloud.tencent.com/developer/article/2015917

12.结构体内存对齐

13.十进制，八进制，十六进制输出

```C++
int n = 10;
std::cout << std::dec << n <<std::endl; //十进制
std::cout << std::hex << n <<std::endl; //十六进制
std::cout << std::oct << n <<std::endl; //八进制
```

14.map, unorder_map的insert()函数插入重复元素时，不会覆盖，会插入失败。

15.**对于有虚拟函数的类对象，决不能使用memset来进行初始化操作**

**用memset初始化obj的时候，会将obj包含的指向虚函数表VTBL的指针也清除，调用obj的虚函数，程序会崩溃。**



### Linux知识点

##### Linux 中的某些重要的目录：

> •主目录：/root、/home/username
>
> •用户可执行文件：/bin、/usr/bin、/usr/local/bin
>
> •系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin
>
> •其他挂载点：/media、/mnt
>
> •配置：/etc
>
> •临时文件：/tmp
>
> •内核和Bootloader：/boot
>
> •服务器数据：/var、/srv
>
> •系统信息：/proc、/sys
>
> •共享库：/lib、/usr/lib、/usr/local/lib



##### Linux指令

> lsof -i:8848  查看端口使用情况
> netstat -tunlp 查看端口占用情况
> nc -zvw3 [ip] [port] 查看端口是否被墙
>
> 创建软连接：ln -s <源文件或目录>  <目标文件或目录>
> 查看所有软连接：ls -il
>
> 将可执行程序安装到全局变量下：expot PATH=<path>:$PATH  --关闭终端失效
> 查看全局变量：export
>
> 每次更新配置需要刷新缓存：sudo /sbin/ldconfig
>
> source命令刷新当前shell环境：source ~/.bashrc
>
> 虚拟机添加新用户：sudo adduser <NewUser>
>
> 查看可执行程序需要的链接库： ldd 
>
> Linux抓包 ： tcpdump -i ens33 -n  port 55555 and host 10.193.12.12 -c 10 -w package.cap



linux配置网络

配置文件写入 /etc/network/interface

```
auto wlan0
iface wlan0 inet static
address 14.18.80.30
netmask 255.255.0.0
gateway 192.168.2.1
wpa_conf /etc/wpa_supplicant/wifi.conf

auto wlan0
iface wlan0 inet static
address 192.168.2.220
netmask 255.255.255.0
```

终端配置

```
ip addr add/del (新增ip)/24 dev eth0/wlan0    增加/删除ip
route add/del default gw (网关地址) eth0/wlan0     增加/删除网关
```



压缩文件

```shell
解压：tar zxvf FileName.tar.gz
压缩：tar zcvf FileName.tar.gz DirName
```





##### error while loading shared libraries的解決方法

在/etc/ld.so.conf中加入/usr/local/lib这一行，保存之后，再运行：/sbin/ldconfig –v更新一下配置即可



##### curl的用法

> https://www.ruanyifeng.com/blog/2019/09/curl-reference.html



### golang知识点



##### go的卸载与安装

> https://blog.csdn.net/qq_36389107/article/details/107972274

go插件安装

```
go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest
go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@latest
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

设置go代理

```
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.cn,direct
```





### protobuf相关

##### protoc版本不一致问题

- 先find / -name protoc

- 查看/usr/bin和/usr/local/bin下的脚本命令，用ll /path/protoc查看
- 可以用的时候指定路径   /usr/local/bin/protoc ......
- 也可以用新的覆盖旧的版本



##### protoc编译的语法

​	protoc (-I=path) --cpp_out=OUT_DIR DsetPath/*.proto

grpc插件下的编译
	protoc --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` *.proto

grpc-gateway插件下的编译
	protoc --grpc-gateway_out=. *.proto



##### protobuf参考手册

> https://developers.google.com/protocol-buffers/docs/reference/cpp-generated



### Git bash的使用

使用教程：https://blog.csdn.net/qq_36667170/article/details/79085301

设置用户：git config --global user.name "kavin"
设置邮箱：git config --global user.email "76820965@qq.com"

初始化本地仓库：git init
建立连接：https://blog.csdn.net/qq_36667170/article/details/79094257
本地仓库打开gitbash：git remote add origin git@github.com:duckproseeker/duckPark.git
查看连接的仓库：git remote -v
git取消与远程仓库的连接：git remote remove origin

###### 文件上传

暂存到缓冲区：git add -A
将缓存区的文件实际保存到仓库的历史记录中；git commit -m "message"
文件推到远程仓库：git push -u origin master
查看日志：git log

###### 文件下拉

>1. git pull origin
>2. git fetch + git merge
>
>note：pull前先git add -A, git commmit,将代码存储到本地仓库。

###### 文件克隆

> git clone 仓库名

#### Git bash常用指令

```
vim hello.txt 表示在文件夹中新建一个hello.txt文件
cat hello.txt 表示在窗口中查看hello.txt文件
git init 表示初始化本地库
git clone xxx 'xxx’表示需要克隆的仓库的链接
git status 查看当前状态
git add 文件名表示将某个文件添加至暂存区
git add . 表示将所有(进行修改的)文件添加至暂存区
git commit -m “xxx” xxx表示自己对本次提交所进行的备注或者标注
git push origin master 表示实现由本地库向远程仓库的推送
git pull origin master 表示将远程仓库的内容文件同步更新拉取到本地库
git reset --hard xxxxxxx 'xxxxxxx’表示不同版本的版本编号,这个指令代表将本地库切换至指定版本
git branch 表示查看所有分支(当前分支前会有*号)
git branch 分支名 表示创建一个新的分支
git checkout 分支名 表示切换至指定分支
git push origin 分支名:分支名 表示在远程仓库创建一个分支，并把本地库的此分支提交至该创建的分支上
在输入状态下，按Esc可以退出编辑模式
退出输入状态后，yy 表示复制当前行。p 表示粘贴。:wq 表示退出编辑并保存
tail -n 1 hello.txt 表示查看hello.txt文件的最后一行内容
git rm --cached hello.txt 表示将hello.txt文件从缓存区删除，但是工作区的文件还在
git reflog 表示查看提交日志的简单化信息
ctrl+L表示清空代码 cd 文件夹名 表示进入该文件夹 cd . . 表示退出当前文件夹
git pull --rebase origin master 将远程仓库修改的文件更新到本地
git push -f origin master 表示强行将本地库的内容推送到远程库。并且覆盖掉远程库的内容
ssh-keygen 表示在本地生成ssh密钥，是可以在gitee和GitHub通用的密钥
git branch -D 分支名表示删除本地分支。删除之前要切换到其他分支
git branch -r 表示查看远程分支
git push origin --delete 分支名表示删除远程分支
git pull origin master --allow-unrelated-histories允许不相关历史提交，强制合并
```



### ASIO的使用

https://zhuanlan.zhihu.com/p/179070263

asio::buffer的使用

>https://www.cnblogs.com/walker-lc/articles/3571760.html
>
>https://www.jianshu.com/p/c33e7265acd8



### sqlite3的基本语法

1、创建数据库

```sqlite
sqlite3 DatabaseName.db   --未进入sqlite使用
sqlite>.open userDB.db    --已进入时，不存在则新建
```

2、退出数据库

```sqlite
sqlite>.quit
```

3、导出完整的数据库在一个文本文件中

```sqlite
sqlite3 userDB.db .dump > userDB.sql --导入文本
sqlite3 userDB.db < userDB.sql       --从文本恢复
```

4、查看某个表的所有数据

```C++
sqlite3 local.db
.mode column
.headers on
.tables
select * from tableName;
```





### POCO第三方库

##### Util读取配置文件

> https://blog.51cto.com/qtlinux/1701956





### ODB的编译运行

##### odb访问mysql数据库

> https://blog.csdn.net/woaichanganba/article/details/79841356

##### odb编译运行sqlite的shell指令

>1. odb -d sqlite --generate-query --generate-schema persion.hxx 
>2. c++ -c driver.cxx 
>3. c++ -c persion-odb.cxx
>4. c++ -o main *.o -lodb-sqlite -lodb



### ROS

基础讲解：
https://juejin.cn/post/6844904053420343310

ros update出现问题:
https://blog.csdn.net/qq_44938606/article/details/120968180

##### 1.创建catkin工作区间

```c++
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/
catkin_make
```

##### 2.设置脚本，配置环境

```C++
1.source devel/setup.bash  --暂时
2.echo $ROS_PACKAGE_PATH
/home/duck/path/catkin_ws/src:/opt/ros/kinetic/share  --持久
```

##### 3.创建catkin包

```c++
cd ~/catkin_ws/src
catkin_create_pkg <package_name> [depend1] [depend2] [depend3]
（example）：catkin_create_pkg beginner_tutorials std_msgs rospy roscpp
```

##### 4.运行ros

```C++
roscore
//显示活动节点
rosnode list
//显示节点信息
resnode info /rosout
```

##### 5.使用rosrun运行程序

```C++
rosrun [package_name] [node_name]
(examplerosrun turtlesim turtlesim_node <__name:=my_turtle>
 //测试rosnode是否启动
rosnode ping my_turtle
```

##### 6.使用rqt_graph查看动态

```C++
rosrun rqt_graph rqt_graph
//查看话题的发布与订阅
rostopic list -v
//查看话题类型
rostopic type [topic]
//查看消息的细节
rosmsg show [message]
//同时查看话题类型和消息细节
rostopic type [topic] | rosmsg show
```

##### 7.使用rostopic pub发布数据

```C++
//以2.0线速度，1.8角速度移动
rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'
//以一定频率发布数据
rostopic pub  /turtle1/cmd_vel geometry_msgs/Twist -r nums -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'
//查看数据发布频率
rostopic hz [topic]
```

##### 8.使用rqt_plot显示数据发布时间图

```c++
rosrun rqt_plot rqt_plot
```

##### 9.使用rosservice

```C++
rosservice list         --print information about active services
rosservice call         --call the service with the provided args
rosservice type         --print service type
rosservice find         --find services by service type
rosservice uri          --print service ROSRPC uri
```

##### 10.使用rosparam

```C++
rosparam set            --set parameter
rosparam get            --get parameter
rosparam load           --load parameters from file
rosparam dump           --dump parameters to file
rosparam delete         --delete parameter
rosparam list           --list parameter names
```

##### 11.使用rqt_console和rqt_logger_level

```C++
rosrun rqt_console rqt_console            --查看日志
rosrun rqt_logger_level rqt_logger_level  --设置日志优先级
//优先级由高到低
Fatal-->Error-->Warn-->Info-->Debug
```

##### 12.使用roslaunch启动文中的节点

```C++
roslaunch [package] [filename.launch]
```



#### 创建ROS的msg和srv

1.创建msg

```C++
roscd beginner_tutorials
mkdir msg
echo "int64 num" > msg/Num.msg
```

2.增加package.xml的依赖

```C++
 <build_depend>message_generation</build_depend>
 <exec_depend>message_runtime</exec_depend>
```

3.修发CMakeLists.txt

```C++
find_package(catkin REQUIRED COMPONENTS
   roscpp
   rospy
   std_msgs
   message_generation
)
catkin_package(
  ...
  CATKIN_DEPENDS message_runtime ...
  ...)
    
//以下取消注释，并修改
add_message_files(
  FILES
  Num.msg
)
generate_messages(
  DEPENDENCIES
  std_msgs
)
```

4.使用rosmsg

```C++
rosmsg show [message type]
```

5.创建srv

```C++
roscd beginner_tutorials
mkdir srv
//(example):roscp rospy_tutorials AddTwoInts.srv srv/AddTwoInts.srv
roscp [package_name] [file_to_copy_path] [copy_path]
```

6.修改CMakeLists.txt

```C++
//取消注释，并修改
add_service_files(
  FILES
  AddTwoInts.srv
)
```

7.使用rossrv

```C++
rossrv show <service type>
```

8.重新make package

```C++
# In your catkin workspace
$ roscd beginner_tutorials
$ cd ../..
$ catkin build
$ cd -    
//if error, 执行sudo apt-get install python3-catkin-tools
//然后删掉build和devel文件夹
```



##### 创建ROS的talker和listener

教程：https://blog.csdn.net/Frank_Zhaoxs/article/details/118881111?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-118881111-blog-105659947.pc_relevant_multi_platform_whitelistv1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-118881111-blog-105659947.pc_relevant_multi_platform_whitelistv1&utm_relevant_index=1



### Log4cpp基础

log4cpp从大的结构上分为日志类别(Category),日志追加器(Appender),日志布局（Layout),日志级别(Priority)。

编译指令：
	g++	*.cpp	-llog4cpp	-lpthread

输出日志的格式

```C++
// %% 输出一个%
 // %c 输出Categroy名称
 // %d 输出日期
 // %m 输出消息
 // %n 输出换行
 // %p 输出Priority
 // %d{%Y-%m-%d %H:%M:%S:%l}对输出日期做定制，年月日时分秒毫秒
 // %t 线程ID
 
 log4cpp::PatternLayout *patternLayout = new log4cpp::PatternLayout();
 patternLayout->setConversionPattern("%d{%Y-%m-%d %H:%M:%S.%l} %t [%p] %m %n");
 appender->setLayout(patternLayout);
```



教程：

> https://www.cnblogs.com/cthon/p/9192787.html



### pkg-config基础

主要指令：

```
pkg-config opencv –libs –cflags //获取链接库及头文件的包含路径
```

详解：https://blog.csdn.net/newchenxf/article/details/51750239



### grpc框架知识点

##### grpc安装

```
sudo apt-get install pkg-config
sudo apt-get install autoconf automake libtool make g++ unzip
sudo apt-get install libgflags-dev libgtest-dev
sudo apt-get install clang libc++-dev
//解压更新好子模块的grpc压缩包
cd grpc
mkdir build
cd build
// 指定安装路径 /usr/local 
cmake -DCMAKE_INSTALL_PREFIX=/usr/local ..
make -j2
sudo make install
```



编译指令：

> g++ test.cpp *.cc -o test -L/usr/local/lib `pkg-config --libs protobuf grpc++` -pthread -ldl -lgrpc++_reflection



### docker

##### docker安装

> https://www.runoob.com/docker/ubuntu-docker-install.html



##### 运行docker权限不足的解决方案：

```
sudo groupadd docker     #添加docker用户组
sudo gpasswd -a $USER docker     #将登陆用户加入到docker用户组中
newgrp docker     #更新用户组
docker ps    #测试docker命令是否可以使用sudo正常使用
```



### grpc-gataway安装事项

将$GOBINf放入$PATH

```
go env  查看Go的环境变量
export GOBIN=/home/ubuntu/go/bin/
export PATH=/home/ubuntu/go/bin/:$PATH
```



### Buf

buf:一个管理和维护protobuf的插件

##### buf的基本指令

```
buf mod init  //初始化并创建一个buf.yaml文件
buf ls-files  //列出当前目录下所有的protobuf文件
buf generate  //根据buf.gen.yaml文件将protobuf文件生成对应的c++或其他语言的代码
```

