// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: protobuf/camel-grpc.proto

package camel

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AgvServiceClient is the client API for AgvService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgvServiceClient interface {
	//UploadMapData为上传区域数据
	//客户端传入区域数据流
	//服务端传出是否成功
	UploadMapData(ctx context.Context, in *ISeeMap, opts ...grpc.CallOption) (*Result, error)
	//获取当前得版本信息
	//客户端传入空值
	GetVersion(ctx context.Context, in *ISeeMap, opts ...grpc.CallOption) (*Version, error)
	//客户端传入空值
	//服务端传出AGV状态
	GetAgvState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AgvInfo, error)
	//UI向Camel请求配置信息
	RequestUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UIConfig, error)
	//获取系统信息
	GetSystemStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SystemStatus, error)
	//客户端获取AGVS中得信息.
	//服务端返回CamelMessage 其中只有
	GetAgvStateInAgvs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CamelSysInfo, error)
	//客户端传入上位机得CamelMessage 其中只用 RequestToAgvs.
	//返回是否有异常信息
	SendToAgvs(ctx context.Context, in *CamelMessage, opts ...grpc.CallOption) (*Result, error)
	//客户端传入AGV得一些操作.
	//返回是否有异常
	ControlAgv(ctx context.Context, in *Operation, opts ...grpc.CallOption) (*Result, error)
	//设置camel的配置项
	//服务端传出是否成功
	SetCamelCfg(ctx context.Context, in *CamelCfg, opts ...grpc.CallOption) (*Result, error)
	//客户端传空值
	//服务端传出camel的配置信息
	GetCamelCfg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CamelCfg, error)
	//获取Camel中所有的路径
	GetCamelPathCollection(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PathCollection, error)
	// 客户端模拟任务发布
	RoutePlan(ctx context.Context, in *CamelMessage_MissonFromAgvs, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 获取所有节点的配置信息
	GetRosNodeCfg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RosNodesCfg, error)
	// 返回设置单个节点的配置信息
	SetRosNodeCfg(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error)
	// 删除单个节点
	// master节点不允许删除
	DeleteNodeCfg(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error)
	// 停止单个节点
	StopRosnode(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error)
	// 获取rosout输出的所有信息，保存一百条
	GetRosoutMsg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RosoutMsg, error)
	// 设置避障区域
	SetAvoidanceArea(ctx context.Context, in *AvoidanceAreaCollection, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 上报报警给Camel
	// cleared: true(清除)/false(新增)
	AlarmUpload(ctx context.Context, in *AlarmMsg, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 查询网络信息
	QueryNetworkInformation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NetworkConfigCollection, error)
	// 设置网络
	SetNetworkInformation(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 搜索WIFI列表
	SearchWLANList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WLANList, error)
	// 连接WIFI
	ConnectWLAN(ctx context.Context, in *WirlessConfig, opts ...grpc.CallOption) (*Result, error)
	// 日志导出
	LogExport(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error)
	// 软件升级（Result: Code -> 0 成功, Message-> 非零时的错误消息）
	// 若成功则会在5s后重启电脑！！！
	SoftwareUpgrade(ctx context.Context, in *InstallPack, opts ...grpc.CallOption) (*Result, error)
	// 软件备份
	SoftwareBackup(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error)
	// 软件还原
	SoftwareRollback(ctx context.Context, in *InstallPack, opts ...grpc.CallOption) (*Result, error)
	// 版本回退（Result: Code -> 0 成功, Message-> 非零时的错误消息）
	// 若成功则会在5s后重启电脑！！！
	SoftwareDowngrade(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error)
	// 模拟手柄控制小车
	StickControl(ctx context.Context, in *Gamepad, opts ...grpc.CallOption) (*Result, error)
	// 申请手柄控制
	ApplyStickControl(ctx context.Context, in *GamepadControl, opts ...grpc.CallOption) (*Token, error)
	// 设置匹配点
	ModifyMatchPoint(ctx context.Context, in *MatchPointCommand, opts ...grpc.CallOption) (*Result, error)
	// 获取匹配点
	GetMatchPoint(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MatchPoints, error)
	// 重启小车
	CarRestart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// 更新站点坐标
	UpdateStationPose(ctx context.Context, in *UpdateStation, opts ...grpc.CallOption) (*UpdatePose, error)
	// 任务点配置
	TaskAllocationOperation(ctx context.Context, in *GrpcTaskOperation, opts ...grpc.CallOption) (*GrpcTaskAllocations, error)
	// 重置任务列表
	AssignAllocationTasks(ctx context.Context, in *GrpcTaskAllocations, opts ...grpc.CallOption) (*Result, error)
}

type agvServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgvServiceClient(cc grpc.ClientConnInterface) AgvServiceClient {
	return &agvServiceClient{cc}
}

func (c *agvServiceClient) UploadMapData(ctx context.Context, in *ISeeMap, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/UploadMapData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetVersion(ctx context.Context, in *ISeeMap, opts ...grpc.CallOption) (*Version, error) {
	out := new(Version)
	err := c.cc.Invoke(ctx, "/AgvService/GetVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetAgvState(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AgvInfo, error) {
	out := new(AgvInfo)
	err := c.cc.Invoke(ctx, "/AgvService/GetAgvState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) RequestUIConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*UIConfig, error) {
	out := new(UIConfig)
	err := c.cc.Invoke(ctx, "/AgvService/RequestUIConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetSystemStatus(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*SystemStatus, error) {
	out := new(SystemStatus)
	err := c.cc.Invoke(ctx, "/AgvService/GetSystemStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetAgvStateInAgvs(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CamelSysInfo, error) {
	out := new(CamelSysInfo)
	err := c.cc.Invoke(ctx, "/AgvService/GetAgvStateInAgvs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SendToAgvs(ctx context.Context, in *CamelMessage, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SendToAgvs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) ControlAgv(ctx context.Context, in *Operation, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/ControlAgv", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SetCamelCfg(ctx context.Context, in *CamelCfg, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SetCamelCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetCamelCfg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*CamelCfg, error) {
	out := new(CamelCfg)
	err := c.cc.Invoke(ctx, "/AgvService/GetCamelCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetCamelPathCollection(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PathCollection, error) {
	out := new(PathCollection)
	err := c.cc.Invoke(ctx, "/AgvService/GetCamelPathCollection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) RoutePlan(ctx context.Context, in *CamelMessage_MissonFromAgvs, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/AgvService/RoutePlan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetRosNodeCfg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RosNodesCfg, error) {
	out := new(RosNodesCfg)
	err := c.cc.Invoke(ctx, "/AgvService/GetRosNodeCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SetRosNodeCfg(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SetRosNodeCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) DeleteNodeCfg(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/DeleteNodeCfg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) StopRosnode(ctx context.Context, in *RosNode, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/StopRosnode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetRosoutMsg(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*RosoutMsg, error) {
	out := new(RosoutMsg)
	err := c.cc.Invoke(ctx, "/AgvService/GetRosoutMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SetAvoidanceArea(ctx context.Context, in *AvoidanceAreaCollection, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/AgvService/SetAvoidanceArea", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) AlarmUpload(ctx context.Context, in *AlarmMsg, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/AgvService/AlarmUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) QueryNetworkInformation(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*NetworkConfigCollection, error) {
	out := new(NetworkConfigCollection)
	err := c.cc.Invoke(ctx, "/AgvService/QueryNetworkInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SetNetworkInformation(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/AgvService/SetNetworkInformation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SearchWLANList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WLANList, error) {
	out := new(WLANList)
	err := c.cc.Invoke(ctx, "/AgvService/SearchWLANList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) ConnectWLAN(ctx context.Context, in *WirlessConfig, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/ConnectWLAN", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) LogExport(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (*LogResponse, error) {
	out := new(LogResponse)
	err := c.cc.Invoke(ctx, "/AgvService/LogExport", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SoftwareUpgrade(ctx context.Context, in *InstallPack, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SoftwareUpgrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SoftwareBackup(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SoftwareBackup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SoftwareRollback(ctx context.Context, in *InstallPack, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SoftwareRollback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) SoftwareDowngrade(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/SoftwareDowngrade", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) StickControl(ctx context.Context, in *Gamepad, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/StickControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) ApplyStickControl(ctx context.Context, in *GamepadControl, opts ...grpc.CallOption) (*Token, error) {
	out := new(Token)
	err := c.cc.Invoke(ctx, "/AgvService/ApplyStickControl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) ModifyMatchPoint(ctx context.Context, in *MatchPointCommand, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/ModifyMatchPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) GetMatchPoint(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MatchPoints, error) {
	out := new(MatchPoints)
	err := c.cc.Invoke(ctx, "/AgvService/GetMatchPoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) CarRestart(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/AgvService/CarRestart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) UpdateStationPose(ctx context.Context, in *UpdateStation, opts ...grpc.CallOption) (*UpdatePose, error) {
	out := new(UpdatePose)
	err := c.cc.Invoke(ctx, "/AgvService/UpdateStationPose", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) TaskAllocationOperation(ctx context.Context, in *GrpcTaskOperation, opts ...grpc.CallOption) (*GrpcTaskAllocations, error) {
	out := new(GrpcTaskAllocations)
	err := c.cc.Invoke(ctx, "/AgvService/TaskAllocationOperation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agvServiceClient) AssignAllocationTasks(ctx context.Context, in *GrpcTaskAllocations, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/AgvService/AssignAllocationTasks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgvServiceServer is the server API for AgvService service.
// All implementations must embed UnimplementedAgvServiceServer
// for forward compatibility
type AgvServiceServer interface {
	//UploadMapData为上传区域数据
	//客户端传入区域数据流
	//服务端传出是否成功
	UploadMapData(context.Context, *ISeeMap) (*Result, error)
	//获取当前得版本信息
	//客户端传入空值
	GetVersion(context.Context, *ISeeMap) (*Version, error)
	//客户端传入空值
	//服务端传出AGV状态
	GetAgvState(context.Context, *emptypb.Empty) (*AgvInfo, error)
	//UI向Camel请求配置信息
	RequestUIConfig(context.Context, *emptypb.Empty) (*UIConfig, error)
	//获取系统信息
	GetSystemStatus(context.Context, *emptypb.Empty) (*SystemStatus, error)
	//客户端获取AGVS中得信息.
	//服务端返回CamelMessage 其中只有
	GetAgvStateInAgvs(context.Context, *emptypb.Empty) (*CamelSysInfo, error)
	//客户端传入上位机得CamelMessage 其中只用 RequestToAgvs.
	//返回是否有异常信息
	SendToAgvs(context.Context, *CamelMessage) (*Result, error)
	//客户端传入AGV得一些操作.
	//返回是否有异常
	ControlAgv(context.Context, *Operation) (*Result, error)
	//设置camel的配置项
	//服务端传出是否成功
	SetCamelCfg(context.Context, *CamelCfg) (*Result, error)
	//客户端传空值
	//服务端传出camel的配置信息
	GetCamelCfg(context.Context, *emptypb.Empty) (*CamelCfg, error)
	//获取Camel中所有的路径
	GetCamelPathCollection(context.Context, *emptypb.Empty) (*PathCollection, error)
	// 客户端模拟任务发布
	RoutePlan(context.Context, *CamelMessage_MissonFromAgvs) (*emptypb.Empty, error)
	// 获取所有节点的配置信息
	GetRosNodeCfg(context.Context, *emptypb.Empty) (*RosNodesCfg, error)
	// 返回设置单个节点的配置信息
	SetRosNodeCfg(context.Context, *RosNode) (*Result, error)
	// 删除单个节点
	// master节点不允许删除
	DeleteNodeCfg(context.Context, *RosNode) (*Result, error)
	// 停止单个节点
	StopRosnode(context.Context, *RosNode) (*Result, error)
	// 获取rosout输出的所有信息，保存一百条
	GetRosoutMsg(context.Context, *emptypb.Empty) (*RosoutMsg, error)
	// 设置避障区域
	SetAvoidanceArea(context.Context, *AvoidanceAreaCollection) (*emptypb.Empty, error)
	// 上报报警给Camel
	// cleared: true(清除)/false(新增)
	AlarmUpload(context.Context, *AlarmMsg) (*emptypb.Empty, error)
	// 查询网络信息
	QueryNetworkInformation(context.Context, *emptypb.Empty) (*NetworkConfigCollection, error)
	// 设置网络
	SetNetworkInformation(context.Context, *NetworkConfig) (*emptypb.Empty, error)
	// 搜索WIFI列表
	SearchWLANList(context.Context, *emptypb.Empty) (*WLANList, error)
	// 连接WIFI
	ConnectWLAN(context.Context, *WirlessConfig) (*Result, error)
	// 日志导出
	LogExport(context.Context, *LogRequest) (*LogResponse, error)
	// 软件升级（Result: Code -> 0 成功, Message-> 非零时的错误消息）
	// 若成功则会在5s后重启电脑！！！
	SoftwareUpgrade(context.Context, *InstallPack) (*Result, error)
	// 软件备份
	SoftwareBackup(context.Context, *emptypb.Empty) (*Result, error)
	// 软件还原
	SoftwareRollback(context.Context, *InstallPack) (*Result, error)
	// 版本回退（Result: Code -> 0 成功, Message-> 非零时的错误消息）
	// 若成功则会在5s后重启电脑！！！
	SoftwareDowngrade(context.Context, *emptypb.Empty) (*Result, error)
	// 模拟手柄控制小车
	StickControl(context.Context, *Gamepad) (*Result, error)
	// 申请手柄控制
	ApplyStickControl(context.Context, *GamepadControl) (*Token, error)
	// 设置匹配点
	ModifyMatchPoint(context.Context, *MatchPointCommand) (*Result, error)
	// 获取匹配点
	GetMatchPoint(context.Context, *emptypb.Empty) (*MatchPoints, error)
	// 重启小车
	CarRestart(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// 更新站点坐标
	UpdateStationPose(context.Context, *UpdateStation) (*UpdatePose, error)
	// 任务点配置
	TaskAllocationOperation(context.Context, *GrpcTaskOperation) (*GrpcTaskAllocations, error)
	// 重置任务列表
	AssignAllocationTasks(context.Context, *GrpcTaskAllocations) (*Result, error)
	mustEmbedUnimplementedAgvServiceServer()
}

// UnimplementedAgvServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAgvServiceServer struct {
}

func (UnimplementedAgvServiceServer) UploadMapData(context.Context, *ISeeMap) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadMapData not implemented")
}
func (UnimplementedAgvServiceServer) GetVersion(context.Context, *ISeeMap) (*Version, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedAgvServiceServer) GetAgvState(context.Context, *emptypb.Empty) (*AgvInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgvState not implemented")
}
func (UnimplementedAgvServiceServer) RequestUIConfig(context.Context, *emptypb.Empty) (*UIConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestUIConfig not implemented")
}
func (UnimplementedAgvServiceServer) GetSystemStatus(context.Context, *emptypb.Empty) (*SystemStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSystemStatus not implemented")
}
func (UnimplementedAgvServiceServer) GetAgvStateInAgvs(context.Context, *emptypb.Empty) (*CamelSysInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgvStateInAgvs not implemented")
}
func (UnimplementedAgvServiceServer) SendToAgvs(context.Context, *CamelMessage) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendToAgvs not implemented")
}
func (UnimplementedAgvServiceServer) ControlAgv(context.Context, *Operation) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ControlAgv not implemented")
}
func (UnimplementedAgvServiceServer) SetCamelCfg(context.Context, *CamelCfg) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCamelCfg not implemented")
}
func (UnimplementedAgvServiceServer) GetCamelCfg(context.Context, *emptypb.Empty) (*CamelCfg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCamelCfg not implemented")
}
func (UnimplementedAgvServiceServer) GetCamelPathCollection(context.Context, *emptypb.Empty) (*PathCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCamelPathCollection not implemented")
}
func (UnimplementedAgvServiceServer) RoutePlan(context.Context, *CamelMessage_MissonFromAgvs) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoutePlan not implemented")
}
func (UnimplementedAgvServiceServer) GetRosNodeCfg(context.Context, *emptypb.Empty) (*RosNodesCfg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRosNodeCfg not implemented")
}
func (UnimplementedAgvServiceServer) SetRosNodeCfg(context.Context, *RosNode) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRosNodeCfg not implemented")
}
func (UnimplementedAgvServiceServer) DeleteNodeCfg(context.Context, *RosNode) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodeCfg not implemented")
}
func (UnimplementedAgvServiceServer) StopRosnode(context.Context, *RosNode) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopRosnode not implemented")
}
func (UnimplementedAgvServiceServer) GetRosoutMsg(context.Context, *emptypb.Empty) (*RosoutMsg, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRosoutMsg not implemented")
}
func (UnimplementedAgvServiceServer) SetAvoidanceArea(context.Context, *AvoidanceAreaCollection) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAvoidanceArea not implemented")
}
func (UnimplementedAgvServiceServer) AlarmUpload(context.Context, *AlarmMsg) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AlarmUpload not implemented")
}
func (UnimplementedAgvServiceServer) QueryNetworkInformation(context.Context, *emptypb.Empty) (*NetworkConfigCollection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryNetworkInformation not implemented")
}
func (UnimplementedAgvServiceServer) SetNetworkInformation(context.Context, *NetworkConfig) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNetworkInformation not implemented")
}
func (UnimplementedAgvServiceServer) SearchWLANList(context.Context, *emptypb.Empty) (*WLANList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchWLANList not implemented")
}
func (UnimplementedAgvServiceServer) ConnectWLAN(context.Context, *WirlessConfig) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConnectWLAN not implemented")
}
func (UnimplementedAgvServiceServer) LogExport(context.Context, *LogRequest) (*LogResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogExport not implemented")
}
func (UnimplementedAgvServiceServer) SoftwareUpgrade(context.Context, *InstallPack) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftwareUpgrade not implemented")
}
func (UnimplementedAgvServiceServer) SoftwareBackup(context.Context, *emptypb.Empty) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftwareBackup not implemented")
}
func (UnimplementedAgvServiceServer) SoftwareRollback(context.Context, *InstallPack) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftwareRollback not implemented")
}
func (UnimplementedAgvServiceServer) SoftwareDowngrade(context.Context, *emptypb.Empty) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftwareDowngrade not implemented")
}
func (UnimplementedAgvServiceServer) StickControl(context.Context, *Gamepad) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StickControl not implemented")
}
func (UnimplementedAgvServiceServer) ApplyStickControl(context.Context, *GamepadControl) (*Token, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyStickControl not implemented")
}
func (UnimplementedAgvServiceServer) ModifyMatchPoint(context.Context, *MatchPointCommand) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModifyMatchPoint not implemented")
}
func (UnimplementedAgvServiceServer) GetMatchPoint(context.Context, *emptypb.Empty) (*MatchPoints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMatchPoint not implemented")
}
func (UnimplementedAgvServiceServer) CarRestart(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CarRestart not implemented")
}
func (UnimplementedAgvServiceServer) UpdateStationPose(context.Context, *UpdateStation) (*UpdatePose, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateStationPose not implemented")
}
func (UnimplementedAgvServiceServer) TaskAllocationOperation(context.Context, *GrpcTaskOperation) (*GrpcTaskAllocations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TaskAllocationOperation not implemented")
}
func (UnimplementedAgvServiceServer) AssignAllocationTasks(context.Context, *GrpcTaskAllocations) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AssignAllocationTasks not implemented")
}
func (UnimplementedAgvServiceServer) mustEmbedUnimplementedAgvServiceServer() {}

// UnsafeAgvServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgvServiceServer will
// result in compilation errors.
type UnsafeAgvServiceServer interface {
	mustEmbedUnimplementedAgvServiceServer()
}

func RegisterAgvServiceServer(s grpc.ServiceRegistrar, srv AgvServiceServer) {
	s.RegisterService(&AgvService_ServiceDesc, srv)
}

func _AgvService_UploadMapData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ISeeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).UploadMapData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/UploadMapData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).UploadMapData(ctx, req.(*ISeeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ISeeMap)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetVersion(ctx, req.(*ISeeMap))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetAgvState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetAgvState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetAgvState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetAgvState(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_RequestUIConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).RequestUIConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/RequestUIConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).RequestUIConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetSystemStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetSystemStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetSystemStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetSystemStatus(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetAgvStateInAgvs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetAgvStateInAgvs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetAgvStateInAgvs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetAgvStateInAgvs(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SendToAgvs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CamelMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SendToAgvs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SendToAgvs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SendToAgvs(ctx, req.(*CamelMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_ControlAgv_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Operation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).ControlAgv(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/ControlAgv",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).ControlAgv(ctx, req.(*Operation))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SetCamelCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CamelCfg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SetCamelCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SetCamelCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SetCamelCfg(ctx, req.(*CamelCfg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetCamelCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetCamelCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetCamelCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetCamelCfg(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetCamelPathCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetCamelPathCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetCamelPathCollection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetCamelPathCollection(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_RoutePlan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CamelMessage_MissonFromAgvs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).RoutePlan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/RoutePlan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).RoutePlan(ctx, req.(*CamelMessage_MissonFromAgvs))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetRosNodeCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetRosNodeCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetRosNodeCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetRosNodeCfg(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SetRosNodeCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RosNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SetRosNodeCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SetRosNodeCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SetRosNodeCfg(ctx, req.(*RosNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_DeleteNodeCfg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RosNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).DeleteNodeCfg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/DeleteNodeCfg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).DeleteNodeCfg(ctx, req.(*RosNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_StopRosnode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RosNode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).StopRosnode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/StopRosnode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).StopRosnode(ctx, req.(*RosNode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetRosoutMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetRosoutMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetRosoutMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetRosoutMsg(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SetAvoidanceArea_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AvoidanceAreaCollection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SetAvoidanceArea(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SetAvoidanceArea",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SetAvoidanceArea(ctx, req.(*AvoidanceAreaCollection))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_AlarmUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AlarmMsg)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).AlarmUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/AlarmUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).AlarmUpload(ctx, req.(*AlarmMsg))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_QueryNetworkInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).QueryNetworkInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/QueryNetworkInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).QueryNetworkInformation(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SetNetworkInformation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SetNetworkInformation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SetNetworkInformation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SetNetworkInformation(ctx, req.(*NetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SearchWLANList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SearchWLANList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SearchWLANList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SearchWLANList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_ConnectWLAN_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WirlessConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).ConnectWLAN(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/ConnectWLAN",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).ConnectWLAN(ctx, req.(*WirlessConfig))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_LogExport_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).LogExport(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/LogExport",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).LogExport(ctx, req.(*LogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SoftwareUpgrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallPack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SoftwareUpgrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SoftwareUpgrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SoftwareUpgrade(ctx, req.(*InstallPack))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SoftwareBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SoftwareBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SoftwareBackup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SoftwareBackup(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SoftwareRollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstallPack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SoftwareRollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SoftwareRollback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SoftwareRollback(ctx, req.(*InstallPack))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_SoftwareDowngrade_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).SoftwareDowngrade(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/SoftwareDowngrade",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).SoftwareDowngrade(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_StickControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Gamepad)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).StickControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/StickControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).StickControl(ctx, req.(*Gamepad))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_ApplyStickControl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GamepadControl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).ApplyStickControl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/ApplyStickControl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).ApplyStickControl(ctx, req.(*GamepadControl))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_ModifyMatchPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchPointCommand)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).ModifyMatchPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/ModifyMatchPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).ModifyMatchPoint(ctx, req.(*MatchPointCommand))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_GetMatchPoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).GetMatchPoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/GetMatchPoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).GetMatchPoint(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_CarRestart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).CarRestart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/CarRestart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).CarRestart(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_UpdateStationPose_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).UpdateStationPose(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/UpdateStationPose",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).UpdateStationPose(ctx, req.(*UpdateStation))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_TaskAllocationOperation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrpcTaskOperation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).TaskAllocationOperation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/TaskAllocationOperation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).TaskAllocationOperation(ctx, req.(*GrpcTaskOperation))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgvService_AssignAllocationTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GrpcTaskAllocations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgvServiceServer).AssignAllocationTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/AgvService/AssignAllocationTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgvServiceServer).AssignAllocationTasks(ctx, req.(*GrpcTaskAllocations))
	}
	return interceptor(ctx, in, info, handler)
}

// AgvService_ServiceDesc is the grpc.ServiceDesc for AgvService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgvService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "AgvService",
	HandlerType: (*AgvServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UploadMapData",
			Handler:    _AgvService_UploadMapData_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _AgvService_GetVersion_Handler,
		},
		{
			MethodName: "GetAgvState",
			Handler:    _AgvService_GetAgvState_Handler,
		},
		{
			MethodName: "RequestUIConfig",
			Handler:    _AgvService_RequestUIConfig_Handler,
		},
		{
			MethodName: "GetSystemStatus",
			Handler:    _AgvService_GetSystemStatus_Handler,
		},
		{
			MethodName: "GetAgvStateInAgvs",
			Handler:    _AgvService_GetAgvStateInAgvs_Handler,
		},
		{
			MethodName: "SendToAgvs",
			Handler:    _AgvService_SendToAgvs_Handler,
		},
		{
			MethodName: "ControlAgv",
			Handler:    _AgvService_ControlAgv_Handler,
		},
		{
			MethodName: "SetCamelCfg",
			Handler:    _AgvService_SetCamelCfg_Handler,
		},
		{
			MethodName: "GetCamelCfg",
			Handler:    _AgvService_GetCamelCfg_Handler,
		},
		{
			MethodName: "GetCamelPathCollection",
			Handler:    _AgvService_GetCamelPathCollection_Handler,
		},
		{
			MethodName: "RoutePlan",
			Handler:    _AgvService_RoutePlan_Handler,
		},
		{
			MethodName: "GetRosNodeCfg",
			Handler:    _AgvService_GetRosNodeCfg_Handler,
		},
		{
			MethodName: "SetRosNodeCfg",
			Handler:    _AgvService_SetRosNodeCfg_Handler,
		},
		{
			MethodName: "DeleteNodeCfg",
			Handler:    _AgvService_DeleteNodeCfg_Handler,
		},
		{
			MethodName: "StopRosnode",
			Handler:    _AgvService_StopRosnode_Handler,
		},
		{
			MethodName: "GetRosoutMsg",
			Handler:    _AgvService_GetRosoutMsg_Handler,
		},
		{
			MethodName: "SetAvoidanceArea",
			Handler:    _AgvService_SetAvoidanceArea_Handler,
		},
		{
			MethodName: "AlarmUpload",
			Handler:    _AgvService_AlarmUpload_Handler,
		},
		{
			MethodName: "QueryNetworkInformation",
			Handler:    _AgvService_QueryNetworkInformation_Handler,
		},
		{
			MethodName: "SetNetworkInformation",
			Handler:    _AgvService_SetNetworkInformation_Handler,
		},
		{
			MethodName: "SearchWLANList",
			Handler:    _AgvService_SearchWLANList_Handler,
		},
		{
			MethodName: "ConnectWLAN",
			Handler:    _AgvService_ConnectWLAN_Handler,
		},
		{
			MethodName: "LogExport",
			Handler:    _AgvService_LogExport_Handler,
		},
		{
			MethodName: "SoftwareUpgrade",
			Handler:    _AgvService_SoftwareUpgrade_Handler,
		},
		{
			MethodName: "SoftwareBackup",
			Handler:    _AgvService_SoftwareBackup_Handler,
		},
		{
			MethodName: "SoftwareRollback",
			Handler:    _AgvService_SoftwareRollback_Handler,
		},
		{
			MethodName: "SoftwareDowngrade",
			Handler:    _AgvService_SoftwareDowngrade_Handler,
		},
		{
			MethodName: "StickControl",
			Handler:    _AgvService_StickControl_Handler,
		},
		{
			MethodName: "ApplyStickControl",
			Handler:    _AgvService_ApplyStickControl_Handler,
		},
		{
			MethodName: "ModifyMatchPoint",
			Handler:    _AgvService_ModifyMatchPoint_Handler,
		},
		{
			MethodName: "GetMatchPoint",
			Handler:    _AgvService_GetMatchPoint_Handler,
		},
		{
			MethodName: "CarRestart",
			Handler:    _AgvService_CarRestart_Handler,
		},
		{
			MethodName: "UpdateStationPose",
			Handler:    _AgvService_UpdateStationPose_Handler,
		},
		{
			MethodName: "TaskAllocationOperation",
			Handler:    _AgvService_TaskAllocationOperation_Handler,
		},
		{
			MethodName: "AssignAllocationTasks",
			Handler:    _AgvService_AssignAllocationTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobuf/camel-grpc.proto",
}
